===============================================================================
Module : mem
===============================================================================
SCORE  LINE   TOGGLE 
 75.65 100.00  51.30 

Source File(s) : 

/afs/umich.edu/user/z/t/ztguan/group6w22/testbench/mem.sv

Module self-instances :

SCORE  LINE   TOGGLE NAME              
 75.65 100.00  51.30 cache_tb.mem_inst 



-------------------------------------------------------------------------------
Line Coverage for Module : mem

             Line No.   Total   Covered  Percent
TOTAL                       33       33   100.00
ALWAYS             51       24       24   100.00
INITIAL           175        9        9   100.00

50                      	always @(negedge clk) begin
51         1/1          		next_mem2proc_tag      = 4'b0;
52         1/1          		next_mem2proc_response = 4'b0;
53         1/1          		next_mem2proc_data     = 64'bx;
54         1/1          		bus_filled             = 1'b0;
55         1/1          		acquire_tag            = ((proc2mem_command == BUS_LOAD) ||
56                      		                          (proc2mem_command == BUS_STORE)) && valid_address;
57                      		
58         1/1          		for(int i=1;i<=`NUM_MEM_TAGS;i=i+1) begin
59         1/1          			if(cycles_left[i]>16'd0) begin
60         1/1          				cycles_left[i] = cycles_left[i]-16'd1;
61                      			
62         1/1          			end else if(acquire_tag && !waiting_for_bus[i]) begin
63         1/1          				next_mem2proc_response = i;
64         1/1          				acquire_tag            = 1'b0;
65         1/1          				cycles_left[i]         = `MEM_LATENCY_IN_CYCLES; 
66                      				                          // must add support for random lantencies
67                      				                          // though this could be done via a non-number
68                      				                          // definition for this macro
69                      				
70         1/1          				if(proc2mem_command == BUS_LOAD) begin
71         1/1          					waiting_for_bus[i] = 1'b1;
72         1/1          					loaded_data[i]     = unified_memory[proc2mem_addr[`XLEN-1:3]];
73                      				end else begin
74         1/1          					unified_memory[proc2mem_addr[`XLEN-1:3]]=proc2mem_data;
75                      				end
76                      			end
                        MISSING_ELSE
77                      			
78         1/1          			if((cycles_left[i]==16'd0) && waiting_for_bus[i] && !bus_filled) begin
79         1/1          					bus_filled         = 1'b1;
80         1/1          					next_mem2proc_tag  = i;
81         1/1          					next_mem2proc_data = loaded_data[i];
82         1/1          					waiting_for_bus[i] = 1'b0;
83                      			end
                        MISSING_ELSE
84                      		end
85         1/1          		mem2proc_response <= `SD next_mem2proc_response;
86         1/1          		mem2proc_data     <= `SD next_mem2proc_data;
87         1/1          		mem2proc_tag      <= `SD next_mem2proc_tag;
88                      	end
89                      `else
90                          wire valid_address = (proc2mem_addr<`MEM_SIZE_IN_BYTES);
91                      	EXAMPLE_CACHE_BLOCK c;
92                          // temporary wires for byte level selection because verilog does not support variable range selection
93                      	always @(negedge clk) begin
94                      		next_mem2proc_tag      = 4'b0;
95                      		next_mem2proc_response = 4'b0;
96                      		next_mem2proc_data     = 64'bx;
97                      		bus_filled             = 1'b0;
98                      		acquire_tag            = ((proc2mem_command == BUS_LOAD) ||
99                      		                          (proc2mem_command == BUS_STORE)) && valid_address;
100                     		
101                     		for(int i=1;i<=`NUM_MEM_TAGS;i=i+1) begin
102                     			if(cycles_left[i]>16'd0) begin
103                     				cycles_left[i] = cycles_left[i]-16'd1;
104                     			
105                     			end else if(acquire_tag && !waiting_for_bus[i]) begin
106                     				next_mem2proc_response = i;
107                     				acquire_tag            = 1'b0;
108                     				cycles_left[i]         = `MEM_LATENCY_IN_CYCLES; 
109                     				                          // must add support for random lantencies
110                     				                          // though this could be done via a non-number
111                     				                          // definition for this macro
112                     				//filling up these temp variables
113                     				c.byte_level = unified_memory[proc2mem_addr[`XLEN-1:3]];
114                     				c.half_level = unified_memory[proc2mem_addr[`XLEN-1:3]];
115                     				c.word_level = unified_memory[proc2mem_addr[`XLEN-1:3]];
116                     
117                     				if(proc2mem_command == BUS_LOAD) begin
118                     					waiting_for_bus[i] = 1'b1;
119                     					loaded_data[i]     = unified_memory[proc2mem_addr[`XLEN-1:3]];
120                                     	case (proc2mem_size) 
121                                             BYTE: begin
122                     							loaded_data[i] = {56'b0, c.byte_level[proc2mem_addr[2:0]]};
123                                             end
124                                             HALF: begin
125                     							assert(proc2mem_addr[0] == 0);
126                     							loaded_data[i] = {48'b0, c.half_level[proc2mem_addr[2:1]]};
127                                             end
128                                             WORD: begin
129                     							assert(proc2mem_addr[1:0] == 0);
130                     							loaded_data[i] = {32'b0, c.word_level[proc2mem_addr[2]]};
131                                             end
132                     						DOUBLE:
133                     							loaded_data[i] = unified_memory[proc2mem_addr[`XLEN-1:3]];
134                     					endcase
135                     
136                     				end else begin
137                     					case (proc2mem_size) 
138                                             BYTE: begin
139                     							c.byte_level[proc2mem_addr[2:0]] = proc2mem_data[7:0];
140                                                 unified_memory[proc2mem_addr[`XLEN-1:3]] = c.byte_level;
141                                             end
142                                             HALF: begin
143                     							assert(proc2mem_addr[0] == 0);
144                     							c.half_level[proc2mem_addr[2:1]] = proc2mem_data[15:0];
145                                                 unified_memory[proc2mem_addr[`XLEN-1:3]] = c.half_level;
146                                             end
147                                             WORD: begin
148                     							assert(proc2mem_addr[1:0] == 0);
149                     							c.word_level[proc2mem_addr[2]] = proc2mem_data[31:0];
150                                                 unified_memory[proc2mem_addr[`XLEN-1:3]] = c.word_level;
151                                             end
152                                             default: begin
153                     							assert(proc2mem_addr[1:0] == 0);
154                     							c.byte_level[proc2mem_addr[2]] = proc2mem_data[31:0];
155                                                 unified_memory[proc2mem_addr[`XLEN-1:3]] = c.word_level;
156                                             end
157                     					endcase
158                     				end
159                     			end
160                     			
161                     			if((cycles_left[i]==16'd0) && waiting_for_bus[i] && !bus_filled) begin
162                     					bus_filled         = 1'b1;
163                     					next_mem2proc_tag  = i;
164                     					next_mem2proc_data = loaded_data[i];
165                     					waiting_for_bus[i] = 1'b0;
166                     			end
167                     		end
168                     		mem2proc_response <= `SD next_mem2proc_response;
169                     		mem2proc_data     <= `SD next_mem2proc_data;
170                     		mem2proc_tag      <= `SD next_mem2proc_tag;
171                     	end
172                     `endif //CACHE_MODE
173                     	// Initialise the entire memory
174                     	initial begin
175        1/1          		for(int i=0; i<`MEM_64BIT_LINES; i=i+1) begin
176        1/1          			unified_memory[i] = 64'h0;
177                     		end
178        1/1          		mem2proc_data=64'bx;
179        1/1          		mem2proc_tag=4'd0;
180        1/1          		mem2proc_response=4'd0;
181        1/1          		for(int i=1;i<=`NUM_MEM_TAGS;i=i+1) begin
182        1/1          			loaded_data[i]=64'bx;
183        1/1          			cycles_left[i]=16'd0;
184        1/1          			waiting_for_bus[i]=1'b0;

-------------------------------------------------------------------------------
Toggle Coverage for Module : mem
                Total Covered Percent 
Totals          15    10      66.67   
Total Bits      1002  514     51.30   
Total Bits 0->1 501   257     51.30   
Total Bits 1->0 501   257     51.30   

                              
Ports          7   6   85.71  
Port Bits      342 304 88.89  
Port Bits 0->1 171 152 88.89  
Port Bits 1->0 171 152 88.89  

                                
Signals          8   4   50.00  
Signal Bits      660 210 31.82  
Signal Bits 0->1 330 105 31.82  
Signal Bits 1->0 330 105 31.82  

Port Details
                       Toggle Toggle 1->0 Toggle 0->1 Direction 
clk                    Yes    Yes         Yes         INPUT     
proc2mem_addr[2:0]     No     No          No          INPUT     
proc2mem_addr[15:3]    Yes    Yes         Yes         INPUT     
proc2mem_addr[31:16]   No     No          No          INPUT     
proc2mem_data[63:0]    Yes    Yes         Yes         INPUT     
proc2mem_command[1:0]  Yes    Yes         Yes         INPUT     
mem2proc_response[3:0] Yes    Yes         Yes         OUTPUT    
mem2proc_data[63:0]    Yes    Yes         Yes         OUTPUT    
mem2proc_tag[3:0]      Yes    Yes         Yes         OUTPUT    

Signal Details
                                      Toggle Toggle 1->0 Toggle 0->1 
next_mem2proc_data[63:0]              Yes    Yes         Yes         
next_mem2proc_response[3:0]           Yes    Yes         Yes         
next_mem2proc_tag[3:0]                Yes    Yes         Yes         
cycles_left[1][2:0]                   Yes    Yes         Yes         
cycles_left[2][2:0]                   Yes    Yes         Yes         
cycles_left[3][2:0]                   Yes    Yes         Yes         
cycles_left[4][2:0]                   Yes    Yes         Yes         
cycles_left[5][2:0]                   Yes    Yes         Yes         
cycles_left[6][2:0]                   Yes    Yes         Yes         
cycles_left[7][2:0]                   Yes    Yes         Yes         
cycles_left[8][2:0]                   Yes    Yes         Yes         
Other bits of cycles_left[15:1][15:0] No     No          No          
waiting_for_bus[8:1]                  Yes    Yes         Yes         
waiting_for_bus[15:9]                 No     No          No          
acquire_tag                           No     No          No          
bus_filled                            Yes    Yes         Yes         
valid_address                         No     No          No          


-------------------------------------------------------------------------------
===============================================================================
Module Instance : cache_tb.mem_inst
===============================================================================

Instance :

SCORE  LINE   TOGGLE 
 75.65 100.00  51.30 


Instance's subtree :

SCORE  LINE   TOGGLE 
 75.65 100.00  51.30 


Module : 

SCORE  LINE   TOGGLE NAME 
 75.65 100.00  51.30 mem  


Parent : 

SCORE  LINE   TOGGLE NAME     
100.00 100.00 100.00 cache_tb 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : evict_hit_detector
===============================================================================
SCORE  LINE   TOGGLE 
 75.71  71.43  80.00 

Source File(s) : 

/afs/umich.edu/user/z/t/ztguan/group6w22/verilog/evict_hit_detector.sv

Module self-instances :

SCORE  LINE   TOGGLE NAME                                                 
 75.71  71.43  80.00 cache_tb.dut.cache_ctrl_inst.evict_hit_detector_inst 



-------------------------------------------------------------------------------
Line Coverage for Module : evict_hit_detector

             Line No.   Total   Covered  Percent
TOTAL                        7        5    71.43
ALWAYS             34        7        5    71.43

33                          always_comb begin
34         1/1                  evict_hit_o      =   1'b0;
35         1/1                  evict_hit_idx_o  =   'd0;
36         1/1                  if (proc2cache_i.command != BUS_NONE) begin
37         1/1                      for (int unsigned entry_idx = 1; entry_idx < C_MSHR_ENTRY_NUM; entry_idx++) begin
38                                      // IF   the entry content is valid
39                                      // AND  the address from processor matches the address of current entry
40                                      // AND  current entry is the least older miss to this address
41                                      // ->   MSHR hit is detected
42         1/1                          if ((mshr_array_i[entry_idx].cmd != BUS_NONE)
43                                      &&  (mshr_array_i[entry_idx].evict_dirty == 1'b1)
44                                      &&  (mshr_array_i[entry_idx].evict_addr[C_XLEN-1:C_CACHE_OFFSET_WIDTH] 
45                                      == proc2cache_i.addr[C_XLEN-1:C_CACHE_OFFSET_WIDTH])) begin
46         0/1     ==>                      evict_hit_o      =   1'b1;
47         0/1     ==>                      evict_hit_idx_o  =   entry_idx;
48                                      end
                        MISSING_ELSE
49                                  end
50                              end
                        MISSING_ELSE

-------------------------------------------------------------------------------
Toggle Coverage for Module : evict_hit_detector
                Total Covered Percent 
Totals          6     3       50.00   
Total Bits      210   168     80.00   
Total Bits 0->1 105   84      80.00   
Total Bits 1->0 105   84      80.00   

                              
Ports          6   3   50.00  
Port Bits      210 168 80.00  
Port Bits 0->1 105 84  80.00  
Port Bits 1->0 105 84  80.00  

Port Details
                          Toggle Toggle 1->0 Toggle 0->1 Direction 
proc2cache_i.command[1:0] Yes    Yes         Yes         INPUT     
proc2cache_i.size[1:0]    Yes    Yes         Yes         INPUT     
proc2cache_i.data[63:0]   Yes    Yes         Yes         INPUT     
proc2cache_i.addr[15:0]   Yes    Yes         Yes         INPUT     
proc2cache_i.addr[31:16]  No     No          No          INPUT     
evict_hit_o               No     No          No          OUTPUT    
evict_hit_idx_o[3:0]      No     No          No          OUTPUT    


-------------------------------------------------------------------------------
===============================================================================
Module Instance : cache_tb.dut.cache_ctrl_inst.evict_hit_detector_inst
===============================================================================

Instance :

SCORE  LINE   TOGGLE 
 75.71  71.43  80.00 


Instance's subtree :

SCORE  LINE   TOGGLE 
 75.71  71.43  80.00 


Module : 

SCORE  LINE   TOGGLE NAME               
 75.71  71.43  80.00 evict_hit_detector 


Parent : 

SCORE  LINE   TOGGLE NAME            
 92.38 100.00  84.76 cache_ctrl_inst 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : cache
===============================================================================
SCORE  LINE   TOGGLE 
 81.99 --      81.99 

Source File(s) : 

/afs/umich.edu/user/z/t/ztguan/group6w22/verilog/cache.sv

Module self-instances :

SCORE  LINE   TOGGLE NAME         
 81.99 --      81.99 cache_tb.dut 



-------------------------------------------------------------------------------
Toggle Coverage for Module : cache
                Total Covered Percent 
Totals          25    17      68.00   
Total Bits      1216  997     81.99   
Total Bits 0->1 608   498     81.91   
Total Bits 1->0 608   499     82.07   

                              
Ports          17  12  70.59  
Port Bits      694 597 86.02  
Port Bits 0->1 347 298 85.88  
Port Bits 1->0 347 299 86.17  

                                
Signals          8   5   62.50  
Signal Bits      522 400 76.63  
Signal Bits 0->1 261 200 76.63  
Signal Bits 1->0 261 200 76.63  

Port Details
                           Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i                      Yes    Yes         Yes         INPUT     
rst_i                      No     Yes         No          INPUT     
proc2cache_i.command[1:0]  Yes    Yes         Yes         INPUT     
proc2cache_i.size[1:0]     Yes    Yes         Yes         INPUT     
proc2cache_i.data[63:0]    Yes    Yes         Yes         INPUT     
proc2cache_i.addr[15:0]    Yes    Yes         Yes         INPUT     
proc2cache_i.addr[31:16]   No     No          No          INPUT     
cache2proc_o.tag[3:0]      Yes    Yes         Yes         OUTPUT    
cache2proc_o.data[18:0]    Yes    Yes         Yes         OUTPUT    
cache2proc_o.data[19]      No     No          No          OUTPUT    
cache2proc_o.data[24:20]   Yes    Yes         Yes         OUTPUT    
cache2proc_o.data[25]      No     No          No          OUTPUT    
cache2proc_o.data[33:26]   Yes    Yes         Yes         OUTPUT    
cache2proc_o.data[34]      No     No          No          OUTPUT    
cache2proc_o.data[41:35]   Yes    Yes         Yes         OUTPUT    
cache2proc_o.data[43:42]   No     No          No          OUTPUT    
cache2proc_o.data[44]      Yes    Yes         Yes         OUTPUT    
cache2proc_o.data[46:45]   No     No          No          OUTPUT    
cache2proc_o.data[49:47]   Yes    Yes         Yes         OUTPUT    
cache2proc_o.data[51:50]   No     No          No          OUTPUT    
cache2proc_o.data[54:52]   Yes    Yes         Yes         OUTPUT    
cache2proc_o.data[55]      No     No          No          OUTPUT    
cache2proc_o.data[58:56]   Yes    Yes         Yes         OUTPUT    
cache2proc_o.data[59]      No     No          No          OUTPUT    
cache2proc_o.data[62:60]   Yes    Yes         Yes         OUTPUT    
cache2proc_o.data[63]      No     No          No          OUTPUT    
cache2proc_o.response[3:0] Yes    Yes         Yes         OUTPUT    
memory_enable_i            No     No          No          INPUT     
cache2mem_o.command[1:0]   Yes    Yes         Yes         OUTPUT    
cache2mem_o.size[1:0]      Yes    Yes         Yes         OUTPUT    
cache2mem_o.data[63:0]     Yes    Yes         Yes         OUTPUT    
cache2mem_o.addr[2:0]      No     No          No          OUTPUT    
cache2mem_o.addr[15:3]     Yes    Yes         Yes         OUTPUT    
cache2mem_o.addr[31:16]    No     No          No          OUTPUT    
mem2cache_i.tag[3:0]       Yes    Yes         Yes         INPUT     
mem2cache_i.data[63:0]     Yes    Yes         Yes         INPUT     
mem2cache_i.response[3:0]  Yes    Yes         Yes         INPUT     

Signal Details
                                   Toggle Toggle 1->0 Toggle 0->1 
cache_ctrl_mem.req_data_in[63:0]   Yes    Yes         Yes         
cache_ctrl_mem.req_addr[15:0]      Yes    Yes         Yes         
cache_ctrl_mem.req_addr[31:16]     No     No          No          
cache_ctrl_mem.req_cmd[2:0]        Yes    Yes         Yes         
cache_mem_ctrl.evict_data[63:0]    Yes    Yes         Yes         
cache_mem_ctrl.evict_addr[2:0]     No     No          No          
cache_mem_ctrl.evict_addr[15:3]    Yes    Yes         Yes         
cache_mem_ctrl.evict_addr[31:16]   No     No          No          
cache_mem_ctrl.evict_dirty         Yes    Yes         Yes         
cache_mem_ctrl.req_data_out[4:0]   Yes    Yes         Yes         
cache_mem_ctrl.req_data_out[6:5]   No     No          No          
cache_mem_ctrl.req_data_out[8:7]   Yes    Yes         Yes         
cache_mem_ctrl.req_data_out[11:9]  No     No          No          
cache_mem_ctrl.req_data_out[13:12] Yes    Yes         Yes         
cache_mem_ctrl.req_data_out[15:14] No     No          No          
cache_mem_ctrl.req_data_out[25:16] Yes    Yes         Yes         
cache_mem_ctrl.req_data_out[26]    No     No          No          
cache_mem_ctrl.req_data_out[31:27] Yes    Yes         Yes         
cache_mem_ctrl.req_data_out[33:32] No     No          No          
cache_mem_ctrl.req_data_out[34]    Yes    Yes         Yes         
cache_mem_ctrl.req_data_out[37:35] No     No          No          
cache_mem_ctrl.req_data_out[38]    Yes    Yes         Yes         
cache_mem_ctrl.req_data_out[41:39] No     No          No          
cache_mem_ctrl.req_data_out[42]    Yes    Yes         Yes         
cache_mem_ctrl.req_data_out[45:43] No     No          No          
cache_mem_ctrl.req_data_out[47:46] Yes    Yes         Yes         
cache_mem_ctrl.req_data_out[50:48] No     No          No          
cache_mem_ctrl.req_data_out[52:51] Yes    Yes         Yes         
cache_mem_ctrl.req_data_out[54:53] No     No          No          
cache_mem_ctrl.req_data_out[58:55] Yes    Yes         Yes         
cache_mem_ctrl.req_data_out[60:59] No     No          No          
cache_mem_ctrl.req_data_out[63:61] Yes    Yes         Yes         
cache_mem_ctrl.req_hit             Yes    Yes         Yes         


-------------------------------------------------------------------------------
===============================================================================
Module Instance : cache_tb.dut
===============================================================================

Instance :

SCORE  LINE   TOGGLE 
 81.99 --      81.99 


Instance's subtree :

SCORE  LINE   TOGGLE 
 81.94  83.13  80.75 


Module : 

SCORE  LINE   TOGGLE NAME  
 81.99 --      81.99 cache 


Parent : 

SCORE  LINE   TOGGLE NAME     
100.00 100.00 100.00 cache_tb 


Subtrees :

SCORE  LINE   TOGGLE NAME            
 81.20  81.80  80.61 cache_ctrl_inst 
 93.94 100.00  87.87 cache_mem_inst  



-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : cache_if
===============================================================================
SCORE  LINE   TOGGLE 
 86.02 --      86.02 

Source File(s) : 

/afs/umich.edu/user/z/t/ztguan/group6w22/testbench/cache_tb.sv

Module self-instances :

SCORE  LINE   TOGGLE NAME         
 86.02 --      86.02 cache_tb._if 



-------------------------------------------------------------------------------
Toggle Coverage for Module : cache_if
                Total Covered Percent 
Totals          17    12      70.59   
Total Bits      694   597     86.02   
Total Bits 0->1 347   298     85.88   
Total Bits 1->0 347   299     86.17   

                          
Ports          1 1 100.00 
Port Bits      2 2 100.00 
Port Bits 0->1 1 1 100.00 
Port Bits 1->0 1 1 100.00 

                                
Signals          16  11  68.75  
Signal Bits      692 595 85.98  
Signal Bits 0->1 346 297 85.84  
Signal Bits 1->0 346 298 86.13  

Port Details
      Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i Yes    Yes         Yes         INPUT     

Signal Details
                           Toggle Toggle 1->0 Toggle 0->1 
rst_i                      No     Yes         No          
proc2cache_i.command[1:0]  Yes    Yes         Yes         
proc2cache_i.size[1:0]     Yes    Yes         Yes         
proc2cache_i.data[63:0]    Yes    Yes         Yes         
proc2cache_i.addr[15:0]    Yes    Yes         Yes         
proc2cache_i.addr[31:16]   No     No          No          
cache2proc_o.tag[3:0]      Yes    Yes         Yes         
cache2proc_o.data[18:0]    Yes    Yes         Yes         
cache2proc_o.data[19]      No     No          No          
cache2proc_o.data[24:20]   Yes    Yes         Yes         
cache2proc_o.data[25]      No     No          No          
cache2proc_o.data[33:26]   Yes    Yes         Yes         
cache2proc_o.data[34]      No     No          No          
cache2proc_o.data[41:35]   Yes    Yes         Yes         
cache2proc_o.data[43:42]   No     No          No          
cache2proc_o.data[44]      Yes    Yes         Yes         
cache2proc_o.data[46:45]   No     No          No          
cache2proc_o.data[49:47]   Yes    Yes         Yes         
cache2proc_o.data[51:50]   No     No          No          
cache2proc_o.data[54:52]   Yes    Yes         Yes         
cache2proc_o.data[55]      No     No          No          
cache2proc_o.data[58:56]   Yes    Yes         Yes         
cache2proc_o.data[59]      No     No          No          
cache2proc_o.data[62:60]   Yes    Yes         Yes         
cache2proc_o.data[63]      No     No          No          
cache2proc_o.response[3:0] Yes    Yes         Yes         
memory_enable_i            No     No          No          
cache2mem_o.command[1:0]   Yes    Yes         Yes         
cache2mem_o.size[1:0]      Yes    Yes         Yes         
cache2mem_o.data[63:0]     Yes    Yes         Yes         
cache2mem_o.addr[2:0]      No     No          No          
cache2mem_o.addr[15:3]     Yes    Yes         Yes         
cache2mem_o.addr[31:16]    No     No          No          
mem2cache_i.tag[3:0]       Yes    Yes         Yes         
mem2cache_i.data[63:0]     Yes    Yes         Yes         
mem2cache_i.response[3:0]  Yes    Yes         Yes         


-------------------------------------------------------------------------------
===============================================================================
Module Instance : cache_tb._if
===============================================================================

Instance :

SCORE  LINE   TOGGLE 
 86.02 --      86.02 


Instance's subtree :

SCORE  LINE   TOGGLE 
 86.02 --      86.02 


Module : 

SCORE  LINE   TOGGLE NAME     
 86.02 --      86.02 cache_if 


Parent : 

SCORE  LINE   TOGGLE NAME     
100.00 100.00 100.00 cache_tb 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : mshr_entry_ctrl
===============================================================================
SCORE  LINE   TOGGLE 
 87.59  90.48  84.70 

Source File(s) : 

/afs/umich.edu/user/z/t/ztguan/group6w22/verilog/mshr_entry_ctrl.sv

Module self-instances :

SCORE  LINE   TOGGLE NAME                                                          
 72.30  72.86  71.74 cache_tb.dut.cache_ctrl_inst.genblk1[12].mshr_entry_ctrl_inst 
 74.74  73.81  75.66 cache_tb.dut.cache_ctrl_inst.genblk1[14].mshr_entry_ctrl_inst 
 74.83  72.38  77.27 cache_tb.dut.cache_ctrl_inst.genblk1[13].mshr_entry_ctrl_inst 
 75.56  72.86  78.26 cache_tb.dut.cache_ctrl_inst.genblk1[15].mshr_entry_ctrl_inst 
 76.96  73.81  80.12 cache_tb.dut.cache_ctrl_inst.genblk1[11].mshr_entry_ctrl_inst 
 78.87  79.52  78.22 cache_tb.dut.cache_ctrl_inst.genblk1[10].mshr_entry_ctrl_inst 
 80.97  80.00  81.94 cache_tb.dut.cache_ctrl_inst.genblk1[8].mshr_entry_ctrl_inst  
 83.68  85.71  81.65 cache_tb.dut.cache_ctrl_inst.genblk1[9].mshr_entry_ctrl_inst  
 84.01  85.71  82.31 cache_tb.dut.cache_ctrl_inst.genblk1[2].mshr_entry_ctrl_inst  
 84.03  85.71  82.35 cache_tb.dut.cache_ctrl_inst.genblk1[5].mshr_entry_ctrl_inst  
 84.11  85.71  82.51 cache_tb.dut.cache_ctrl_inst.genblk1[4].mshr_entry_ctrl_inst  
 84.60  87.14  82.06 cache_tb.dut.cache_ctrl_inst.genblk1[3].mshr_entry_ctrl_inst  
 84.68  87.14  82.23 cache_tb.dut.cache_ctrl_inst.genblk1[7].mshr_entry_ctrl_inst  
 84.75  85.71  83.79 cache_tb.dut.cache_ctrl_inst.genblk1[6].mshr_entry_ctrl_inst  
 86.35  89.52  83.18 cache_tb.dut.cache_ctrl_inst.genblk1[1].mshr_entry_ctrl_inst  



-------------------------------------------------------------------------------
Line Coverage for Module : mshr_entry_ctrl

             Line No.   Total   Covered  Percent
TOTAL                      210      190    90.48
ALWAYS             75       17       17   100.00
ALWAYS             97      135      118    87.41
ALWAYS            317       25       22    88.00
ALWAYS            368       22       22   100.00
ALWAYS            411       11       11   100.00

74                          always_ff @(posedge clk_i) begin
75         1/1                  if (rst_i) begin
76         1/1                      mshr_entry.state        <=  `SD ST_IDLE     ;
77         1/1                      mshr_entry.cmd          <=  `SD BUS_NONE    ;
78         1/1                      mshr_entry.req_addr     <=  `SD 'b0         ;
79         1/1                      mshr_entry.req_data     <=  `SD 'b0         ;
80         1/1                      mshr_entry.req_size     <=  `SD BYTE        ;
81         1/1                      mshr_entry.evict_addr   <=  `SD 'b0         ;
82         1/1                      mshr_entry.evict_data   <=  `SD 'b0         ;
83         1/1                      mshr_entry.evict_dirty  <=  `SD 1'b0        ;
84         1/1                      mshr_entry.link_idx     <=  `SD 'd0         ;
85         1/1                      mshr_entry.linked       <=  `SD 1'b0        ;
86         1/1                      mshr_entry.mem_tag      <=  `SD 'd0         ;
87         1/1                      mshr_cp_flag_o          <=  `SD 1'b0        ;
88         1/1                      mshr_cp_data_o          <=  `SD 'b0         ;
89                              end else begin
90         1/1                      mshr_entry              <=  `SD next_mshr_entry     ;
91         1/1                      mshr_cp_flag_o          <=  `SD next_mshr_cp_flag   ;
92         1/1                      mshr_cp_data_o          <=  `SD next_mshr_cp_data   ;
93                              end
94                          end
95                      
96                          always_comb begin
97         1/1                  next_mshr_entry.state       =   mshr_entry.state        ;
98         1/1                  next_mshr_entry.cmd         =   mshr_entry.cmd          ;
99         1/1                  next_mshr_entry.req_addr    =   mshr_entry.req_addr     ;
100        1/1                  next_mshr_entry.req_data    =   mshr_entry.req_data     ;
101        1/1                  next_mshr_entry.req_size    =   mshr_entry.req_size     ;
102        1/1                  next_mshr_entry.evict_addr  =   mshr_entry.evict_addr   ;
103        1/1                  next_mshr_entry.evict_data  =   mshr_entry.evict_data   ;
104        1/1                  next_mshr_entry.evict_dirty =   mshr_entry.evict_dirty  ;
105        1/1                  next_mshr_entry.link_idx    =   mshr_entry.link_idx     ;
106        1/1                  next_mshr_entry.linked      =   mshr_entry.linked       ;
107        1/1                  next_mshr_entry.mem_tag     =   mshr_entry.mem_tag      ;
108        1/1                  next_mshr_cp_flag           =   mshr_cp_flag_o          ;
109        1/1                  next_mshr_cp_data           =   mshr_cp_data_o          ;
110        1/1                  case (mshr_entry.state)
111                                 ST_IDLE     :   begin
112                                     // IF   there is a valid transaction on Processor Interface
113                                     // AND  the Processor Interface is granted to this entry
114                                     // AND  the cache_mem Interface is granted to this entry
115                                     // AND  it is a miss
116                                     // AND  the entry is selected to hold the new miss
117        1/1                          if ((proc2cache_i.command != BUS_NONE) && (dp_sel_i == 1'b1)
118                                     && (proc_grant_i == 1'b1)) begin
119                                         // IF   there is an older in-flight transaction to the same addreess
120                                         // ->   Wait for the completion of older miss to the same address
121        1/1                              if (mshr_hit_i && (cp_flag_i[mshr_hit_idx_i] == 1'b0)) begin
122        1/1                                  next_mshr_entry.state       =   ST_WAIT_DEPEND          ;
123        1/1                                  next_mshr_entry.link_idx    =   mshr_hit_idx_i          ;
124        1/1                                  next_mshr_entry.cmd         =   proc2cache_i.command    ;
125        1/1                                  next_mshr_entry.req_addr    =   proc2cache_i.addr       ;
126        1/1                                  next_mshr_entry.req_size    =   proc2cache_i.size       ;
127        1/1                                  if (proc2cache_i.command == BUS_STORE) begin
128        1/1                                      next_mshr_entry.req_data    =   proc2cache_i.data   ;
129                                             end
                        MISSING_ELSE
130                                         // IF   there is an older in-flight transaction that is in the middle of evicting the data block
131                                         // ->   Wait for the completion of write-back to memory
132        1/1                              end else if (evict_hit_i && (cp_flag_i[evict_hit_idx_i] == 1'b0)) begin
133        0/1     ==>                          next_mshr_entry.state       =   ST_WAIT_EVICT           ;
134        0/1     ==>                          next_mshr_entry.link_idx    =   evict_hit_idx_i         ;
135        0/1     ==>                          next_mshr_entry.cmd         =   proc2cache_i.command    ;
136        0/1     ==>                          next_mshr_entry.req_addr    =   proc2cache_i.addr       ;
137        0/1     ==>                          next_mshr_entry.req_size    =   proc2cache_i.size       ;
138        0/1     ==>                          if (proc2cache_i.command == BUS_STORE) begin
139        0/1     ==>                              next_mshr_entry.req_data    =   proc2cache_i.data   ;
140                                             end
                   ==>  MISSING_ELSE
141                                         // IF   it is a miss, and no dependency to older in-flight transactions.
142                                         // ->   Start miss handling
143        1/1                              end else if ((cache_mem_ctrl_i.req_hit == 1'b0) && (cache_mem_grant_i == 1'b1)) begin
144        1/1                                  next_mshr_entry.state       =   ST_RD_MEM               ;
145        1/1                                  next_mshr_entry.link_idx    =   'd0                     ;
146        1/1                                  next_mshr_entry.cmd         =   proc2cache_i.command    ;
147        1/1                                  next_mshr_entry.req_addr    =   proc2cache_i.addr       ;
148        1/1                                  next_mshr_entry.req_size    =   proc2cache_i.size       ;
149        1/1                                  if (proc2cache_i.command == BUS_STORE) begin
150        1/1                                      next_mshr_entry.req_data    =   proc2cache_i.data   ;
151                                             end
                        MISSING_ELSE
152                                         end
                        MISSING_ELSE
153                                     end
                        MISSING_ELSE
154        1/1                          next_mshr_cp_flag   =   1'b0    ;
155        1/1                          next_mshr_cp_data   =   'b0     ;
156                                 end
157                                 ST_WAIT_DEPEND  :   begin
158                                     // IF   the older transaction that the entry is linked to completed
159                                     // ->   Update the cache data
160        1/1                          if (cp_flag_i[mshr_entry.link_idx] == 1'b1) begin
161        1/1                              next_mshr_entry.state       =   ST_UPDATE   ;
162        1/1                              next_mshr_entry.link_idx    =   'd0         ;
163        1/1                              next_mshr_entry.req_data    =   cp_data_i[mshr_entry.link_idx];
164        1/1                              if (mshr_entry.cmd == BUS_STORE) begin
165        0/1     ==>                          case (mshr_entry.req_size)
166        0/1     ==>                              BYTE    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +:  8]    =   mshr_entry.req_data[ 7:0]   ;
167        0/1     ==>                              HALF    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +: 16]    =   mshr_entry.req_data[15:0]   ;
168        0/1     ==>                              WORD    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +: 32]    =   mshr_entry.req_data[31:0]   ;
169        0/1     ==>                              DOUBLE  :   next_mshr_entry.req_data                                    =   mshr_entry.req_data         ;
170        0/1     ==>                              default :   next_mshr_entry.req_data                                    =   mshr_entry.req_data         ;
171                                             endcase
172                                         end
                        MISSING_ELSE
173                                     end
                        MISSING_ELSE
174                                 end
175                                 ST_WAIT_EVICT   : begin
176                                     // IF   the older transaction that evicts the cache block completed
177                                     // ->   Read from Memory
178        0/1     ==>                  if (cp_flag_i[mshr_entry.link_idx] == 1'b1) begin
179        0/1     ==>                      next_mshr_entry.state       =   ST_RD_MEM   ;
180        0/1     ==>                      next_mshr_entry.link_idx    =   'd0         ;
181                                     end
                   ==>  MISSING_ELSE
182                                 end
183                                 ST_RD_MEM   :   begin
184                                     // IF   the read transaction is confirmed by Memory Interface
185                                     // ->   Wait for the data to return from Memory
186        1/1                          if ((memory_grant_i == 1'b1) && (mem2cache_i.response != 'd0)) begin
187        1/1                              next_mshr_entry.state       =   ST_WAIT_MEM             ;
188        1/1                              next_mshr_entry.mem_tag     =   mem2cache_i.response    ;
189                                     end
                        MISSING_ELSE
190                                 end
191                                 ST_WAIT_MEM :   begin
192                                     // IF   the data is returned from the Memory
193                                     // ->   Update the cache data
194        1/1                          if (mem2cache_i.tag == mshr_entry.mem_tag) begin
195        1/1                              next_mshr_entry.state       =   ST_UPDATE           ;
196        1/1                              next_mshr_entry.req_data    =   mem2cache_i.data    ;
197        1/1                              if (mshr_entry.cmd == BUS_STORE) begin
198        1/1                                  case (mshr_entry.req_size)
199        1/1                                      BYTE    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +:  8]    =   mshr_entry.req_data[ 7:0]   ;
200        1/1                                      HALF    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +: 16]    =   mshr_entry.req_data[15:0]   ;
201        1/1                                      WORD    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +: 32]    =   mshr_entry.req_data[31:0]   ;
202        1/1                                      DOUBLE  :   next_mshr_entry.req_data                                    =   mshr_entry.req_data         ;
203        0/1     ==>                              default :   next_mshr_entry.req_data                                    =   mshr_entry.req_data         ;
204                                             endcase
205                                         end
                        MISSING_ELSE
206                                     end
                        MISSING_ELSE
207                                 end
208                                 ST_UPDATE   :   begin
209                                     // IF   the req interface is granted to this entry
210        1/1                          if (cache_mem_grant_i == 1'b1) begin
211                                         // IF   it is a load miss
212                                         // ->   Output data to processor
213        1/1                              if (mshr_entry.cmd == BUS_LOAD) begin
214        1/1                                  next_mshr_entry.state       =   ST_OUTPUT;
215        1/1                                  next_mshr_entry.evict_addr  =   cache_mem_ctrl_i.evict_addr ;
216        1/1                                  next_mshr_entry.evict_data  =   cache_mem_ctrl_i.evict_data ;
217        1/1                                  next_mshr_entry.evict_dirty =   cache_mem_ctrl_i.evict_dirty;
218                                         // IF   a dirty block is evicted
219                                         // ->   Write back the evicted block
220        1/1                              end else if (cache_mem_ctrl_i.evict_dirty == 1'b1) begin
221        1/1                                  next_mshr_entry.state       =   ST_EVICT;
222        1/1                                  next_mshr_entry.evict_addr  =   cache_mem_ctrl_i.evict_addr ;
223        1/1                                  next_mshr_entry.evict_data  =   cache_mem_ctrl_i.evict_data ;
224        1/1                                  next_mshr_entry.evict_dirty =   cache_mem_ctrl_i.evict_dirty;
225                                         // ELSE
226                                         // ->   Miss Handling Completed
227                                         end else begin
228        1/1                                  next_mshr_entry.state       =   ST_IDLE             ;
229        1/1                                  next_mshr_entry.cmd         =   BUS_NONE            ;
230        1/1                                  next_mshr_entry.req_addr    =   'b0                 ;
231        1/1                                  next_mshr_entry.req_data    =   'b0                 ;
232        1/1                                  next_mshr_entry.req_size    =   BYTE                ;
233        1/1                                  next_mshr_entry.evict_addr  =   'b0                 ;
234        1/1                                  next_mshr_entry.evict_data  =   'b0                 ;
235        1/1                                  next_mshr_entry.evict_dirty =   1'b0                ;
236        1/1                                  next_mshr_entry.link_idx    =   'd0                 ;
237        1/1                                  next_mshr_entry.mem_tag     =   'd0                 ;
238        1/1                                  next_mshr_cp_flag           =   1'b1                ;
239        1/1                                  next_mshr_cp_data           =   mshr_entry.req_data ;
240                                         end
241                                     end
                        MISSING_ELSE
242                                 end
243                                 ST_OUTPUT   :   begin
244                                     // IF   the Processor Interface is granted to this entry
245        1/1                          if (proc_grant_i == 1'b1) begin
246                                         // IF   the evicted block is dirty
247                                         // ->   Write back the evicted block
248        1/1                              if (mshr_entry.evict_dirty == 1'b1) begin
249        1/1                                  next_mshr_entry.state       =   ST_EVICT;
250                                         // ELSE
251                                         // ->   Miss Handling Completed
252                                         end else begin
253        1/1                                  next_mshr_entry.state       =   ST_IDLE             ;
254        1/1                                  next_mshr_entry.cmd         =   BUS_NONE            ;
255        1/1                                  next_mshr_entry.req_addr    =   'b0                 ;
256        1/1                                  next_mshr_entry.req_data    =   'b0                 ;
257        1/1                                  next_mshr_entry.req_size    =   BYTE                ;
258        1/1                                  next_mshr_entry.evict_addr  =   'b0                 ;
259        1/1                                  next_mshr_entry.evict_data  =   'b0                 ;
260        1/1                                  next_mshr_entry.evict_dirty =   1'b0                ;
261        1/1                                  next_mshr_entry.link_idx    =   'd0                 ;
262        1/1                                  next_mshr_entry.mem_tag     =   'd0                 ;
263        1/1                                  next_mshr_cp_flag           =   1'b1                ;
264        1/1                                  next_mshr_cp_data           =   mshr_entry.req_data ;
265                                         end
266                                     end
                        MISSING_ELSE
267                                 end
268                                 ST_EVICT    :   begin
269                                     // IF   the write back transaction to Memory is confirmed
270                                     // ->   Miss Handling Completed
271        1/1                          if ((memory_grant_i == 1'b1) && (mem2cache_i.response != 'd0)) begin
272        1/1                              next_mshr_entry.state       =   ST_IDLE             ;
273        1/1                              next_mshr_entry.cmd         =   BUS_NONE            ;
274        1/1                              next_mshr_entry.req_addr    =   'b0                 ;
275        1/1                              next_mshr_entry.req_data    =   'b0                 ;
276        1/1                              next_mshr_entry.req_size    =   BYTE                ;
277        1/1                              next_mshr_entry.evict_addr  =   'b0                 ;
278        1/1                              next_mshr_entry.evict_data  =   'b0                 ;
279        1/1                              next_mshr_entry.evict_dirty =   1'b0                ;
280        1/1                              next_mshr_entry.link_idx    =   'd0                 ;
281        1/1                              next_mshr_entry.mem_tag     =   'd0                 ;
282        1/1                              next_mshr_cp_flag           =   1'b1                ;
283        1/1                              next_mshr_cp_data           =   mshr_entry.req_data ;
284                                     end
                        MISSING_ELSE
285                                 end
286                                 default     :   begin
287        1/1                          next_mshr_entry.state       =   ST_IDLE     ;
288        1/1                          next_mshr_entry.cmd         =   BUS_NONE    ;
289        1/1                          next_mshr_entry.req_addr    =   'b0         ;
290        1/1                          next_mshr_entry.req_data    =   'b0         ;
291        1/1                          next_mshr_entry.req_size    =   BYTE        ;
292        1/1                          next_mshr_entry.evict_addr  =   'b0         ;
293        1/1                          next_mshr_entry.evict_data  =   'b0         ;
294        1/1                          next_mshr_entry.evict_dirty =   1'b0        ;
295        1/1                          next_mshr_entry.link_idx    =   'd0         ;
296        1/1                          next_mshr_entry.mem_tag     =   'd0         ;
297        1/1                          next_mshr_cp_flag           =   1'b0        ;
298        1/1                          next_mshr_cp_data           =   'd0         ;
299                                 end
300                             endcase
301                     
302        1/1                  if (next_mshr_entry.state == ST_IDLE) begin
303        1/1                      next_mshr_entry.linked  =   1'b0;
304        1/1                  end else if ((mshr_hit_i == 1'b1) && (mshr_hit_idx_i == mshr_entry_idx_i)) begin
305        1/1                      next_mshr_entry.linked  =   1'b1;
306                             end
                        MISSING_ELSE
307                         end
308                     
309                     // --------------------------------------------------------------------
310                     // MSHR entry output
311                     // --------------------------------------------------------------------
312                         assign  mshr_entry_o    =   mshr_entry  ;
313                     // --------------------------------------------------------------------
314                     // Processor Interface
315                     // --------------------------------------------------------------------
316                         always_comb begin
317        1/1                  mshr_proc_o.response    =   'd0 ;
318        1/1                  mshr_proc_o.data        =   'b0 ;
319        1/1                  mshr_proc_o.tag         =   'd0 ;
320        1/1                  case (mshr_entry.state)
321                                 ST_IDLE     :   begin
322                                     // IF   the processor request is allocated to this entry
323        1/1                          if ((proc2cache_i.command != BUS_NONE) && (dp_sel_i == 1'b1)) begin
324                                         // IF   The Processor Interface is granted to this entry
325                                         // AND  there is a dependency to older in-flight transaction
326                                         // ->   Confirm the request
327        1/1                              if (((mshr_hit_i && (cp_flag_i[mshr_hit_idx_i] == 1'b0))
328                                         || (evict_hit_i && (cp_flag_i[evict_hit_idx_i] == 1'b0)))) begin
329        1/1                                  mshr_proc_o.response    =   mshr_entry_idx_i;
330                                         // IF   The Processor Interface is granted to this entry
331                                         // AND  The cache_mem Interface is granted to this entry
332                                         // ->   Confirm the request 
333        1/1                              end else if (cache_mem_grant_i == 1'b1) begin
334        1/1                                  mshr_proc_o.response    =   mshr_entry_idx_i;
335                                             // IF   it is a load hit
336                                             // ->   Output data and tag
337        1/1                                  if (cache_mem_ctrl_i.req_hit == 1'b1 && proc2cache_i.command == BUS_LOAD) begin
338        1/1                                      mshr_proc_o.tag     =   mshr_entry_idx_i;
339        1/1                                      case (proc2cache_i.size)
340        1/1                                          BYTE    :   mshr_proc_o.data    =   {56'b0,cache_mem_ctrl_i.req_data_out[proc2cache_i.addr[2:0]+: 8]};
341        1/1                                          HALF    :   mshr_proc_o.data    =   {48'b0,cache_mem_ctrl_i.req_data_out[proc2cache_i.addr[2:0]+:16]};
342        1/1                                          WORD    :   mshr_proc_o.data    =   {32'b0,cache_mem_ctrl_i.req_data_out[proc2cache_i.addr[2:0]+:32]};
343        0/1     ==>                                  DOUBLE  :   mshr_proc_o.data    =   cache_mem_ctrl_i.req_data_out;
344        0/1     ==>                                  default :   mshr_proc_o.data    =   cache_mem_ctrl_i.req_data_out;
345                                                 endcase
346                                             end
                        MISSING_ELSE
347                                         end
                        MISSING_ELSE
348                                     end
                        MISSING_ELSE
349                                 end
350                                 ST_OUTPUT   :   begin
351        1/1                          mshr_proc_o.response    =   'd0                 ;
352        1/1                          mshr_proc_o.tag         =   mshr_entry_idx_i    ;
353        1/1                          case (mshr_entry.req_size)
354        1/1                              BYTE    :   mshr_proc_o.data    =   {56'b0,mshr_entry.req_data[mshr_entry.req_addr[2:0]+: 8]};
355        1/1                              HALF    :   mshr_proc_o.data    =   {48'b0,mshr_entry.req_data[mshr_entry.req_addr[2:0]+:16]};
356        1/1                              WORD    :   mshr_proc_o.data    =   {32'b0,mshr_entry.req_data[mshr_entry.req_addr[2:0]+:32]};
357        1/1                              DOUBLE  :   mshr_proc_o.data    =   mshr_entry.req_data;
358        0/1     ==>                      default :   mshr_proc_o.data    =   mshr_entry.req_data;
359                                     endcase
360                                 end
                        MISSING_DEFAULT
361                             endcase
362                         end
363                     
364                     // --------------------------------------------------------------------
365                     // cache_mem Interface
366                     // --------------------------------------------------------------------
367                         always_comb begin
368        1/1                  mshr_cache_mem_o.req_cmd        =   REQ_NONE;
369        1/1                  mshr_cache_mem_o.req_addr       =   'b0     ;
370        1/1                  mshr_cache_mem_o.req_data_in    =   'b0     ;
371        1/1                  case (mshr_entry.state)
372                                 ST_IDLE:    begin
373                                     // IF   the processor request is allocated to this entry
374        1/1                          if (dp_sel_i == 1'b1) begin
375        1/1                              case (proc2cache_i.command)
376                                             BUS_LOAD    :   begin
377        1/1                                      mshr_cache_mem_o.req_cmd        =   REQ_LOAD                        ;
378        1/1                                      mshr_cache_mem_o.req_addr       =   proc2cache_i.addr               ;
379        1/1                                      mshr_cache_mem_o.req_data_in    =   cache_mem_ctrl_i.req_data_out   ;
380                                             end
381                                             BUS_STORE   :   begin
382        1/1                                      mshr_cache_mem_o.req_cmd        =   REQ_STORE                       ;
383        1/1                                      mshr_cache_mem_o.req_addr       =   proc2cache_i.addr               ;
384        1/1                                      mshr_cache_mem_o.req_data_in    =   cache_mem_ctrl_i.req_data_out   ;
385        1/1                                      case (proc2cache_i.size)
386        1/1                                          BYTE    :   mshr_cache_mem_o.req_data_in[proc2cache_i.addr[2:0] +:  8]  =   proc2cache_i.data[ 7:0] ;
387        1/1                                          HALF    :   mshr_cache_mem_o.req_data_in[proc2cache_i.addr[2:0] +: 16]  =   proc2cache_i.data[15:0] ;
388        1/1                                          WORD    :   mshr_cache_mem_o.req_data_in[proc2cache_i.addr[2:0] +: 32]  =   proc2cache_i.data[31:0] ;
389        1/1                                          DOUBLE  :   mshr_cache_mem_o.req_data_in                                =   proc2cache_i.data       ;
                   ==>  MISSING_DEFAULT
390                                                 endcase
391                                             end    
                        MISSING_DEFAULT
392                                         endcase
393                                     end
                        MISSING_ELSE
394                                 end
395                                 ST_UPDATE:  begin
396        1/1                          if (mshr_entry.cmd == BUS_LOAD) begin
397        1/1                              mshr_cache_mem_o.req_cmd    =   REQ_LOAD_MISS       ;
398                                     end else begin
399        1/1                              mshr_cache_mem_o.req_cmd    =   REQ_STORE_MISS      ;
400                                     end
401        1/1                          mshr_cache_mem_o.req_addr       =   mshr_entry.req_addr ;
402        1/1                          mshr_cache_mem_o.req_data_in    =   mshr_entry.req_data ;
403                                 end
                        MISSING_DEFAULT
404                             endcase
405                         end
406                     
407                     // --------------------------------------------------------------------
408                     // Memory Interface
409                     // --------------------------------------------------------------------
410                         always_comb begin
411        1/1                  mshr_memory_o.addr      =   {mshr_entry.req_addr[C_XLEN-1:C_CACHE_OFFSET_WIDTH], {C_CACHE_OFFSET_WIDTH{1'b0}}};
412        1/1                  mshr_memory_o.size      =   DOUBLE              ;
413        1/1                  mshr_memory_o.command   =   BUS_NONE            ;
414        1/1                  mshr_memory_o.data      =   'd0 ;
415        1/1                  case (mshr_entry.state)
416                                 ST_RD_MEM   :   begin
417        1/1                          mshr_memory_o.data      =   'd0 ;
418        1/1                          mshr_memory_o.addr      =   {mshr_entry.req_addr[C_XLEN-1:C_CACHE_OFFSET_WIDTH], {C_CACHE_OFFSET_WIDTH{1'b0}}};
419        1/1                          mshr_memory_o.command   =   BUS_LOAD;
420                                 end
421                                 ST_EVICT    :   begin
422        1/1                          mshr_memory_o.data      =   mshr_entry.evict_data;
423        1/1                          mshr_memory_o.addr      =   {mshr_entry.evict_addr[C_XLEN-1:C_CACHE_OFFSET_WIDTH], {C_CACHE_OFFSET_WIDTH{1'b0}}};
424        1/1                          mshr_memory_o.command   =   BUS_STORE;
425                                 end
                        MISSING_DEFAULT

-------------------------------------------------------------------------------
Toggle Coverage for Module : mshr_entry_ctrl
                Total Covered Percent 
Totals          72    51      70.83   
Total Bits      4844  4103    84.70   
Total Bits 0->1 2422  2051    84.68   
Total Bits 1->0 2422  2052    84.72   

                                
Ports          48   32   66.67  
Port Bits      3878 3279 84.55  
Port Bits 0->1 1939 1639 84.53  
Port Bits 1->0 1939 1640 84.58  

                                
Signals          24  19  79.17  
Signal Bits      966 824 85.30  
Signal Bits 0->1 483 412 85.30  
Signal Bits 1->0 483 412 85.30  

Port Details
                                     Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i                                Yes    Yes         Yes         INPUT     
rst_i                                No     Yes         No          INPUT     
mshr_entry_idx_i[3:0]                No     No          No          INPUT     
mshr_entry_o.mem_tag[3:0]            Yes    Yes         Yes         OUTPUT    
mshr_entry_o.linked                  Yes    Yes         Yes         OUTPUT    
mshr_entry_o.link_idx[2:0]           Yes    Yes         Yes         OUTPUT    
mshr_entry_o.link_idx[3]             No     No          No          OUTPUT    
mshr_entry_o.evict_dirty             Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_data[63:0]        Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_addr[2:0]         No     No          No          OUTPUT    
mshr_entry_o.evict_addr[15:3]        Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_addr[31:16]       No     No          No          OUTPUT    
mshr_entry_o.req_size[1:0]           Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_data[63:0]          Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_addr[15:0]          Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_addr[31:16]         No     No          No          OUTPUT    
mshr_entry_o.cmd[1:0]                Yes    Yes         Yes         OUTPUT    
mshr_entry_o.state[2:0]              Yes    Yes         Yes         OUTPUT    
proc_grant_i                         Yes    Yes         Yes         INPUT     
proc2cache_i.command[1:0]            Yes    Yes         Yes         INPUT     
proc2cache_i.size[1:0]               Yes    Yes         Yes         INPUT     
proc2cache_i.data[63:0]              Yes    Yes         Yes         INPUT     
proc2cache_i.addr[15:0]              Yes    Yes         Yes         INPUT     
proc2cache_i.addr[31:16]             No     No          No          INPUT     
mshr_proc_o.tag[3:0]                 Yes    Yes         Yes         OUTPUT    
mshr_proc_o.data[18:0]               Yes    Yes         Yes         OUTPUT    
mshr_proc_o.data[19]                 No     No          No          OUTPUT    
mshr_proc_o.data[24:20]              Yes    Yes         Yes         OUTPUT    
mshr_proc_o.data[25]                 No     No          No          OUTPUT    
mshr_proc_o.data[33:26]              Yes    Yes         Yes         OUTPUT    
mshr_proc_o.data[34]                 No     No          No          OUTPUT    
mshr_proc_o.data[41:35]              Yes    Yes         Yes         OUTPUT    
mshr_proc_o.data[43:42]              No     No          No          OUTPUT    
mshr_proc_o.data[44]                 Yes    Yes         Yes         OUTPUT    
mshr_proc_o.data[46:45]              No     No          No          OUTPUT    
mshr_proc_o.data[49:47]              Yes    Yes         Yes         OUTPUT    
mshr_proc_o.data[51:50]              No     No          No          OUTPUT    
mshr_proc_o.data[54:52]              Yes    Yes         Yes         OUTPUT    
mshr_proc_o.data[55]                 No     No          No          OUTPUT    
mshr_proc_o.data[58:56]              Yes    Yes         Yes         OUTPUT    
mshr_proc_o.data[59]                 No     No          No          OUTPUT    
mshr_proc_o.data[62:60]              Yes    Yes         Yes         OUTPUT    
mshr_proc_o.data[63]                 No     No          No          OUTPUT    
mshr_proc_o.response[3:0]            Yes    Yes         Yes         OUTPUT    
cache_mem_grant_i                    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.evict_data[63:0]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.evict_addr[2:0]     No     No          No          INPUT     
cache_mem_ctrl_i.evict_addr[15:3]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.evict_addr[31:16]   No     No          No          INPUT     
cache_mem_ctrl_i.evict_dirty         Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[4:0]   Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[6:5]   No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[8:7]   Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[11:9]  No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[13:12] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[15:14] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[25:16] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[26]    No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[31:27] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[33:32] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[34]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[37:35] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[38]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[41:39] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[42]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[45:43] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[47:46] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[50:48] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[52:51] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[54:53] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[58:55] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[60:59] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[63:61] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_hit             Yes    Yes         Yes         INPUT     
mshr_cache_mem_o.req_data_in[63:0]   Yes    Yes         Yes         OUTPUT    
mshr_cache_mem_o.req_addr[15:0]      Yes    Yes         Yes         OUTPUT    
mshr_cache_mem_o.req_addr[31:16]     No     No          No          OUTPUT    
mshr_cache_mem_o.req_cmd[2:0]        Yes    Yes         Yes         OUTPUT    
memory_grant_i                       Yes    Yes         Yes         INPUT     
mem2cache_i.tag[3:0]                 Yes    Yes         Yes         INPUT     
mem2cache_i.data[63:0]               Yes    Yes         Yes         INPUT     
mem2cache_i.response[3:0]            Yes    Yes         Yes         INPUT     
mshr_memory_o.command[1:0]           Yes    Yes         Yes         OUTPUT    
mshr_memory_o.size[1:0]              No     No          No          OUTPUT    
mshr_memory_o.data[63:0]             Yes    Yes         Yes         OUTPUT    
mshr_memory_o.addr[2:0]              No     No          No          OUTPUT    
mshr_memory_o.addr[15:3]             Yes    Yes         Yes         OUTPUT    
mshr_memory_o.addr[31:16]            No     No          No          OUTPUT    
mshr_hit_i                           Yes    Yes         Yes         INPUT     
mshr_hit_idx_i[3:0]                  Yes    Yes         Yes         INPUT     
evict_hit_i                          No     No          No          INPUT     
evict_hit_idx_i[3:0]                 No     No          No          INPUT     
dp_sel_i                             Yes    Yes         Yes         INPUT     
mshr_cp_flag_o                       Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[63:0]                 Yes    Yes         Yes         OUTPUT    
cp_flag_i[0]                         No     No          No          INPUT     
cp_flag_i[15:1]                      Yes    Yes         Yes         INPUT     
cp_data_i[8:1][63:0]                 Yes    Yes         Yes         INPUT     
cp_data_i[9][44:0]                   Yes    Yes         Yes         INPUT     
cp_data_i[9][63:46]                  Yes    Yes         Yes         INPUT     
cp_data_i[10][30:1]                  Yes    Yes         Yes         INPUT     
cp_data_i[10][36:32]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][41:40]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][45]                    Yes    Yes         Yes         INPUT     
cp_data_i[10][49:47]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][52:51]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][56:55]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][60]                    Yes    Yes         Yes         INPUT     
cp_data_i[10][62]                    Yes    Yes         Yes         INPUT     
cp_data_i[11][27:0]                  Yes    Yes         Yes         INPUT     
cp_data_i[11][36:29]                 Yes    Yes         Yes         INPUT     
cp_data_i[11][49:39]                 Yes    Yes         Yes         INPUT     
cp_data_i[11][51]                    Yes    Yes         Yes         INPUT     
cp_data_i[11][59:54]                 Yes    Yes         Yes         INPUT     
cp_data_i[11][63:62]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][4:0]                   Yes    Yes         Yes         INPUT     
cp_data_i[12][27:6]                  Yes    Yes         Yes         INPUT     
cp_data_i[12][31:29]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][35:33]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][39]                    Yes    Yes         Yes         INPUT     
cp_data_i[12][44:43]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][48:46]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][50]                    Yes    Yes         Yes         INPUT     
cp_data_i[12][54]                    Yes    Yes         Yes         INPUT     
cp_data_i[12][58:57]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][61]                    Yes    Yes         Yes         INPUT     
cp_data_i[13][17:0]                  Yes    Yes         Yes         INPUT     
cp_data_i[13][46:19]                 Yes    Yes         Yes         INPUT     
cp_data_i[13][49]                    Yes    Yes         Yes         INPUT     
cp_data_i[13][56:51]                 Yes    Yes         Yes         INPUT     
cp_data_i[13][63:58]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][14:1]                  Yes    Yes         Yes         INPUT     
cp_data_i[14][19:16]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][21]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][24:23]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][27]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][32:30]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][37:35]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][39]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][41]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][43]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][46:45]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][51:49]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][59:53]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][62:61]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][15:0]                  Yes    Yes         Yes         INPUT     
cp_data_i[15][37:17]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][40:39]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][42]                    Yes    Yes         Yes         INPUT     
cp_data_i[15][45:44]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][48:47]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][53:51]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][55]                    Yes    Yes         Yes         INPUT     
cp_data_i[15][63:57]                 Yes    Yes         Yes         INPUT     
Other bits of cp_data_i[15:0][63:0]  No     No          No          INPUT     

Signal Details
                                  Toggle Toggle 1->0 Toggle 0->1 
mshr_entry.mem_tag[3:0]           Yes    Yes         Yes         
mshr_entry.linked                 Yes    Yes         Yes         
mshr_entry.link_idx[2:0]          Yes    Yes         Yes         
mshr_entry.link_idx[3]            No     No          No          
mshr_entry.evict_dirty            Yes    Yes         Yes         
mshr_entry.evict_data[63:0]       Yes    Yes         Yes         
mshr_entry.evict_addr[2:0]        No     No          No          
mshr_entry.evict_addr[15:3]       Yes    Yes         Yes         
mshr_entry.evict_addr[31:16]      No     No          No          
mshr_entry.req_size[1:0]          Yes    Yes         Yes         
mshr_entry.req_data[63:0]         Yes    Yes         Yes         
mshr_entry.req_addr[15:0]         Yes    Yes         Yes         
mshr_entry.req_addr[31:16]        No     No          No          
mshr_entry.cmd[1:0]               Yes    Yes         Yes         
mshr_entry.state[2:0]             Yes    Yes         Yes         
next_mshr_entry.mem_tag[3:0]      Yes    Yes         Yes         
next_mshr_entry.linked            Yes    Yes         Yes         
next_mshr_entry.link_idx[3:0]     Yes    Yes         Yes         
next_mshr_entry.evict_dirty       Yes    Yes         Yes         
next_mshr_entry.evict_data[63:0]  Yes    Yes         Yes         
next_mshr_entry.evict_addr[2:0]   No     No          No          
next_mshr_entry.evict_addr[15:3]  Yes    Yes         Yes         
next_mshr_entry.evict_addr[31:16] No     No          No          
next_mshr_entry.req_size[1:0]     Yes    Yes         Yes         
next_mshr_entry.req_data[63:0]    Yes    Yes         Yes         
next_mshr_entry.req_addr[15:0]    Yes    Yes         Yes         
next_mshr_entry.req_addr[31:16]   No     No          No          
next_mshr_entry.cmd[1:0]          Yes    Yes         Yes         
next_mshr_entry.state[2:0]        Yes    Yes         Yes         
next_mshr_cp_flag                 Yes    Yes         Yes         
next_mshr_cp_data[63:0]           Yes    Yes         Yes         


-------------------------------------------------------------------------------
===============================================================================
Module Instance : cache_tb.dut.cache_ctrl_inst.genblk1[12].mshr_entry_ctrl_inst
===============================================================================

Instance :

SCORE  LINE   TOGGLE 
 72.30  72.86  71.74 


Instance's subtree :

SCORE  LINE   TOGGLE 
 72.30  72.86  71.74 


Module : 

SCORE  LINE   TOGGLE NAME            
 87.59  90.48  84.70 mshr_entry_ctrl 


Parent : 

SCORE  LINE   TOGGLE NAME            
 92.38 100.00  84.76 cache_ctrl_inst 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : cache_tb.dut.cache_ctrl_inst.genblk1[12].mshr_entry_ctrl_inst

             Line No.   Total   Covered  Percent
TOTAL                      210      153    72.86
ALWAYS             75       17       17   100.00
ALWAYS             97      135       88    65.19
ALWAYS            317       25       16    64.00
ALWAYS            368       22       21    95.45
ALWAYS            411       11       11   100.00

74                          always_ff @(posedge clk_i) begin
75         1/1                  if (rst_i) begin
76         1/1                      mshr_entry.state        <=  `SD ST_IDLE     ;
77         1/1                      mshr_entry.cmd          <=  `SD BUS_NONE    ;
78         1/1                      mshr_entry.req_addr     <=  `SD 'b0         ;
79         1/1                      mshr_entry.req_data     <=  `SD 'b0         ;
80         1/1                      mshr_entry.req_size     <=  `SD BYTE        ;
81         1/1                      mshr_entry.evict_addr   <=  `SD 'b0         ;
82         1/1                      mshr_entry.evict_data   <=  `SD 'b0         ;
83         1/1                      mshr_entry.evict_dirty  <=  `SD 1'b0        ;
84         1/1                      mshr_entry.link_idx     <=  `SD 'd0         ;
85         1/1                      mshr_entry.linked       <=  `SD 1'b0        ;
86         1/1                      mshr_entry.mem_tag      <=  `SD 'd0         ;
87         1/1                      mshr_cp_flag_o          <=  `SD 1'b0        ;
88         1/1                      mshr_cp_data_o          <=  `SD 'b0         ;
89                              end else begin
90         1/1                      mshr_entry              <=  `SD next_mshr_entry     ;
91         1/1                      mshr_cp_flag_o          <=  `SD next_mshr_cp_flag   ;
92         1/1                      mshr_cp_data_o          <=  `SD next_mshr_cp_data   ;
93                              end
94                          end
95                      
96                          always_comb begin
97         1/1                  next_mshr_entry.state       =   mshr_entry.state        ;
98         1/1                  next_mshr_entry.cmd         =   mshr_entry.cmd          ;
99         1/1                  next_mshr_entry.req_addr    =   mshr_entry.req_addr     ;
100        1/1                  next_mshr_entry.req_data    =   mshr_entry.req_data     ;
101        1/1                  next_mshr_entry.req_size    =   mshr_entry.req_size     ;
102        1/1                  next_mshr_entry.evict_addr  =   mshr_entry.evict_addr   ;
103        1/1                  next_mshr_entry.evict_data  =   mshr_entry.evict_data   ;
104        1/1                  next_mshr_entry.evict_dirty =   mshr_entry.evict_dirty  ;
105        1/1                  next_mshr_entry.link_idx    =   mshr_entry.link_idx     ;
106        1/1                  next_mshr_entry.linked      =   mshr_entry.linked       ;
107        1/1                  next_mshr_entry.mem_tag     =   mshr_entry.mem_tag      ;
108        1/1                  next_mshr_cp_flag           =   mshr_cp_flag_o          ;
109        1/1                  next_mshr_cp_data           =   mshr_cp_data_o          ;
110        1/1                  case (mshr_entry.state)
111                                 ST_IDLE     :   begin
112                                     // IF   there is a valid transaction on Processor Interface
113                                     // AND  the Processor Interface is granted to this entry
114                                     // AND  the cache_mem Interface is granted to this entry
115                                     // AND  it is a miss
116                                     // AND  the entry is selected to hold the new miss
117        1/1                          if ((proc2cache_i.command != BUS_NONE) && (dp_sel_i == 1'b1)
118                                     && (proc_grant_i == 1'b1)) begin
119                                         // IF   there is an older in-flight transaction to the same addreess
120                                         // ->   Wait for the completion of older miss to the same address
121        1/1                              if (mshr_hit_i && (cp_flag_i[mshr_hit_idx_i] == 1'b0)) begin
122        1/1                                  next_mshr_entry.state       =   ST_WAIT_DEPEND          ;
123        1/1                                  next_mshr_entry.link_idx    =   mshr_hit_idx_i          ;
124        1/1                                  next_mshr_entry.cmd         =   proc2cache_i.command    ;
125        1/1                                  next_mshr_entry.req_addr    =   proc2cache_i.addr       ;
126        1/1                                  next_mshr_entry.req_size    =   proc2cache_i.size       ;
127        1/1                                  if (proc2cache_i.command == BUS_STORE) begin
128        1/1                                      next_mshr_entry.req_data    =   proc2cache_i.data   ;
129                                             end
                        MISSING_ELSE
130                                         // IF   there is an older in-flight transaction that is in the middle of evicting the data block
131                                         // ->   Wait for the completion of write-back to memory
132        1/1                              end else if (evict_hit_i && (cp_flag_i[evict_hit_idx_i] == 1'b0)) begin
133        0/1     ==>                          next_mshr_entry.state       =   ST_WAIT_EVICT           ;
134        0/1     ==>                          next_mshr_entry.link_idx    =   evict_hit_idx_i         ;
135        0/1     ==>                          next_mshr_entry.cmd         =   proc2cache_i.command    ;
136        0/1     ==>                          next_mshr_entry.req_addr    =   proc2cache_i.addr       ;
137        0/1     ==>                          next_mshr_entry.req_size    =   proc2cache_i.size       ;
138        0/1     ==>                          if (proc2cache_i.command == BUS_STORE) begin
139        0/1     ==>                              next_mshr_entry.req_data    =   proc2cache_i.data   ;
140                                             end
                   ==>  MISSING_ELSE
141                                         // IF   it is a miss, and no dependency to older in-flight transactions.
142                                         // ->   Start miss handling
143        1/1                              end else if ((cache_mem_ctrl_i.req_hit == 1'b0) && (cache_mem_grant_i == 1'b1)) begin
144        1/1                                  next_mshr_entry.state       =   ST_RD_MEM               ;
145        1/1                                  next_mshr_entry.link_idx    =   'd0                     ;
146        1/1                                  next_mshr_entry.cmd         =   proc2cache_i.command    ;
147        1/1                                  next_mshr_entry.req_addr    =   proc2cache_i.addr       ;
148        1/1                                  next_mshr_entry.req_size    =   proc2cache_i.size       ;
149        1/1                                  if (proc2cache_i.command == BUS_STORE) begin
150        1/1                                      next_mshr_entry.req_data    =   proc2cache_i.data   ;
151                                             end
                        MISSING_ELSE
152                                         end
                   ==>  MISSING_ELSE
153                                     end
                        MISSING_ELSE
154        1/1                          next_mshr_cp_flag   =   1'b0    ;
155        1/1                          next_mshr_cp_data   =   'b0     ;
156                                 end
157                                 ST_WAIT_DEPEND  :   begin
158                                     // IF   the older transaction that the entry is linked to completed
159                                     // ->   Update the cache data
160        0/1     ==>                  if (cp_flag_i[mshr_entry.link_idx] == 1'b1) begin
161        0/1     ==>                      next_mshr_entry.state       =   ST_UPDATE   ;
162        0/1     ==>                      next_mshr_entry.link_idx    =   'd0         ;
163        0/1     ==>                      next_mshr_entry.req_data    =   cp_data_i[mshr_entry.link_idx];
164        0/1     ==>                      if (mshr_entry.cmd == BUS_STORE) begin
165        0/1     ==>                          case (mshr_entry.req_size)
166        0/1     ==>                              BYTE    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +:  8]    =   mshr_entry.req_data[ 7:0]   ;
167        0/1     ==>                              HALF    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +: 16]    =   mshr_entry.req_data[15:0]   ;
168        0/1     ==>                              WORD    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +: 32]    =   mshr_entry.req_data[31:0]   ;
169        0/1     ==>                              DOUBLE  :   next_mshr_entry.req_data                                    =   mshr_entry.req_data         ;
170        0/1     ==>                              default :   next_mshr_entry.req_data                                    =   mshr_entry.req_data         ;
171                                             endcase
172                                         end
                   ==>  MISSING_ELSE
173                                     end
                   ==>  MISSING_ELSE
174                                 end
175                                 ST_WAIT_EVICT   : begin
176                                     // IF   the older transaction that evicts the cache block completed
177                                     // ->   Read from Memory
178        0/1     ==>                  if (cp_flag_i[mshr_entry.link_idx] == 1'b1) begin
179        0/1     ==>                      next_mshr_entry.state       =   ST_RD_MEM   ;
180        0/1     ==>                      next_mshr_entry.link_idx    =   'd0         ;
181                                     end
                   ==>  MISSING_ELSE
182                                 end
183                                 ST_RD_MEM   :   begin
184                                     // IF   the read transaction is confirmed by Memory Interface
185                                     // ->   Wait for the data to return from Memory
186        1/1                          if ((memory_grant_i == 1'b1) && (mem2cache_i.response != 'd0)) begin
187        1/1                              next_mshr_entry.state       =   ST_WAIT_MEM             ;
188        1/1                              next_mshr_entry.mem_tag     =   mem2cache_i.response    ;
189                                     end
                        MISSING_ELSE
190                                 end
191                                 ST_WAIT_MEM :   begin
192                                     // IF   the data is returned from the Memory
193                                     // ->   Update the cache data
194        1/1                          if (mem2cache_i.tag == mshr_entry.mem_tag) begin
195        1/1                              next_mshr_entry.state       =   ST_UPDATE           ;
196        1/1                              next_mshr_entry.req_data    =   mem2cache_i.data    ;
197        1/1                              if (mshr_entry.cmd == BUS_STORE) begin
198        1/1                                  case (mshr_entry.req_size)
199        1/1                                      BYTE    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +:  8]    =   mshr_entry.req_data[ 7:0]   ;
200        0/1     ==>                              HALF    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +: 16]    =   mshr_entry.req_data[15:0]   ;
201        1/1                                      WORD    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +: 32]    =   mshr_entry.req_data[31:0]   ;
202        1/1                                      DOUBLE  :   next_mshr_entry.req_data                                    =   mshr_entry.req_data         ;
203        0/1     ==>                              default :   next_mshr_entry.req_data                                    =   mshr_entry.req_data         ;
204                                             endcase
205                                         end
                        MISSING_ELSE
206                                     end
                        MISSING_ELSE
207                                 end
208                                 ST_UPDATE   :   begin
209                                     // IF   the req interface is granted to this entry
210        1/1                          if (cache_mem_grant_i == 1'b1) begin
211                                         // IF   it is a load miss
212                                         // ->   Output data to processor
213        1/1                              if (mshr_entry.cmd == BUS_LOAD) begin
214        1/1                                  next_mshr_entry.state       =   ST_OUTPUT;
215        1/1                                  next_mshr_entry.evict_addr  =   cache_mem_ctrl_i.evict_addr ;
216        1/1                                  next_mshr_entry.evict_data  =   cache_mem_ctrl_i.evict_data ;
217        1/1                                  next_mshr_entry.evict_dirty =   cache_mem_ctrl_i.evict_dirty;
218                                         // IF   a dirty block is evicted
219                                         // ->   Write back the evicted block
220        1/1                              end else if (cache_mem_ctrl_i.evict_dirty == 1'b1) begin
221        1/1                                  next_mshr_entry.state       =   ST_EVICT;
222        1/1                                  next_mshr_entry.evict_addr  =   cache_mem_ctrl_i.evict_addr ;
223        1/1                                  next_mshr_entry.evict_data  =   cache_mem_ctrl_i.evict_data ;
224        1/1                                  next_mshr_entry.evict_dirty =   cache_mem_ctrl_i.evict_dirty;
225                                         // ELSE
226                                         // ->   Miss Handling Completed
227                                         end else begin
228        0/1     ==>                          next_mshr_entry.state       =   ST_IDLE             ;
229        0/1     ==>                          next_mshr_entry.cmd         =   BUS_NONE            ;
230        0/1     ==>                          next_mshr_entry.req_addr    =   'b0                 ;
231        0/1     ==>                          next_mshr_entry.req_data    =   'b0                 ;
232        0/1     ==>                          next_mshr_entry.req_size    =   BYTE                ;
233        0/1     ==>                          next_mshr_entry.evict_addr  =   'b0                 ;
234        0/1     ==>                          next_mshr_entry.evict_data  =   'b0                 ;
235        0/1     ==>                          next_mshr_entry.evict_dirty =   1'b0                ;
236        0/1     ==>                          next_mshr_entry.link_idx    =   'd0                 ;
237        0/1     ==>                          next_mshr_entry.mem_tag     =   'd0                 ;
238        0/1     ==>                          next_mshr_cp_flag           =   1'b1                ;
239        0/1     ==>                          next_mshr_cp_data           =   mshr_entry.req_data ;
240                                         end
241                                     end
                        MISSING_ELSE
242                                 end
243                                 ST_OUTPUT   :   begin
244                                     // IF   the Processor Interface is granted to this entry
245        1/1                          if (proc_grant_i == 1'b1) begin
246                                         // IF   the evicted block is dirty
247                                         // ->   Write back the evicted block
248        1/1                              if (mshr_entry.evict_dirty == 1'b1) begin
249        1/1                                  next_mshr_entry.state       =   ST_EVICT;
250                                         // ELSE
251                                         // ->   Miss Handling Completed
252                                         end else begin
253        0/1     ==>                          next_mshr_entry.state       =   ST_IDLE             ;
254        0/1     ==>                          next_mshr_entry.cmd         =   BUS_NONE            ;
255        0/1     ==>                          next_mshr_entry.req_addr    =   'b0                 ;
256        0/1     ==>                          next_mshr_entry.req_data    =   'b0                 ;
257        0/1     ==>                          next_mshr_entry.req_size    =   BYTE                ;
258        0/1     ==>                          next_mshr_entry.evict_addr  =   'b0                 ;
259        0/1     ==>                          next_mshr_entry.evict_data  =   'b0                 ;
260        0/1     ==>                          next_mshr_entry.evict_dirty =   1'b0                ;
261        0/1     ==>                          next_mshr_entry.link_idx    =   'd0                 ;
262        0/1     ==>                          next_mshr_entry.mem_tag     =   'd0                 ;
263        0/1     ==>                          next_mshr_cp_flag           =   1'b1                ;
264        0/1     ==>                          next_mshr_cp_data           =   mshr_entry.req_data ;
265                                         end
266                                     end
                        MISSING_ELSE
267                                 end
268                                 ST_EVICT    :   begin
269                                     // IF   the write back transaction to Memory is confirmed
270                                     // ->   Miss Handling Completed
271        1/1                          if ((memory_grant_i == 1'b1) && (mem2cache_i.response != 'd0)) begin
272        1/1                              next_mshr_entry.state       =   ST_IDLE             ;
273        1/1                              next_mshr_entry.cmd         =   BUS_NONE            ;
274        1/1                              next_mshr_entry.req_addr    =   'b0                 ;
275        1/1                              next_mshr_entry.req_data    =   'b0                 ;
276        1/1                              next_mshr_entry.req_size    =   BYTE                ;
277        1/1                              next_mshr_entry.evict_addr  =   'b0                 ;
278        1/1                              next_mshr_entry.evict_data  =   'b0                 ;
279        1/1                              next_mshr_entry.evict_dirty =   1'b0                ;
280        1/1                              next_mshr_entry.link_idx    =   'd0                 ;
281        1/1                              next_mshr_entry.mem_tag     =   'd0                 ;
282        1/1                              next_mshr_cp_flag           =   1'b1                ;
283        1/1                              next_mshr_cp_data           =   mshr_entry.req_data ;
284                                     end
                        MISSING_ELSE
285                                 end
286                                 default     :   begin
287        1/1                          next_mshr_entry.state       =   ST_IDLE     ;
288        1/1                          next_mshr_entry.cmd         =   BUS_NONE    ;
289        1/1                          next_mshr_entry.req_addr    =   'b0         ;
290        1/1                          next_mshr_entry.req_data    =   'b0         ;
291        1/1                          next_mshr_entry.req_size    =   BYTE        ;
292        1/1                          next_mshr_entry.evict_addr  =   'b0         ;
293        1/1                          next_mshr_entry.evict_data  =   'b0         ;
294        1/1                          next_mshr_entry.evict_dirty =   1'b0        ;
295        1/1                          next_mshr_entry.link_idx    =   'd0         ;
296        1/1                          next_mshr_entry.mem_tag     =   'd0         ;
297        1/1                          next_mshr_cp_flag           =   1'b0        ;
298        1/1                          next_mshr_cp_data           =   'd0         ;
299                                 end
300                             endcase
301                     
302        1/1                  if (next_mshr_entry.state == ST_IDLE) begin
303        1/1                      next_mshr_entry.linked  =   1'b0;
304        1/1                  end else if ((mshr_hit_i == 1'b1) && (mshr_hit_idx_i == mshr_entry_idx_i)) begin
305        1/1                      next_mshr_entry.linked  =   1'b1;
306                             end
                        MISSING_ELSE
307                         end
308                     
309                     // --------------------------------------------------------------------
310                     // MSHR entry output
311                     // --------------------------------------------------------------------
312                         assign  mshr_entry_o    =   mshr_entry  ;
313                     // --------------------------------------------------------------------
314                     // Processor Interface
315                     // --------------------------------------------------------------------
316                         always_comb begin
317        1/1                  mshr_proc_o.response    =   'd0 ;
318        1/1                  mshr_proc_o.data        =   'b0 ;
319        1/1                  mshr_proc_o.tag         =   'd0 ;
320        1/1                  case (mshr_entry.state)
321                                 ST_IDLE     :   begin
322                                     // IF   the processor request is allocated to this entry
323        1/1                          if ((proc2cache_i.command != BUS_NONE) && (dp_sel_i == 1'b1)) begin
324                                         // IF   The Processor Interface is granted to this entry
325                                         // AND  there is a dependency to older in-flight transaction
326                                         // ->   Confirm the request
327        1/1                              if (((mshr_hit_i && (cp_flag_i[mshr_hit_idx_i] == 1'b0))
328                                         || (evict_hit_i && (cp_flag_i[evict_hit_idx_i] == 1'b0)))) begin
329        1/1                                  mshr_proc_o.response    =   mshr_entry_idx_i;
330                                         // IF   The Processor Interface is granted to this entry
331                                         // AND  The cache_mem Interface is granted to this entry
332                                         // ->   Confirm the request 
333        1/1                              end else if (cache_mem_grant_i == 1'b1) begin
334        1/1                                  mshr_proc_o.response    =   mshr_entry_idx_i;
335                                             // IF   it is a load hit
336                                             // ->   Output data and tag
337        1/1                                  if (cache_mem_ctrl_i.req_hit == 1'b1 && proc2cache_i.command == BUS_LOAD) begin
338        0/1     ==>                              mshr_proc_o.tag     =   mshr_entry_idx_i;
339        0/1     ==>                              case (proc2cache_i.size)
340        0/1     ==>                                  BYTE    :   mshr_proc_o.data    =   {56'b0,cache_mem_ctrl_i.req_data_out[proc2cache_i.addr[2:0]+: 8]};
341        0/1     ==>                                  HALF    :   mshr_proc_o.data    =   {48'b0,cache_mem_ctrl_i.req_data_out[proc2cache_i.addr[2:0]+:16]};
342        0/1     ==>                                  WORD    :   mshr_proc_o.data    =   {32'b0,cache_mem_ctrl_i.req_data_out[proc2cache_i.addr[2:0]+:32]};
343        0/1     ==>                                  DOUBLE  :   mshr_proc_o.data    =   cache_mem_ctrl_i.req_data_out;
344        0/1     ==>                                  default :   mshr_proc_o.data    =   cache_mem_ctrl_i.req_data_out;
345                                                 endcase
346                                             end
                        MISSING_ELSE
347                                         end
                        MISSING_ELSE
348                                     end
                        MISSING_ELSE
349                                 end
350                                 ST_OUTPUT   :   begin
351        1/1                          mshr_proc_o.response    =   'd0                 ;
352        1/1                          mshr_proc_o.tag         =   mshr_entry_idx_i    ;
353        1/1                          case (mshr_entry.req_size)
354        1/1                              BYTE    :   mshr_proc_o.data    =   {56'b0,mshr_entry.req_data[mshr_entry.req_addr[2:0]+: 8]};
355        1/1                              HALF    :   mshr_proc_o.data    =   {48'b0,mshr_entry.req_data[mshr_entry.req_addr[2:0]+:16]};
356        0/1     ==>                      WORD    :   mshr_proc_o.data    =   {32'b0,mshr_entry.req_data[mshr_entry.req_addr[2:0]+:32]};
357        1/1                              DOUBLE  :   mshr_proc_o.data    =   mshr_entry.req_data;
358        0/1     ==>                      default :   mshr_proc_o.data    =   mshr_entry.req_data;
359                                     endcase
360                                 end
                        MISSING_DEFAULT
361                             endcase
362                         end
363                     
364                     // --------------------------------------------------------------------
365                     // cache_mem Interface
366                     // --------------------------------------------------------------------
367                         always_comb begin
368        1/1                  mshr_cache_mem_o.req_cmd        =   REQ_NONE;
369        1/1                  mshr_cache_mem_o.req_addr       =   'b0     ;
370        1/1                  mshr_cache_mem_o.req_data_in    =   'b0     ;
371        1/1                  case (mshr_entry.state)
372                                 ST_IDLE:    begin
373                                     // IF   the processor request is allocated to this entry
374        1/1                          if (dp_sel_i == 1'b1) begin
375        1/1                              case (proc2cache_i.command)
376                                             BUS_LOAD    :   begin
377        1/1                                      mshr_cache_mem_o.req_cmd        =   REQ_LOAD                        ;
378        1/1                                      mshr_cache_mem_o.req_addr       =   proc2cache_i.addr               ;
379        1/1                                      mshr_cache_mem_o.req_data_in    =   cache_mem_ctrl_i.req_data_out   ;
380                                             end
381                                             BUS_STORE   :   begin
382        1/1                                      mshr_cache_mem_o.req_cmd        =   REQ_STORE                       ;
383        1/1                                      mshr_cache_mem_o.req_addr       =   proc2cache_i.addr               ;
384        1/1                                      mshr_cache_mem_o.req_data_in    =   cache_mem_ctrl_i.req_data_out   ;
385        1/1                                      case (proc2cache_i.size)
386        1/1                                          BYTE    :   mshr_cache_mem_o.req_data_in[proc2cache_i.addr[2:0] +:  8]  =   proc2cache_i.data[ 7:0] ;
387        0/1     ==>                                  HALF    :   mshr_cache_mem_o.req_data_in[proc2cache_i.addr[2:0] +: 16]  =   proc2cache_i.data[15:0] ;
388        1/1                                          WORD    :   mshr_cache_mem_o.req_data_in[proc2cache_i.addr[2:0] +: 32]  =   proc2cache_i.data[31:0] ;
389        1/1                                          DOUBLE  :   mshr_cache_mem_o.req_data_in                                =   proc2cache_i.data       ;
                   ==>  MISSING_DEFAULT
390                                                 endcase
391                                             end    
                        MISSING_DEFAULT
392                                         endcase
393                                     end
                        MISSING_ELSE
394                                 end
395                                 ST_UPDATE:  begin
396        1/1                          if (mshr_entry.cmd == BUS_LOAD) begin
397        1/1                              mshr_cache_mem_o.req_cmd    =   REQ_LOAD_MISS       ;
398                                     end else begin
399        1/1                              mshr_cache_mem_o.req_cmd    =   REQ_STORE_MISS      ;
400                                     end
401        1/1                          mshr_cache_mem_o.req_addr       =   mshr_entry.req_addr ;
402        1/1                          mshr_cache_mem_o.req_data_in    =   mshr_entry.req_data ;
403                                 end
                        MISSING_DEFAULT
404                             endcase
405                         end
406                     
407                     // --------------------------------------------------------------------
408                     // Memory Interface
409                     // --------------------------------------------------------------------
410                         always_comb begin
411        1/1                  mshr_memory_o.addr      =   {mshr_entry.req_addr[C_XLEN-1:C_CACHE_OFFSET_WIDTH], {C_CACHE_OFFSET_WIDTH{1'b0}}};
412        1/1                  mshr_memory_o.size      =   DOUBLE              ;
413        1/1                  mshr_memory_o.command   =   BUS_NONE            ;
414        1/1                  mshr_memory_o.data      =   'd0 ;
415        1/1                  case (mshr_entry.state)
416                                 ST_RD_MEM   :   begin
417        1/1                          mshr_memory_o.data      =   'd0 ;
418        1/1                          mshr_memory_o.addr      =   {mshr_entry.req_addr[C_XLEN-1:C_CACHE_OFFSET_WIDTH], {C_CACHE_OFFSET_WIDTH{1'b0}}};
419        1/1                          mshr_memory_o.command   =   BUS_LOAD;
420                                 end
421                                 ST_EVICT    :   begin
422        1/1                          mshr_memory_o.data      =   mshr_entry.evict_data;
423        1/1                          mshr_memory_o.addr      =   {mshr_entry.evict_addr[C_XLEN-1:C_CACHE_OFFSET_WIDTH], {C_CACHE_OFFSET_WIDTH{1'b0}}};
424        1/1                          mshr_memory_o.command   =   BUS_STORE;
425                                 end
                        MISSING_DEFAULT

-------------------------------------------------------------------------------
Toggle Coverage for Instance : cache_tb.dut.cache_ctrl_inst.genblk1[12].mshr_entry_ctrl_inst
                Total Covered Percent 
Totals          72    36      50.00   
Total Bits      4844  3475    71.74   
Total Bits 0->1 2422  1737    71.72   
Total Bits 1->0 2422  1738    71.76   

                                
Ports          48   24   50.00  
Port Bits      3878 2919 75.27  
Port Bits 0->1 1939 1459 75.24  
Port Bits 1->0 1939 1460 75.30  

                                
Signals          24  12  50.00  
Signal Bits      966 556 57.56  
Signal Bits 0->1 483 278 57.56  
Signal Bits 1->0 483 278 57.56  

Port Details
                                     Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i                                Yes    Yes         Yes         INPUT     
rst_i                                No     Yes         No          INPUT     
mshr_entry_idx_i[3:0]                No     No          No          INPUT     
mshr_entry_o.mem_tag[3:0]            Yes    Yes         Yes         OUTPUT    
mshr_entry_o.linked                  No     No          No          OUTPUT    
mshr_entry_o.link_idx[3:0]           No     No          No          OUTPUT    
mshr_entry_o.evict_dirty             Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_data[0]           No     No          No          OUTPUT    
mshr_entry_o.evict_data[1]           Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_data[3:2]         No     No          No          OUTPUT    
mshr_entry_o.evict_data[9:4]         Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_data[11:10]       No     No          No          OUTPUT    
mshr_entry_o.evict_data[16:12]       Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_data[17]          No     No          No          OUTPUT    
mshr_entry_o.evict_data[18]          Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_data[19]          No     No          No          OUTPUT    
mshr_entry_o.evict_data[24:20]       Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_data[26:25]       No     No          No          OUTPUT    
mshr_entry_o.evict_data[28:27]       Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_data[29]          No     No          No          OUTPUT    
mshr_entry_o.evict_data[31:30]       Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_data[63:32]       No     No          No          OUTPUT    
mshr_entry_o.evict_addr[2:0]         No     No          No          OUTPUT    
mshr_entry_o.evict_addr[15:3]        Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_addr[31:16]       No     No          No          OUTPUT    
mshr_entry_o.req_size[1:0]           Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_data[27:0]          Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_data[28]            No     No          No          OUTPUT    
mshr_entry_o.req_data[31:29]         Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_data[32]            No     No          No          OUTPUT    
mshr_entry_o.req_data[35:33]         Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_data[38:36]         No     No          No          OUTPUT    
mshr_entry_o.req_data[39]            Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_data[42:40]         No     No          No          OUTPUT    
mshr_entry_o.req_data[44:43]         Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_data[45]            No     No          No          OUTPUT    
mshr_entry_o.req_data[48:46]         Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_data[49]            No     No          No          OUTPUT    
mshr_entry_o.req_data[50]            Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_data[53:51]         No     No          No          OUTPUT    
mshr_entry_o.req_data[54]            Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_data[56:55]         No     No          No          OUTPUT    
mshr_entry_o.req_data[58:57]         Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_data[60:59]         No     No          No          OUTPUT    
mshr_entry_o.req_data[61]            Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_data[63:62]         No     No          No          OUTPUT    
mshr_entry_o.req_addr[15:0]          Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_addr[31:16]         No     No          No          OUTPUT    
mshr_entry_o.cmd[1:0]                Yes    Yes         Yes         OUTPUT    
mshr_entry_o.state[2:0]              Yes    Yes         Yes         OUTPUT    
proc_grant_i                         Yes    Yes         Yes         INPUT     
proc2cache_i.command[1:0]            Yes    Yes         Yes         INPUT     
proc2cache_i.size[1:0]               Yes    Yes         Yes         INPUT     
proc2cache_i.data[63:0]              Yes    Yes         Yes         INPUT     
proc2cache_i.addr[15:0]              Yes    Yes         Yes         INPUT     
proc2cache_i.addr[31:16]             No     No          No          INPUT     
mshr_proc_o.tag[1:0]                 No     No          No          OUTPUT    
mshr_proc_o.tag[3:2]                 Yes    Yes         Yes         OUTPUT    
mshr_proc_o.data[0]                  No     No          No          OUTPUT    
mshr_proc_o.data[3:1]                Yes    Yes         Yes         OUTPUT    
mshr_proc_o.data[4]                  No     No          No          OUTPUT    
mshr_proc_o.data[6:5]                Yes    Yes         Yes         OUTPUT    
mshr_proc_o.data[63:7]               No     No          No          OUTPUT    
mshr_proc_o.response[1:0]            No     No          No          OUTPUT    
mshr_proc_o.response[3:2]            Yes    Yes         Yes         OUTPUT    
cache_mem_grant_i                    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.evict_data[63:0]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.evict_addr[2:0]     No     No          No          INPUT     
cache_mem_ctrl_i.evict_addr[15:3]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.evict_addr[31:16]   No     No          No          INPUT     
cache_mem_ctrl_i.evict_dirty         Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[4:0]   Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[6:5]   No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[8:7]   Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[11:9]  No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[13:12] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[15:14] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[25:16] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[26]    No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[31:27] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[33:32] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[34]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[37:35] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[38]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[41:39] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[42]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[45:43] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[47:46] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[50:48] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[52:51] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[54:53] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[58:55] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[60:59] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[63:61] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_hit             Yes    Yes         Yes         INPUT     
mshr_cache_mem_o.req_data_in[36:0]   Yes    Yes         Yes         OUTPUT    
mshr_cache_mem_o.req_data_in[37]     No     No          No          OUTPUT    
mshr_cache_mem_o.req_data_in[51:38]  Yes    Yes         Yes         OUTPUT    
mshr_cache_mem_o.req_data_in[52]     No     No          No          OUTPUT    
mshr_cache_mem_o.req_data_in[63:53]  Yes    Yes         Yes         OUTPUT    
mshr_cache_mem_o.req_addr[15:0]      Yes    Yes         Yes         OUTPUT    
mshr_cache_mem_o.req_addr[31:16]     No     No          No          OUTPUT    
mshr_cache_mem_o.req_cmd[2:0]        Yes    Yes         Yes         OUTPUT    
memory_grant_i                       Yes    Yes         Yes         INPUT     
mem2cache_i.tag[3:0]                 Yes    Yes         Yes         INPUT     
mem2cache_i.data[63:0]               Yes    Yes         Yes         INPUT     
mem2cache_i.response[3:0]            Yes    Yes         Yes         INPUT     
mshr_memory_o.command[1:0]           Yes    Yes         Yes         OUTPUT    
mshr_memory_o.size[1:0]              No     No          No          OUTPUT    
mshr_memory_o.data[0]                No     No          No          OUTPUT    
mshr_memory_o.data[1]                Yes    Yes         Yes         OUTPUT    
mshr_memory_o.data[3:2]              No     No          No          OUTPUT    
mshr_memory_o.data[9:4]              Yes    Yes         Yes         OUTPUT    
mshr_memory_o.data[11:10]            No     No          No          OUTPUT    
mshr_memory_o.data[16:12]            Yes    Yes         Yes         OUTPUT    
mshr_memory_o.data[17]               No     No          No          OUTPUT    
mshr_memory_o.data[18]               Yes    Yes         Yes         OUTPUT    
mshr_memory_o.data[19]               No     No          No          OUTPUT    
mshr_memory_o.data[24:20]            Yes    Yes         Yes         OUTPUT    
mshr_memory_o.data[26:25]            No     No          No          OUTPUT    
mshr_memory_o.data[28:27]            Yes    Yes         Yes         OUTPUT    
mshr_memory_o.data[29]               No     No          No          OUTPUT    
mshr_memory_o.data[31:30]            Yes    Yes         Yes         OUTPUT    
mshr_memory_o.data[63:32]            No     No          No          OUTPUT    
mshr_memory_o.addr[2:0]              No     No          No          OUTPUT    
mshr_memory_o.addr[15:3]             Yes    Yes         Yes         OUTPUT    
mshr_memory_o.addr[31:16]            No     No          No          OUTPUT    
mshr_hit_i                           Yes    Yes         Yes         INPUT     
mshr_hit_idx_i[3:0]                  Yes    Yes         Yes         INPUT     
evict_hit_i                          No     No          No          INPUT     
evict_hit_idx_i[3:0]                 No     No          No          INPUT     
dp_sel_i                             Yes    Yes         Yes         INPUT     
mshr_cp_flag_o                       Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[4:0]                  Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[5]                    No     No          No          OUTPUT    
mshr_cp_data_o[27:6]                 Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[28]                   No     No          No          OUTPUT    
mshr_cp_data_o[31:29]                Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[32]                   No     No          No          OUTPUT    
mshr_cp_data_o[35:33]                Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[38:36]                No     No          No          OUTPUT    
mshr_cp_data_o[39]                   Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[42:40]                No     No          No          OUTPUT    
mshr_cp_data_o[44:43]                Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[45]                   No     No          No          OUTPUT    
mshr_cp_data_o[48:46]                Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[49]                   No     No          No          OUTPUT    
mshr_cp_data_o[50]                   Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[53:51]                No     No          No          OUTPUT    
mshr_cp_data_o[54]                   Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[56:55]                No     No          No          OUTPUT    
mshr_cp_data_o[58:57]                Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[60:59]                No     No          No          OUTPUT    
mshr_cp_data_o[61]                   Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[63:62]                No     No          No          OUTPUT    
cp_flag_i[0]                         No     No          No          INPUT     
cp_flag_i[15:1]                      Yes    Yes         Yes         INPUT     
cp_data_i[8:1][63:0]                 Yes    Yes         Yes         INPUT     
cp_data_i[9][44:0]                   Yes    Yes         Yes         INPUT     
cp_data_i[9][63:46]                  Yes    Yes         Yes         INPUT     
cp_data_i[10][30:1]                  Yes    Yes         Yes         INPUT     
cp_data_i[10][36:32]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][41:40]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][45]                    Yes    Yes         Yes         INPUT     
cp_data_i[10][49:47]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][52:51]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][56:55]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][60]                    Yes    Yes         Yes         INPUT     
cp_data_i[10][62]                    Yes    Yes         Yes         INPUT     
cp_data_i[11][27:0]                  Yes    Yes         Yes         INPUT     
cp_data_i[11][36:29]                 Yes    Yes         Yes         INPUT     
cp_data_i[11][49:39]                 Yes    Yes         Yes         INPUT     
cp_data_i[11][51]                    Yes    Yes         Yes         INPUT     
cp_data_i[11][59:54]                 Yes    Yes         Yes         INPUT     
cp_data_i[11][63:62]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][4:0]                   Yes    Yes         Yes         INPUT     
cp_data_i[12][27:6]                  Yes    Yes         Yes         INPUT     
cp_data_i[12][31:29]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][35:33]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][39]                    Yes    Yes         Yes         INPUT     
cp_data_i[12][44:43]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][48:46]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][50]                    Yes    Yes         Yes         INPUT     
cp_data_i[12][54]                    Yes    Yes         Yes         INPUT     
cp_data_i[12][58:57]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][61]                    Yes    Yes         Yes         INPUT     
cp_data_i[13][17:0]                  Yes    Yes         Yes         INPUT     
cp_data_i[13][46:19]                 Yes    Yes         Yes         INPUT     
cp_data_i[13][49]                    Yes    Yes         Yes         INPUT     
cp_data_i[13][56:51]                 Yes    Yes         Yes         INPUT     
cp_data_i[13][63:58]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][14:1]                  Yes    Yes         Yes         INPUT     
cp_data_i[14][19:16]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][21]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][24:23]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][27]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][32:30]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][37:35]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][39]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][41]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][43]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][46:45]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][51:49]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][59:53]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][62:61]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][15:0]                  Yes    Yes         Yes         INPUT     
cp_data_i[15][37:17]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][40:39]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][42]                    Yes    Yes         Yes         INPUT     
cp_data_i[15][45:44]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][48:47]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][53:51]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][55]                    Yes    Yes         Yes         INPUT     
cp_data_i[15][63:57]                 Yes    Yes         Yes         INPUT     
Other bits of cp_data_i[15:0][63:0]  No     No          No          INPUT     

Signal Details
                                  Toggle Toggle 1->0 Toggle 0->1 
mshr_entry.mem_tag[3:0]           Yes    Yes         Yes         
mshr_entry.linked                 No     No          No          
mshr_entry.link_idx[3:0]          No     No          No          
mshr_entry.evict_dirty            Yes    Yes         Yes         
mshr_entry.evict_data[0]          No     No          No          
mshr_entry.evict_data[1]          Yes    Yes         Yes         
mshr_entry.evict_data[3:2]        No     No          No          
mshr_entry.evict_data[9:4]        Yes    Yes         Yes         
mshr_entry.evict_data[11:10]      No     No          No          
mshr_entry.evict_data[16:12]      Yes    Yes         Yes         
mshr_entry.evict_data[17]         No     No          No          
mshr_entry.evict_data[18]         Yes    Yes         Yes         
mshr_entry.evict_data[19]         No     No          No          
mshr_entry.evict_data[24:20]      Yes    Yes         Yes         
mshr_entry.evict_data[26:25]      No     No          No          
mshr_entry.evict_data[28:27]      Yes    Yes         Yes         
mshr_entry.evict_data[29]         No     No          No          
mshr_entry.evict_data[31:30]      Yes    Yes         Yes         
mshr_entry.evict_data[63:32]      No     No          No          
mshr_entry.evict_addr[2:0]        No     No          No          
mshr_entry.evict_addr[15:3]       Yes    Yes         Yes         
mshr_entry.evict_addr[31:16]      No     No          No          
mshr_entry.req_size[1:0]          Yes    Yes         Yes         
mshr_entry.req_data[27:0]         Yes    Yes         Yes         
mshr_entry.req_data[28]           No     No          No          
mshr_entry.req_data[31:29]        Yes    Yes         Yes         
mshr_entry.req_data[32]           No     No          No          
mshr_entry.req_data[35:33]        Yes    Yes         Yes         
mshr_entry.req_data[38:36]        No     No          No          
mshr_entry.req_data[39]           Yes    Yes         Yes         
mshr_entry.req_data[42:40]        No     No          No          
mshr_entry.req_data[44:43]        Yes    Yes         Yes         
mshr_entry.req_data[45]           No     No          No          
mshr_entry.req_data[48:46]        Yes    Yes         Yes         
mshr_entry.req_data[49]           No     No          No          
mshr_entry.req_data[50]           Yes    Yes         Yes         
mshr_entry.req_data[53:51]        No     No          No          
mshr_entry.req_data[54]           Yes    Yes         Yes         
mshr_entry.req_data[56:55]        No     No          No          
mshr_entry.req_data[58:57]        Yes    Yes         Yes         
mshr_entry.req_data[60:59]        No     No          No          
mshr_entry.req_data[61]           Yes    Yes         Yes         
mshr_entry.req_data[63:62]        No     No          No          
mshr_entry.req_addr[15:0]         Yes    Yes         Yes         
mshr_entry.req_addr[31:16]        No     No          No          
mshr_entry.cmd[1:0]               Yes    Yes         Yes         
mshr_entry.state[2:0]             Yes    Yes         Yes         
next_mshr_entry.mem_tag[3:0]      Yes    Yes         Yes         
next_mshr_entry.linked            Yes    Yes         Yes         
next_mshr_entry.link_idx[1:0]     Yes    Yes         Yes         
next_mshr_entry.link_idx[2]       No     No          No          
next_mshr_entry.link_idx[3]       Yes    Yes         Yes         
next_mshr_entry.evict_dirty       Yes    Yes         Yes         
next_mshr_entry.evict_data[0]     No     No          No          
next_mshr_entry.evict_data[1]     Yes    Yes         Yes         
next_mshr_entry.evict_data[3:2]   No     No          No          
next_mshr_entry.evict_data[9:4]   Yes    Yes         Yes         
next_mshr_entry.evict_data[11:10] No     No          No          
next_mshr_entry.evict_data[16:12] Yes    Yes         Yes         
next_mshr_entry.evict_data[17]    No     No          No          
next_mshr_entry.evict_data[18]    Yes    Yes         Yes         
next_mshr_entry.evict_data[19]    No     No          No          
next_mshr_entry.evict_data[24:20] Yes    Yes         Yes         
next_mshr_entry.evict_data[26:25] No     No          No          
next_mshr_entry.evict_data[28:27] Yes    Yes         Yes         
next_mshr_entry.evict_data[29]    No     No          No          
next_mshr_entry.evict_data[31:30] Yes    Yes         Yes         
next_mshr_entry.evict_data[63:32] No     No          No          
next_mshr_entry.evict_addr[2:0]   No     No          No          
next_mshr_entry.evict_addr[15:3]  Yes    Yes         Yes         
next_mshr_entry.evict_addr[31:16] No     No          No          
next_mshr_entry.req_size[1:0]     Yes    Yes         Yes         
next_mshr_entry.req_data[27:0]    Yes    Yes         Yes         
next_mshr_entry.req_data[28]      No     No          No          
next_mshr_entry.req_data[36:29]   Yes    Yes         Yes         
next_mshr_entry.req_data[38:37]   No     No          No          
next_mshr_entry.req_data[51:39]   Yes    Yes         Yes         
next_mshr_entry.req_data[53:52]   No     No          No          
next_mshr_entry.req_data[59:54]   Yes    Yes         Yes         
next_mshr_entry.req_data[60]      No     No          No          
next_mshr_entry.req_data[63:61]   Yes    Yes         Yes         
next_mshr_entry.req_addr[15:0]    Yes    Yes         Yes         
next_mshr_entry.req_addr[31:16]   No     No          No          
next_mshr_entry.cmd[1:0]          Yes    Yes         Yes         
next_mshr_entry.state[2:0]        Yes    Yes         Yes         
next_mshr_cp_flag                 Yes    Yes         Yes         
next_mshr_cp_data[4:0]            Yes    Yes         Yes         
next_mshr_cp_data[5]              No     No          No          
next_mshr_cp_data[27:6]           Yes    Yes         Yes         
next_mshr_cp_data[28]             No     No          No          
next_mshr_cp_data[31:29]          Yes    Yes         Yes         
next_mshr_cp_data[32]             No     No          No          
next_mshr_cp_data[35:33]          Yes    Yes         Yes         
next_mshr_cp_data[38:36]          No     No          No          
next_mshr_cp_data[39]             Yes    Yes         Yes         
next_mshr_cp_data[42:40]          No     No          No          
next_mshr_cp_data[44:43]          Yes    Yes         Yes         
next_mshr_cp_data[45]             No     No          No          
next_mshr_cp_data[48:46]          Yes    Yes         Yes         
next_mshr_cp_data[49]             No     No          No          
next_mshr_cp_data[50]             Yes    Yes         Yes         
next_mshr_cp_data[53:51]          No     No          No          
next_mshr_cp_data[54]             Yes    Yes         Yes         
next_mshr_cp_data[56:55]          No     No          No          
next_mshr_cp_data[58:57]          Yes    Yes         Yes         
next_mshr_cp_data[60:59]          No     No          No          
next_mshr_cp_data[61]             Yes    Yes         Yes         
next_mshr_cp_data[63:62]          No     No          No          


-------------------------------------------------------------------------------
===============================================================================
Module Instance : cache_tb.dut.cache_ctrl_inst.genblk1[14].mshr_entry_ctrl_inst
===============================================================================

Instance :

SCORE  LINE   TOGGLE 
 74.74  73.81  75.66 


Instance's subtree :

SCORE  LINE   TOGGLE 
 74.74  73.81  75.66 


Module : 

SCORE  LINE   TOGGLE NAME            
 87.59  90.48  84.70 mshr_entry_ctrl 


Parent : 

SCORE  LINE   TOGGLE NAME            
 92.38 100.00  84.76 cache_ctrl_inst 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : cache_tb.dut.cache_ctrl_inst.genblk1[14].mshr_entry_ctrl_inst

             Line No.   Total   Covered  Percent
TOTAL                      210      155    73.81
ALWAYS             75       17       17   100.00
ALWAYS             97      135       89    65.93
ALWAYS            317       25       16    64.00
ALWAYS            368       22       22   100.00
ALWAYS            411       11       11   100.00

74                          always_ff @(posedge clk_i) begin
75         1/1                  if (rst_i) begin
76         1/1                      mshr_entry.state        <=  `SD ST_IDLE     ;
77         1/1                      mshr_entry.cmd          <=  `SD BUS_NONE    ;
78         1/1                      mshr_entry.req_addr     <=  `SD 'b0         ;
79         1/1                      mshr_entry.req_data     <=  `SD 'b0         ;
80         1/1                      mshr_entry.req_size     <=  `SD BYTE        ;
81         1/1                      mshr_entry.evict_addr   <=  `SD 'b0         ;
82         1/1                      mshr_entry.evict_data   <=  `SD 'b0         ;
83         1/1                      mshr_entry.evict_dirty  <=  `SD 1'b0        ;
84         1/1                      mshr_entry.link_idx     <=  `SD 'd0         ;
85         1/1                      mshr_entry.linked       <=  `SD 1'b0        ;
86         1/1                      mshr_entry.mem_tag      <=  `SD 'd0         ;
87         1/1                      mshr_cp_flag_o          <=  `SD 1'b0        ;
88         1/1                      mshr_cp_data_o          <=  `SD 'b0         ;
89                              end else begin
90         1/1                      mshr_entry              <=  `SD next_mshr_entry     ;
91         1/1                      mshr_cp_flag_o          <=  `SD next_mshr_cp_flag   ;
92         1/1                      mshr_cp_data_o          <=  `SD next_mshr_cp_data   ;
93                              end
94                          end
95                      
96                          always_comb begin
97         1/1                  next_mshr_entry.state       =   mshr_entry.state        ;
98         1/1                  next_mshr_entry.cmd         =   mshr_entry.cmd          ;
99         1/1                  next_mshr_entry.req_addr    =   mshr_entry.req_addr     ;
100        1/1                  next_mshr_entry.req_data    =   mshr_entry.req_data     ;
101        1/1                  next_mshr_entry.req_size    =   mshr_entry.req_size     ;
102        1/1                  next_mshr_entry.evict_addr  =   mshr_entry.evict_addr   ;
103        1/1                  next_mshr_entry.evict_data  =   mshr_entry.evict_data   ;
104        1/1                  next_mshr_entry.evict_dirty =   mshr_entry.evict_dirty  ;
105        1/1                  next_mshr_entry.link_idx    =   mshr_entry.link_idx     ;
106        1/1                  next_mshr_entry.linked      =   mshr_entry.linked       ;
107        1/1                  next_mshr_entry.mem_tag     =   mshr_entry.mem_tag      ;
108        1/1                  next_mshr_cp_flag           =   mshr_cp_flag_o          ;
109        1/1                  next_mshr_cp_data           =   mshr_cp_data_o          ;
110        1/1                  case (mshr_entry.state)
111                                 ST_IDLE     :   begin
112                                     // IF   there is a valid transaction on Processor Interface
113                                     // AND  the Processor Interface is granted to this entry
114                                     // AND  the cache_mem Interface is granted to this entry
115                                     // AND  it is a miss
116                                     // AND  the entry is selected to hold the new miss
117        1/1                          if ((proc2cache_i.command != BUS_NONE) && (dp_sel_i == 1'b1)
118                                     && (proc_grant_i == 1'b1)) begin
119                                         // IF   there is an older in-flight transaction to the same addreess
120                                         // ->   Wait for the completion of older miss to the same address
121        1/1                              if (mshr_hit_i && (cp_flag_i[mshr_hit_idx_i] == 1'b0)) begin
122        1/1                                  next_mshr_entry.state       =   ST_WAIT_DEPEND          ;
123        1/1                                  next_mshr_entry.link_idx    =   mshr_hit_idx_i          ;
124        1/1                                  next_mshr_entry.cmd         =   proc2cache_i.command    ;
125        1/1                                  next_mshr_entry.req_addr    =   proc2cache_i.addr       ;
126        1/1                                  next_mshr_entry.req_size    =   proc2cache_i.size       ;
127        1/1                                  if (proc2cache_i.command == BUS_STORE) begin
128        1/1                                      next_mshr_entry.req_data    =   proc2cache_i.data   ;
129                                             end
                        MISSING_ELSE
130                                         // IF   there is an older in-flight transaction that is in the middle of evicting the data block
131                                         // ->   Wait for the completion of write-back to memory
132        1/1                              end else if (evict_hit_i && (cp_flag_i[evict_hit_idx_i] == 1'b0)) begin
133        0/1     ==>                          next_mshr_entry.state       =   ST_WAIT_EVICT           ;
134        0/1     ==>                          next_mshr_entry.link_idx    =   evict_hit_idx_i         ;
135        0/1     ==>                          next_mshr_entry.cmd         =   proc2cache_i.command    ;
136        0/1     ==>                          next_mshr_entry.req_addr    =   proc2cache_i.addr       ;
137        0/1     ==>                          next_mshr_entry.req_size    =   proc2cache_i.size       ;
138        0/1     ==>                          if (proc2cache_i.command == BUS_STORE) begin
139        0/1     ==>                              next_mshr_entry.req_data    =   proc2cache_i.data   ;
140                                             end
                   ==>  MISSING_ELSE
141                                         // IF   it is a miss, and no dependency to older in-flight transactions.
142                                         // ->   Start miss handling
143        1/1                              end else if ((cache_mem_ctrl_i.req_hit == 1'b0) && (cache_mem_grant_i == 1'b1)) begin
144        1/1                                  next_mshr_entry.state       =   ST_RD_MEM               ;
145        1/1                                  next_mshr_entry.link_idx    =   'd0                     ;
146        1/1                                  next_mshr_entry.cmd         =   proc2cache_i.command    ;
147        1/1                                  next_mshr_entry.req_addr    =   proc2cache_i.addr       ;
148        1/1                                  next_mshr_entry.req_size    =   proc2cache_i.size       ;
149        1/1                                  if (proc2cache_i.command == BUS_STORE) begin
150        1/1                                      next_mshr_entry.req_data    =   proc2cache_i.data   ;
151                                             end
                        MISSING_ELSE
152                                         end
                   ==>  MISSING_ELSE
153                                     end
                        MISSING_ELSE
154        1/1                          next_mshr_cp_flag   =   1'b0    ;
155        1/1                          next_mshr_cp_data   =   'b0     ;
156                                 end
157                                 ST_WAIT_DEPEND  :   begin
158                                     // IF   the older transaction that the entry is linked to completed
159                                     // ->   Update the cache data
160        0/1     ==>                  if (cp_flag_i[mshr_entry.link_idx] == 1'b1) begin
161        0/1     ==>                      next_mshr_entry.state       =   ST_UPDATE   ;
162        0/1     ==>                      next_mshr_entry.link_idx    =   'd0         ;
163        0/1     ==>                      next_mshr_entry.req_data    =   cp_data_i[mshr_entry.link_idx];
164        0/1     ==>                      if (mshr_entry.cmd == BUS_STORE) begin
165        0/1     ==>                          case (mshr_entry.req_size)
166        0/1     ==>                              BYTE    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +:  8]    =   mshr_entry.req_data[ 7:0]   ;
167        0/1     ==>                              HALF    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +: 16]    =   mshr_entry.req_data[15:0]   ;
168        0/1     ==>                              WORD    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +: 32]    =   mshr_entry.req_data[31:0]   ;
169        0/1     ==>                              DOUBLE  :   next_mshr_entry.req_data                                    =   mshr_entry.req_data         ;
170        0/1     ==>                              default :   next_mshr_entry.req_data                                    =   mshr_entry.req_data         ;
171                                             endcase
172                                         end
                   ==>  MISSING_ELSE
173                                     end
                   ==>  MISSING_ELSE
174                                 end
175                                 ST_WAIT_EVICT   : begin
176                                     // IF   the older transaction that evicts the cache block completed
177                                     // ->   Read from Memory
178        0/1     ==>                  if (cp_flag_i[mshr_entry.link_idx] == 1'b1) begin
179        0/1     ==>                      next_mshr_entry.state       =   ST_RD_MEM   ;
180        0/1     ==>                      next_mshr_entry.link_idx    =   'd0         ;
181                                     end
                   ==>  MISSING_ELSE
182                                 end
183                                 ST_RD_MEM   :   begin
184                                     // IF   the read transaction is confirmed by Memory Interface
185                                     // ->   Wait for the data to return from Memory
186        1/1                          if ((memory_grant_i == 1'b1) && (mem2cache_i.response != 'd0)) begin
187        1/1                              next_mshr_entry.state       =   ST_WAIT_MEM             ;
188        1/1                              next_mshr_entry.mem_tag     =   mem2cache_i.response    ;
189                                     end
                        MISSING_ELSE
190                                 end
191                                 ST_WAIT_MEM :   begin
192                                     // IF   the data is returned from the Memory
193                                     // ->   Update the cache data
194        1/1                          if (mem2cache_i.tag == mshr_entry.mem_tag) begin
195        1/1                              next_mshr_entry.state       =   ST_UPDATE           ;
196        1/1                              next_mshr_entry.req_data    =   mem2cache_i.data    ;
197        1/1                              if (mshr_entry.cmd == BUS_STORE) begin
198        1/1                                  case (mshr_entry.req_size)
199        1/1                                      BYTE    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +:  8]    =   mshr_entry.req_data[ 7:0]   ;
200        1/1                                      HALF    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +: 16]    =   mshr_entry.req_data[15:0]   ;
201        1/1                                      WORD    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +: 32]    =   mshr_entry.req_data[31:0]   ;
202        1/1                                      DOUBLE  :   next_mshr_entry.req_data                                    =   mshr_entry.req_data         ;
203        0/1     ==>                              default :   next_mshr_entry.req_data                                    =   mshr_entry.req_data         ;
204                                             endcase
205                                         end
                        MISSING_ELSE
206                                     end
                        MISSING_ELSE
207                                 end
208                                 ST_UPDATE   :   begin
209                                     // IF   the req interface is granted to this entry
210        1/1                          if (cache_mem_grant_i == 1'b1) begin
211                                         // IF   it is a load miss
212                                         // ->   Output data to processor
213        1/1                              if (mshr_entry.cmd == BUS_LOAD) begin
214        1/1                                  next_mshr_entry.state       =   ST_OUTPUT;
215        1/1                                  next_mshr_entry.evict_addr  =   cache_mem_ctrl_i.evict_addr ;
216        1/1                                  next_mshr_entry.evict_data  =   cache_mem_ctrl_i.evict_data ;
217        1/1                                  next_mshr_entry.evict_dirty =   cache_mem_ctrl_i.evict_dirty;
218                                         // IF   a dirty block is evicted
219                                         // ->   Write back the evicted block
220        1/1                              end else if (cache_mem_ctrl_i.evict_dirty == 1'b1) begin
221        1/1                                  next_mshr_entry.state       =   ST_EVICT;
222        1/1                                  next_mshr_entry.evict_addr  =   cache_mem_ctrl_i.evict_addr ;
223        1/1                                  next_mshr_entry.evict_data  =   cache_mem_ctrl_i.evict_data ;
224        1/1                                  next_mshr_entry.evict_dirty =   cache_mem_ctrl_i.evict_dirty;
225                                         // ELSE
226                                         // ->   Miss Handling Completed
227                                         end else begin
228        0/1     ==>                          next_mshr_entry.state       =   ST_IDLE             ;
229        0/1     ==>                          next_mshr_entry.cmd         =   BUS_NONE            ;
230        0/1     ==>                          next_mshr_entry.req_addr    =   'b0                 ;
231        0/1     ==>                          next_mshr_entry.req_data    =   'b0                 ;
232        0/1     ==>                          next_mshr_entry.req_size    =   BYTE                ;
233        0/1     ==>                          next_mshr_entry.evict_addr  =   'b0                 ;
234        0/1     ==>                          next_mshr_entry.evict_data  =   'b0                 ;
235        0/1     ==>                          next_mshr_entry.evict_dirty =   1'b0                ;
236        0/1     ==>                          next_mshr_entry.link_idx    =   'd0                 ;
237        0/1     ==>                          next_mshr_entry.mem_tag     =   'd0                 ;
238        0/1     ==>                          next_mshr_cp_flag           =   1'b1                ;
239        0/1     ==>                          next_mshr_cp_data           =   mshr_entry.req_data ;
240                                         end
241                                     end
                        MISSING_ELSE
242                                 end
243                                 ST_OUTPUT   :   begin
244                                     // IF   the Processor Interface is granted to this entry
245        1/1                          if (proc_grant_i == 1'b1) begin
246                                         // IF   the evicted block is dirty
247                                         // ->   Write back the evicted block
248        1/1                              if (mshr_entry.evict_dirty == 1'b1) begin
249        1/1                                  next_mshr_entry.state       =   ST_EVICT;
250                                         // ELSE
251                                         // ->   Miss Handling Completed
252                                         end else begin
253        0/1     ==>                          next_mshr_entry.state       =   ST_IDLE             ;
254        0/1     ==>                          next_mshr_entry.cmd         =   BUS_NONE            ;
255        0/1     ==>                          next_mshr_entry.req_addr    =   'b0                 ;
256        0/1     ==>                          next_mshr_entry.req_data    =   'b0                 ;
257        0/1     ==>                          next_mshr_entry.req_size    =   BYTE                ;
258        0/1     ==>                          next_mshr_entry.evict_addr  =   'b0                 ;
259        0/1     ==>                          next_mshr_entry.evict_data  =   'b0                 ;
260        0/1     ==>                          next_mshr_entry.evict_dirty =   1'b0                ;
261        0/1     ==>                          next_mshr_entry.link_idx    =   'd0                 ;
262        0/1     ==>                          next_mshr_entry.mem_tag     =   'd0                 ;
263        0/1     ==>                          next_mshr_cp_flag           =   1'b1                ;
264        0/1     ==>                          next_mshr_cp_data           =   mshr_entry.req_data ;
265                                         end
266                                     end
                        MISSING_ELSE
267                                 end
268                                 ST_EVICT    :   begin
269                                     // IF   the write back transaction to Memory is confirmed
270                                     // ->   Miss Handling Completed
271        1/1                          if ((memory_grant_i == 1'b1) && (mem2cache_i.response != 'd0)) begin
272        1/1                              next_mshr_entry.state       =   ST_IDLE             ;
273        1/1                              next_mshr_entry.cmd         =   BUS_NONE            ;
274        1/1                              next_mshr_entry.req_addr    =   'b0                 ;
275        1/1                              next_mshr_entry.req_data    =   'b0                 ;
276        1/1                              next_mshr_entry.req_size    =   BYTE                ;
277        1/1                              next_mshr_entry.evict_addr  =   'b0                 ;
278        1/1                              next_mshr_entry.evict_data  =   'b0                 ;
279        1/1                              next_mshr_entry.evict_dirty =   1'b0                ;
280        1/1                              next_mshr_entry.link_idx    =   'd0                 ;
281        1/1                              next_mshr_entry.mem_tag     =   'd0                 ;
282        1/1                              next_mshr_cp_flag           =   1'b1                ;
283        1/1                              next_mshr_cp_data           =   mshr_entry.req_data ;
284                                     end
                        MISSING_ELSE
285                                 end
286                                 default     :   begin
287        1/1                          next_mshr_entry.state       =   ST_IDLE     ;
288        1/1                          next_mshr_entry.cmd         =   BUS_NONE    ;
289        1/1                          next_mshr_entry.req_addr    =   'b0         ;
290        1/1                          next_mshr_entry.req_data    =   'b0         ;
291        1/1                          next_mshr_entry.req_size    =   BYTE        ;
292        1/1                          next_mshr_entry.evict_addr  =   'b0         ;
293        1/1                          next_mshr_entry.evict_data  =   'b0         ;
294        1/1                          next_mshr_entry.evict_dirty =   1'b0        ;
295        1/1                          next_mshr_entry.link_idx    =   'd0         ;
296        1/1                          next_mshr_entry.mem_tag     =   'd0         ;
297        1/1                          next_mshr_cp_flag           =   1'b0        ;
298        1/1                          next_mshr_cp_data           =   'd0         ;
299                                 end
300                             endcase
301                     
302        1/1                  if (next_mshr_entry.state == ST_IDLE) begin
303        1/1                      next_mshr_entry.linked  =   1'b0;
304        1/1                  end else if ((mshr_hit_i == 1'b1) && (mshr_hit_idx_i == mshr_entry_idx_i)) begin
305        1/1                      next_mshr_entry.linked  =   1'b1;
306                             end
                        MISSING_ELSE
307                         end
308                     
309                     // --------------------------------------------------------------------
310                     // MSHR entry output
311                     // --------------------------------------------------------------------
312                         assign  mshr_entry_o    =   mshr_entry  ;
313                     // --------------------------------------------------------------------
314                     // Processor Interface
315                     // --------------------------------------------------------------------
316                         always_comb begin
317        1/1                  mshr_proc_o.response    =   'd0 ;
318        1/1                  mshr_proc_o.data        =   'b0 ;
319        1/1                  mshr_proc_o.tag         =   'd0 ;
320        1/1                  case (mshr_entry.state)
321                                 ST_IDLE     :   begin
322                                     // IF   the processor request is allocated to this entry
323        1/1                          if ((proc2cache_i.command != BUS_NONE) && (dp_sel_i == 1'b1)) begin
324                                         // IF   The Processor Interface is granted to this entry
325                                         // AND  there is a dependency to older in-flight transaction
326                                         // ->   Confirm the request
327        1/1                              if (((mshr_hit_i && (cp_flag_i[mshr_hit_idx_i] == 1'b0))
328                                         || (evict_hit_i && (cp_flag_i[evict_hit_idx_i] == 1'b0)))) begin
329        1/1                                  mshr_proc_o.response    =   mshr_entry_idx_i;
330                                         // IF   The Processor Interface is granted to this entry
331                                         // AND  The cache_mem Interface is granted to this entry
332                                         // ->   Confirm the request 
333        1/1                              end else if (cache_mem_grant_i == 1'b1) begin
334        1/1                                  mshr_proc_o.response    =   mshr_entry_idx_i;
335                                             // IF   it is a load hit
336                                             // ->   Output data and tag
337        1/1                                  if (cache_mem_ctrl_i.req_hit == 1'b1 && proc2cache_i.command == BUS_LOAD) begin
338        0/1     ==>                              mshr_proc_o.tag     =   mshr_entry_idx_i;
339        0/1     ==>                              case (proc2cache_i.size)
340        0/1     ==>                                  BYTE    :   mshr_proc_o.data    =   {56'b0,cache_mem_ctrl_i.req_data_out[proc2cache_i.addr[2:0]+: 8]};
341        0/1     ==>                                  HALF    :   mshr_proc_o.data    =   {48'b0,cache_mem_ctrl_i.req_data_out[proc2cache_i.addr[2:0]+:16]};
342        0/1     ==>                                  WORD    :   mshr_proc_o.data    =   {32'b0,cache_mem_ctrl_i.req_data_out[proc2cache_i.addr[2:0]+:32]};
343        0/1     ==>                                  DOUBLE  :   mshr_proc_o.data    =   cache_mem_ctrl_i.req_data_out;
344        0/1     ==>                                  default :   mshr_proc_o.data    =   cache_mem_ctrl_i.req_data_out;
345                                                 endcase
346                                             end
                        MISSING_ELSE
347                                         end
                        MISSING_ELSE
348                                     end
                        MISSING_ELSE
349                                 end
350                                 ST_OUTPUT   :   begin
351        1/1                          mshr_proc_o.response    =   'd0                 ;
352        1/1                          mshr_proc_o.tag         =   mshr_entry_idx_i    ;
353        1/1                          case (mshr_entry.req_size)
354        1/1                              BYTE    :   mshr_proc_o.data    =   {56'b0,mshr_entry.req_data[mshr_entry.req_addr[2:0]+: 8]};
355        1/1                              HALF    :   mshr_proc_o.data    =   {48'b0,mshr_entry.req_data[mshr_entry.req_addr[2:0]+:16]};
356        0/1     ==>                      WORD    :   mshr_proc_o.data    =   {32'b0,mshr_entry.req_data[mshr_entry.req_addr[2:0]+:32]};
357        1/1                              DOUBLE  :   mshr_proc_o.data    =   mshr_entry.req_data;
358        0/1     ==>                      default :   mshr_proc_o.data    =   mshr_entry.req_data;
359                                     endcase
360                                 end
                        MISSING_DEFAULT
361                             endcase
362                         end
363                     
364                     // --------------------------------------------------------------------
365                     // cache_mem Interface
366                     // --------------------------------------------------------------------
367                         always_comb begin
368        1/1                  mshr_cache_mem_o.req_cmd        =   REQ_NONE;
369        1/1                  mshr_cache_mem_o.req_addr       =   'b0     ;
370        1/1                  mshr_cache_mem_o.req_data_in    =   'b0     ;
371        1/1                  case (mshr_entry.state)
372                                 ST_IDLE:    begin
373                                     // IF   the processor request is allocated to this entry
374        1/1                          if (dp_sel_i == 1'b1) begin
375        1/1                              case (proc2cache_i.command)
376                                             BUS_LOAD    :   begin
377        1/1                                      mshr_cache_mem_o.req_cmd        =   REQ_LOAD                        ;
378        1/1                                      mshr_cache_mem_o.req_addr       =   proc2cache_i.addr               ;
379        1/1                                      mshr_cache_mem_o.req_data_in    =   cache_mem_ctrl_i.req_data_out   ;
380                                             end
381                                             BUS_STORE   :   begin
382        1/1                                      mshr_cache_mem_o.req_cmd        =   REQ_STORE                       ;
383        1/1                                      mshr_cache_mem_o.req_addr       =   proc2cache_i.addr               ;
384        1/1                                      mshr_cache_mem_o.req_data_in    =   cache_mem_ctrl_i.req_data_out   ;
385        1/1                                      case (proc2cache_i.size)
386        1/1                                          BYTE    :   mshr_cache_mem_o.req_data_in[proc2cache_i.addr[2:0] +:  8]  =   proc2cache_i.data[ 7:0] ;
387        1/1                                          HALF    :   mshr_cache_mem_o.req_data_in[proc2cache_i.addr[2:0] +: 16]  =   proc2cache_i.data[15:0] ;
388        1/1                                          WORD    :   mshr_cache_mem_o.req_data_in[proc2cache_i.addr[2:0] +: 32]  =   proc2cache_i.data[31:0] ;
389        1/1                                          DOUBLE  :   mshr_cache_mem_o.req_data_in                                =   proc2cache_i.data       ;
                   ==>  MISSING_DEFAULT
390                                                 endcase
391                                             end    
                        MISSING_DEFAULT
392                                         endcase
393                                     end
                        MISSING_ELSE
394                                 end
395                                 ST_UPDATE:  begin
396        1/1                          if (mshr_entry.cmd == BUS_LOAD) begin
397        1/1                              mshr_cache_mem_o.req_cmd    =   REQ_LOAD_MISS       ;
398                                     end else begin
399        1/1                              mshr_cache_mem_o.req_cmd    =   REQ_STORE_MISS      ;
400                                     end
401        1/1                          mshr_cache_mem_o.req_addr       =   mshr_entry.req_addr ;
402        1/1                          mshr_cache_mem_o.req_data_in    =   mshr_entry.req_data ;
403                                 end
                        MISSING_DEFAULT
404                             endcase
405                         end
406                     
407                     // --------------------------------------------------------------------
408                     // Memory Interface
409                     // --------------------------------------------------------------------
410                         always_comb begin
411        1/1                  mshr_memory_o.addr      =   {mshr_entry.req_addr[C_XLEN-1:C_CACHE_OFFSET_WIDTH], {C_CACHE_OFFSET_WIDTH{1'b0}}};
412        1/1                  mshr_memory_o.size      =   DOUBLE              ;
413        1/1                  mshr_memory_o.command   =   BUS_NONE            ;
414        1/1                  mshr_memory_o.data      =   'd0 ;
415        1/1                  case (mshr_entry.state)
416                                 ST_RD_MEM   :   begin
417        1/1                          mshr_memory_o.data      =   'd0 ;
418        1/1                          mshr_memory_o.addr      =   {mshr_entry.req_addr[C_XLEN-1:C_CACHE_OFFSET_WIDTH], {C_CACHE_OFFSET_WIDTH{1'b0}}};
419        1/1                          mshr_memory_o.command   =   BUS_LOAD;
420                                 end
421                                 ST_EVICT    :   begin
422        1/1                          mshr_memory_o.data      =   mshr_entry.evict_data;
423        1/1                          mshr_memory_o.addr      =   {mshr_entry.evict_addr[C_XLEN-1:C_CACHE_OFFSET_WIDTH], {C_CACHE_OFFSET_WIDTH{1'b0}}};
424        1/1                          mshr_memory_o.command   =   BUS_STORE;
425                                 end
                        MISSING_DEFAULT

-------------------------------------------------------------------------------
Toggle Coverage for Instance : cache_tb.dut.cache_ctrl_inst.genblk1[14].mshr_entry_ctrl_inst
                Total Covered Percent 
Totals          72    34      47.22   
Total Bits      4844  3665    75.66   
Total Bits 0->1 2422  1832    75.64   
Total Bits 1->0 2422  1833    75.68   

                                
Ports          48   23   47.92  
Port Bits      3878 3007 77.54  
Port Bits 0->1 1939 1503 77.51  
Port Bits 1->0 1939 1504 77.57  

                                
Signals          24  11  45.83  
Signal Bits      966 658 68.12  
Signal Bits 0->1 483 329 68.12  
Signal Bits 1->0 483 329 68.12  

Port Details
                                     Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i                                Yes    Yes         Yes         INPUT     
rst_i                                No     Yes         No          INPUT     
mshr_entry_idx_i[3:0]                No     No          No          INPUT     
mshr_entry_o.mem_tag[2:0]            Yes    Yes         Yes         OUTPUT    
mshr_entry_o.mem_tag[3]              No     No          No          OUTPUT    
mshr_entry_o.linked                  No     No          No          OUTPUT    
mshr_entry_o.link_idx[3:0]           No     No          No          OUTPUT    
mshr_entry_o.evict_dirty             Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_data[0]           No     No          No          OUTPUT    
mshr_entry_o.evict_data[25:1]        Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_data[26]          No     No          No          OUTPUT    
mshr_entry_o.evict_data[31:27]       Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_data[32]          No     No          No          OUTPUT    
mshr_entry_o.evict_data[35:33]       Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_data[36]          No     No          No          OUTPUT    
mshr_entry_o.evict_data[37]          Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_data[38]          No     No          No          OUTPUT    
mshr_entry_o.evict_data[39]          Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_data[40]          No     No          No          OUTPUT    
mshr_entry_o.evict_data[44:41]       Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_data[48:45]       No     No          No          OUTPUT    
mshr_entry_o.evict_data[49]          Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_data[50]          No     No          No          OUTPUT    
mshr_entry_o.evict_data[52:51]       Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_data[53]          No     No          No          OUTPUT    
mshr_entry_o.evict_data[54]          Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_data[57:55]       No     No          No          OUTPUT    
mshr_entry_o.evict_data[59:58]       Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_data[63:60]       No     No          No          OUTPUT    
mshr_entry_o.evict_addr[2:0]         No     No          No          OUTPUT    
mshr_entry_o.evict_addr[15:3]        Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_addr[31:16]       No     No          No          OUTPUT    
mshr_entry_o.req_size[1:0]           Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_data[19:0]          Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_data[20]            No     No          No          OUTPUT    
mshr_entry_o.req_data[21]            Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_data[22]            No     No          No          OUTPUT    
mshr_entry_o.req_data[24:23]         Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_data[26:25]         No     No          No          OUTPUT    
mshr_entry_o.req_data[27]            Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_data[29:28]         No     No          No          OUTPUT    
mshr_entry_o.req_data[32:30]         Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_data[34:33]         No     No          No          OUTPUT    
mshr_entry_o.req_data[37:35]         Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_data[38]            No     No          No          OUTPUT    
mshr_entry_o.req_data[39]            Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_data[40]            No     No          No          OUTPUT    
mshr_entry_o.req_data[41]            Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_data[42]            No     No          No          OUTPUT    
mshr_entry_o.req_data[43]            Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_data[44]            No     No          No          OUTPUT    
mshr_entry_o.req_data[46:45]         Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_data[48:47]         No     No          No          OUTPUT    
mshr_entry_o.req_data[51:49]         Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_data[52]            No     No          No          OUTPUT    
mshr_entry_o.req_data[59:53]         Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_data[60]            No     No          No          OUTPUT    
mshr_entry_o.req_data[62:61]         Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_data[63]            No     No          No          OUTPUT    
mshr_entry_o.req_addr[0]             Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_addr[1]             No     No          No          OUTPUT    
mshr_entry_o.req_addr[15:2]          Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_addr[31:16]         No     No          No          OUTPUT    
mshr_entry_o.cmd[1:0]                Yes    Yes         Yes         OUTPUT    
mshr_entry_o.state[2:0]              Yes    Yes         Yes         OUTPUT    
proc_grant_i                         Yes    Yes         Yes         INPUT     
proc2cache_i.command[1:0]            Yes    Yes         Yes         INPUT     
proc2cache_i.size[1:0]               Yes    Yes         Yes         INPUT     
proc2cache_i.data[63:0]              Yes    Yes         Yes         INPUT     
proc2cache_i.addr[15:0]              Yes    Yes         Yes         INPUT     
proc2cache_i.addr[31:16]             No     No          No          INPUT     
mshr_proc_o.tag[0]                   No     No          No          OUTPUT    
mshr_proc_o.tag[3:1]                 Yes    Yes         Yes         OUTPUT    
mshr_proc_o.data[63:0]               No     No          No          OUTPUT    
mshr_proc_o.response[0]              No     No          No          OUTPUT    
mshr_proc_o.response[3:1]            Yes    Yes         Yes         OUTPUT    
cache_mem_grant_i                    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.evict_data[63:0]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.evict_addr[2:0]     No     No          No          INPUT     
cache_mem_ctrl_i.evict_addr[15:3]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.evict_addr[31:16]   No     No          No          INPUT     
cache_mem_ctrl_i.evict_dirty         Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[4:0]   Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[6:5]   No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[8:7]   Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[11:9]  No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[13:12] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[15:14] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[25:16] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[26]    No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[31:27] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[33:32] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[34]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[37:35] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[38]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[41:39] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[42]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[45:43] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[47:46] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[50:48] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[52:51] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[54:53] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[58:55] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[60:59] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[63:61] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_hit             Yes    Yes         Yes         INPUT     
mshr_cache_mem_o.req_data_in[46:0]   Yes    Yes         Yes         OUTPUT    
mshr_cache_mem_o.req_data_in[48:47]  No     No          No          OUTPUT    
mshr_cache_mem_o.req_data_in[63:49]  Yes    Yes         Yes         OUTPUT    
mshr_cache_mem_o.req_addr[15:0]      Yes    Yes         Yes         OUTPUT    
mshr_cache_mem_o.req_addr[31:16]     No     No          No          OUTPUT    
mshr_cache_mem_o.req_cmd[2:0]        Yes    Yes         Yes         OUTPUT    
memory_grant_i                       Yes    Yes         Yes         INPUT     
mem2cache_i.tag[3:0]                 Yes    Yes         Yes         INPUT     
mem2cache_i.data[63:0]               Yes    Yes         Yes         INPUT     
mem2cache_i.response[3:0]            Yes    Yes         Yes         INPUT     
mshr_memory_o.command[1:0]           Yes    Yes         Yes         OUTPUT    
mshr_memory_o.size[1:0]              No     No          No          OUTPUT    
mshr_memory_o.data[0]                No     No          No          OUTPUT    
mshr_memory_o.data[25:1]             Yes    Yes         Yes         OUTPUT    
mshr_memory_o.data[26]               No     No          No          OUTPUT    
mshr_memory_o.data[31:27]            Yes    Yes         Yes         OUTPUT    
mshr_memory_o.data[32]               No     No          No          OUTPUT    
mshr_memory_o.data[35:33]            Yes    Yes         Yes         OUTPUT    
mshr_memory_o.data[36]               No     No          No          OUTPUT    
mshr_memory_o.data[37]               Yes    Yes         Yes         OUTPUT    
mshr_memory_o.data[38]               No     No          No          OUTPUT    
mshr_memory_o.data[39]               Yes    Yes         Yes         OUTPUT    
mshr_memory_o.data[40]               No     No          No          OUTPUT    
mshr_memory_o.data[44:41]            Yes    Yes         Yes         OUTPUT    
mshr_memory_o.data[48:45]            No     No          No          OUTPUT    
mshr_memory_o.data[49]               Yes    Yes         Yes         OUTPUT    
mshr_memory_o.data[50]               No     No          No          OUTPUT    
mshr_memory_o.data[52:51]            Yes    Yes         Yes         OUTPUT    
mshr_memory_o.data[53]               No     No          No          OUTPUT    
mshr_memory_o.data[54]               Yes    Yes         Yes         OUTPUT    
mshr_memory_o.data[57:55]            No     No          No          OUTPUT    
mshr_memory_o.data[59:58]            Yes    Yes         Yes         OUTPUT    
mshr_memory_o.data[63:60]            No     No          No          OUTPUT    
mshr_memory_o.addr[2:0]              No     No          No          OUTPUT    
mshr_memory_o.addr[15:3]             Yes    Yes         Yes         OUTPUT    
mshr_memory_o.addr[31:16]            No     No          No          OUTPUT    
mshr_hit_i                           Yes    Yes         Yes         INPUT     
mshr_hit_idx_i[3:0]                  Yes    Yes         Yes         INPUT     
evict_hit_i                          No     No          No          INPUT     
evict_hit_idx_i[3:0]                 No     No          No          INPUT     
dp_sel_i                             Yes    Yes         Yes         INPUT     
mshr_cp_flag_o                       Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[0]                    No     No          No          OUTPUT    
mshr_cp_data_o[14:1]                 Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[15]                   No     No          No          OUTPUT    
mshr_cp_data_o[19:16]                Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[20]                   No     No          No          OUTPUT    
mshr_cp_data_o[21]                   Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[22]                   No     No          No          OUTPUT    
mshr_cp_data_o[24:23]                Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[26:25]                No     No          No          OUTPUT    
mshr_cp_data_o[27]                   Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[29:28]                No     No          No          OUTPUT    
mshr_cp_data_o[32:30]                Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[34:33]                No     No          No          OUTPUT    
mshr_cp_data_o[37:35]                Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[38]                   No     No          No          OUTPUT    
mshr_cp_data_o[39]                   Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[40]                   No     No          No          OUTPUT    
mshr_cp_data_o[41]                   Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[42]                   No     No          No          OUTPUT    
mshr_cp_data_o[43]                   Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[44]                   No     No          No          OUTPUT    
mshr_cp_data_o[46:45]                Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[48:47]                No     No          No          OUTPUT    
mshr_cp_data_o[51:49]                Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[52]                   No     No          No          OUTPUT    
mshr_cp_data_o[59:53]                Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[60]                   No     No          No          OUTPUT    
mshr_cp_data_o[62:61]                Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[63]                   No     No          No          OUTPUT    
cp_flag_i[0]                         No     No          No          INPUT     
cp_flag_i[15:1]                      Yes    Yes         Yes         INPUT     
cp_data_i[8:1][63:0]                 Yes    Yes         Yes         INPUT     
cp_data_i[9][44:0]                   Yes    Yes         Yes         INPUT     
cp_data_i[9][63:46]                  Yes    Yes         Yes         INPUT     
cp_data_i[10][30:1]                  Yes    Yes         Yes         INPUT     
cp_data_i[10][36:32]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][41:40]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][45]                    Yes    Yes         Yes         INPUT     
cp_data_i[10][49:47]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][52:51]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][56:55]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][60]                    Yes    Yes         Yes         INPUT     
cp_data_i[10][62]                    Yes    Yes         Yes         INPUT     
cp_data_i[11][27:0]                  Yes    Yes         Yes         INPUT     
cp_data_i[11][36:29]                 Yes    Yes         Yes         INPUT     
cp_data_i[11][49:39]                 Yes    Yes         Yes         INPUT     
cp_data_i[11][51]                    Yes    Yes         Yes         INPUT     
cp_data_i[11][59:54]                 Yes    Yes         Yes         INPUT     
cp_data_i[11][63:62]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][4:0]                   Yes    Yes         Yes         INPUT     
cp_data_i[12][27:6]                  Yes    Yes         Yes         INPUT     
cp_data_i[12][31:29]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][35:33]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][39]                    Yes    Yes         Yes         INPUT     
cp_data_i[12][44:43]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][48:46]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][50]                    Yes    Yes         Yes         INPUT     
cp_data_i[12][54]                    Yes    Yes         Yes         INPUT     
cp_data_i[12][58:57]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][61]                    Yes    Yes         Yes         INPUT     
cp_data_i[13][17:0]                  Yes    Yes         Yes         INPUT     
cp_data_i[13][46:19]                 Yes    Yes         Yes         INPUT     
cp_data_i[13][49]                    Yes    Yes         Yes         INPUT     
cp_data_i[13][56:51]                 Yes    Yes         Yes         INPUT     
cp_data_i[13][63:58]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][14:1]                  Yes    Yes         Yes         INPUT     
cp_data_i[14][19:16]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][21]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][24:23]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][27]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][32:30]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][37:35]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][39]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][41]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][43]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][46:45]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][51:49]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][59:53]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][62:61]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][15:0]                  Yes    Yes         Yes         INPUT     
cp_data_i[15][37:17]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][40:39]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][42]                    Yes    Yes         Yes         INPUT     
cp_data_i[15][45:44]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][48:47]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][53:51]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][55]                    Yes    Yes         Yes         INPUT     
cp_data_i[15][63:57]                 Yes    Yes         Yes         INPUT     
Other bits of cp_data_i[15:0][63:0]  No     No          No          INPUT     

Signal Details
                                  Toggle Toggle 1->0 Toggle 0->1 
mshr_entry.mem_tag[2:0]           Yes    Yes         Yes         
mshr_entry.mem_tag[3]             No     No          No          
mshr_entry.linked                 No     No          No          
mshr_entry.link_idx[3:0]          No     No          No          
mshr_entry.evict_dirty            Yes    Yes         Yes         
mshr_entry.evict_data[0]          No     No          No          
mshr_entry.evict_data[25:1]       Yes    Yes         Yes         
mshr_entry.evict_data[26]         No     No          No          
mshr_entry.evict_data[31:27]      Yes    Yes         Yes         
mshr_entry.evict_data[32]         No     No          No          
mshr_entry.evict_data[35:33]      Yes    Yes         Yes         
mshr_entry.evict_data[36]         No     No          No          
mshr_entry.evict_data[37]         Yes    Yes         Yes         
mshr_entry.evict_data[38]         No     No          No          
mshr_entry.evict_data[39]         Yes    Yes         Yes         
mshr_entry.evict_data[40]         No     No          No          
mshr_entry.evict_data[44:41]      Yes    Yes         Yes         
mshr_entry.evict_data[48:45]      No     No          No          
mshr_entry.evict_data[49]         Yes    Yes         Yes         
mshr_entry.evict_data[50]         No     No          No          
mshr_entry.evict_data[52:51]      Yes    Yes         Yes         
mshr_entry.evict_data[53]         No     No          No          
mshr_entry.evict_data[54]         Yes    Yes         Yes         
mshr_entry.evict_data[57:55]      No     No          No          
mshr_entry.evict_data[59:58]      Yes    Yes         Yes         
mshr_entry.evict_data[63:60]      No     No          No          
mshr_entry.evict_addr[2:0]        No     No          No          
mshr_entry.evict_addr[15:3]       Yes    Yes         Yes         
mshr_entry.evict_addr[31:16]      No     No          No          
mshr_entry.req_size[1:0]          Yes    Yes         Yes         
mshr_entry.req_data[19:0]         Yes    Yes         Yes         
mshr_entry.req_data[20]           No     No          No          
mshr_entry.req_data[21]           Yes    Yes         Yes         
mshr_entry.req_data[22]           No     No          No          
mshr_entry.req_data[24:23]        Yes    Yes         Yes         
mshr_entry.req_data[26:25]        No     No          No          
mshr_entry.req_data[27]           Yes    Yes         Yes         
mshr_entry.req_data[29:28]        No     No          No          
mshr_entry.req_data[32:30]        Yes    Yes         Yes         
mshr_entry.req_data[34:33]        No     No          No          
mshr_entry.req_data[37:35]        Yes    Yes         Yes         
mshr_entry.req_data[38]           No     No          No          
mshr_entry.req_data[39]           Yes    Yes         Yes         
mshr_entry.req_data[40]           No     No          No          
mshr_entry.req_data[41]           Yes    Yes         Yes         
mshr_entry.req_data[42]           No     No          No          
mshr_entry.req_data[43]           Yes    Yes         Yes         
mshr_entry.req_data[44]           No     No          No          
mshr_entry.req_data[46:45]        Yes    Yes         Yes         
mshr_entry.req_data[48:47]        No     No          No          
mshr_entry.req_data[51:49]        Yes    Yes         Yes         
mshr_entry.req_data[52]           No     No          No          
mshr_entry.req_data[59:53]        Yes    Yes         Yes         
mshr_entry.req_data[60]           No     No          No          
mshr_entry.req_data[62:61]        Yes    Yes         Yes         
mshr_entry.req_data[63]           No     No          No          
mshr_entry.req_addr[0]            Yes    Yes         Yes         
mshr_entry.req_addr[1]            No     No          No          
mshr_entry.req_addr[15:2]         Yes    Yes         Yes         
mshr_entry.req_addr[31:16]        No     No          No          
mshr_entry.cmd[1:0]               Yes    Yes         Yes         
mshr_entry.state[2:0]             Yes    Yes         Yes         
next_mshr_entry.mem_tag[3:0]      Yes    Yes         Yes         
next_mshr_entry.linked            Yes    Yes         Yes         
next_mshr_entry.link_idx[0]       Yes    Yes         Yes         
next_mshr_entry.link_idx[1]       No     No          No          
next_mshr_entry.link_idx[3:2]     Yes    Yes         Yes         
next_mshr_entry.evict_dirty       Yes    Yes         Yes         
next_mshr_entry.evict_data[0]     No     No          No          
next_mshr_entry.evict_data[25:1]  Yes    Yes         Yes         
next_mshr_entry.evict_data[26]    No     No          No          
next_mshr_entry.evict_data[31:27] Yes    Yes         Yes         
next_mshr_entry.evict_data[32]    No     No          No          
next_mshr_entry.evict_data[35:33] Yes    Yes         Yes         
next_mshr_entry.evict_data[36]    No     No          No          
next_mshr_entry.evict_data[37]    Yes    Yes         Yes         
next_mshr_entry.evict_data[38]    No     No          No          
next_mshr_entry.evict_data[39]    Yes    Yes         Yes         
next_mshr_entry.evict_data[40]    No     No          No          
next_mshr_entry.evict_data[44:41] Yes    Yes         Yes         
next_mshr_entry.evict_data[48:45] No     No          No          
next_mshr_entry.evict_data[49]    Yes    Yes         Yes         
next_mshr_entry.evict_data[50]    No     No          No          
next_mshr_entry.evict_data[52:51] Yes    Yes         Yes         
next_mshr_entry.evict_data[53]    No     No          No          
next_mshr_entry.evict_data[54]    Yes    Yes         Yes         
next_mshr_entry.evict_data[57:55] No     No          No          
next_mshr_entry.evict_data[59:58] Yes    Yes         Yes         
next_mshr_entry.evict_data[63:60] No     No          No          
next_mshr_entry.evict_addr[2:0]   No     No          No          
next_mshr_entry.evict_addr[15:3]  Yes    Yes         Yes         
next_mshr_entry.evict_addr[31:16] No     No          No          
next_mshr_entry.req_size[1:0]     Yes    Yes         Yes         
next_mshr_entry.req_data[46:0]    Yes    Yes         Yes         
next_mshr_entry.req_data[48:47]   No     No          No          
next_mshr_entry.req_data[63:49]   Yes    Yes         Yes         
next_mshr_entry.req_addr[15:0]    Yes    Yes         Yes         
next_mshr_entry.req_addr[31:16]   No     No          No          
next_mshr_entry.cmd[1:0]          Yes    Yes         Yes         
next_mshr_entry.state[2:0]        Yes    Yes         Yes         
next_mshr_cp_flag                 Yes    Yes         Yes         
next_mshr_cp_data[0]              No     No          No          
next_mshr_cp_data[14:1]           Yes    Yes         Yes         
next_mshr_cp_data[15]             No     No          No          
next_mshr_cp_data[19:16]          Yes    Yes         Yes         
next_mshr_cp_data[20]             No     No          No          
next_mshr_cp_data[21]             Yes    Yes         Yes         
next_mshr_cp_data[22]             No     No          No          
next_mshr_cp_data[24:23]          Yes    Yes         Yes         
next_mshr_cp_data[26:25]          No     No          No          
next_mshr_cp_data[27]             Yes    Yes         Yes         
next_mshr_cp_data[29:28]          No     No          No          
next_mshr_cp_data[32:30]          Yes    Yes         Yes         
next_mshr_cp_data[34:33]          No     No          No          
next_mshr_cp_data[37:35]          Yes    Yes         Yes         
next_mshr_cp_data[38]             No     No          No          
next_mshr_cp_data[39]             Yes    Yes         Yes         
next_mshr_cp_data[40]             No     No          No          
next_mshr_cp_data[41]             Yes    Yes         Yes         
next_mshr_cp_data[42]             No     No          No          
next_mshr_cp_data[43]             Yes    Yes         Yes         
next_mshr_cp_data[44]             No     No          No          
next_mshr_cp_data[46:45]          Yes    Yes         Yes         
next_mshr_cp_data[48:47]          No     No          No          
next_mshr_cp_data[51:49]          Yes    Yes         Yes         
next_mshr_cp_data[52]             No     No          No          
next_mshr_cp_data[59:53]          Yes    Yes         Yes         
next_mshr_cp_data[60]             No     No          No          
next_mshr_cp_data[62:61]          Yes    Yes         Yes         
next_mshr_cp_data[63]             No     No          No          


-------------------------------------------------------------------------------
===============================================================================
Module Instance : cache_tb.dut.cache_ctrl_inst.genblk1[13].mshr_entry_ctrl_inst
===============================================================================

Instance :

SCORE  LINE   TOGGLE 
 74.83  72.38  77.27 


Instance's subtree :

SCORE  LINE   TOGGLE 
 74.83  72.38  77.27 


Module : 

SCORE  LINE   TOGGLE NAME            
 87.59  90.48  84.70 mshr_entry_ctrl 


Parent : 

SCORE  LINE   TOGGLE NAME            
 92.38 100.00  84.76 cache_ctrl_inst 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : cache_tb.dut.cache_ctrl_inst.genblk1[13].mshr_entry_ctrl_inst

             Line No.   Total   Covered  Percent
TOTAL                      210      152    72.38
ALWAYS             75       17       17   100.00
ALWAYS             97      135       87    64.44
ALWAYS            317       25       16    64.00
ALWAYS            368       22       21    95.45
ALWAYS            411       11       11   100.00

74                          always_ff @(posedge clk_i) begin
75         1/1                  if (rst_i) begin
76         1/1                      mshr_entry.state        <=  `SD ST_IDLE     ;
77         1/1                      mshr_entry.cmd          <=  `SD BUS_NONE    ;
78         1/1                      mshr_entry.req_addr     <=  `SD 'b0         ;
79         1/1                      mshr_entry.req_data     <=  `SD 'b0         ;
80         1/1                      mshr_entry.req_size     <=  `SD BYTE        ;
81         1/1                      mshr_entry.evict_addr   <=  `SD 'b0         ;
82         1/1                      mshr_entry.evict_data   <=  `SD 'b0         ;
83         1/1                      mshr_entry.evict_dirty  <=  `SD 1'b0        ;
84         1/1                      mshr_entry.link_idx     <=  `SD 'd0         ;
85         1/1                      mshr_entry.linked       <=  `SD 1'b0        ;
86         1/1                      mshr_entry.mem_tag      <=  `SD 'd0         ;
87         1/1                      mshr_cp_flag_o          <=  `SD 1'b0        ;
88         1/1                      mshr_cp_data_o          <=  `SD 'b0         ;
89                              end else begin
90         1/1                      mshr_entry              <=  `SD next_mshr_entry     ;
91         1/1                      mshr_cp_flag_o          <=  `SD next_mshr_cp_flag   ;
92         1/1                      mshr_cp_data_o          <=  `SD next_mshr_cp_data   ;
93                              end
94                          end
95                      
96                          always_comb begin
97         1/1                  next_mshr_entry.state       =   mshr_entry.state        ;
98         1/1                  next_mshr_entry.cmd         =   mshr_entry.cmd          ;
99         1/1                  next_mshr_entry.req_addr    =   mshr_entry.req_addr     ;
100        1/1                  next_mshr_entry.req_data    =   mshr_entry.req_data     ;
101        1/1                  next_mshr_entry.req_size    =   mshr_entry.req_size     ;
102        1/1                  next_mshr_entry.evict_addr  =   mshr_entry.evict_addr   ;
103        1/1                  next_mshr_entry.evict_data  =   mshr_entry.evict_data   ;
104        1/1                  next_mshr_entry.evict_dirty =   mshr_entry.evict_dirty  ;
105        1/1                  next_mshr_entry.link_idx    =   mshr_entry.link_idx     ;
106        1/1                  next_mshr_entry.linked      =   mshr_entry.linked       ;
107        1/1                  next_mshr_entry.mem_tag     =   mshr_entry.mem_tag      ;
108        1/1                  next_mshr_cp_flag           =   mshr_cp_flag_o          ;
109        1/1                  next_mshr_cp_data           =   mshr_cp_data_o          ;
110        1/1                  case (mshr_entry.state)
111                                 ST_IDLE     :   begin
112                                     // IF   there is a valid transaction on Processor Interface
113                                     // AND  the Processor Interface is granted to this entry
114                                     // AND  the cache_mem Interface is granted to this entry
115                                     // AND  it is a miss
116                                     // AND  the entry is selected to hold the new miss
117        1/1                          if ((proc2cache_i.command != BUS_NONE) && (dp_sel_i == 1'b1)
118                                     && (proc_grant_i == 1'b1)) begin
119                                         // IF   there is an older in-flight transaction to the same addreess
120                                         // ->   Wait for the completion of older miss to the same address
121        1/1                              if (mshr_hit_i && (cp_flag_i[mshr_hit_idx_i] == 1'b0)) begin
122        1/1                                  next_mshr_entry.state       =   ST_WAIT_DEPEND          ;
123        1/1                                  next_mshr_entry.link_idx    =   mshr_hit_idx_i          ;
124        1/1                                  next_mshr_entry.cmd         =   proc2cache_i.command    ;
125        1/1                                  next_mshr_entry.req_addr    =   proc2cache_i.addr       ;
126        1/1                                  next_mshr_entry.req_size    =   proc2cache_i.size       ;
127        1/1                                  if (proc2cache_i.command == BUS_STORE) begin
128        1/1                                      next_mshr_entry.req_data    =   proc2cache_i.data   ;
129                                             end
                        MISSING_ELSE
130                                         // IF   there is an older in-flight transaction that is in the middle of evicting the data block
131                                         // ->   Wait for the completion of write-back to memory
132        1/1                              end else if (evict_hit_i && (cp_flag_i[evict_hit_idx_i] == 1'b0)) begin
133        0/1     ==>                          next_mshr_entry.state       =   ST_WAIT_EVICT           ;
134        0/1     ==>                          next_mshr_entry.link_idx    =   evict_hit_idx_i         ;
135        0/1     ==>                          next_mshr_entry.cmd         =   proc2cache_i.command    ;
136        0/1     ==>                          next_mshr_entry.req_addr    =   proc2cache_i.addr       ;
137        0/1     ==>                          next_mshr_entry.req_size    =   proc2cache_i.size       ;
138        0/1     ==>                          if (proc2cache_i.command == BUS_STORE) begin
139        0/1     ==>                              next_mshr_entry.req_data    =   proc2cache_i.data   ;
140                                             end
                   ==>  MISSING_ELSE
141                                         // IF   it is a miss, and no dependency to older in-flight transactions.
142                                         // ->   Start miss handling
143        1/1                              end else if ((cache_mem_ctrl_i.req_hit == 1'b0) && (cache_mem_grant_i == 1'b1)) begin
144        1/1                                  next_mshr_entry.state       =   ST_RD_MEM               ;
145        1/1                                  next_mshr_entry.link_idx    =   'd0                     ;
146        1/1                                  next_mshr_entry.cmd         =   proc2cache_i.command    ;
147        1/1                                  next_mshr_entry.req_addr    =   proc2cache_i.addr       ;
148        1/1                                  next_mshr_entry.req_size    =   proc2cache_i.size       ;
149        1/1                                  if (proc2cache_i.command == BUS_STORE) begin
150        1/1                                      next_mshr_entry.req_data    =   proc2cache_i.data   ;
151                                             end
                        MISSING_ELSE
152                                         end
                   ==>  MISSING_ELSE
153                                     end
                        MISSING_ELSE
154        1/1                          next_mshr_cp_flag   =   1'b0    ;
155        1/1                          next_mshr_cp_data   =   'b0     ;
156                                 end
157                                 ST_WAIT_DEPEND  :   begin
158                                     // IF   the older transaction that the entry is linked to completed
159                                     // ->   Update the cache data
160        0/1     ==>                  if (cp_flag_i[mshr_entry.link_idx] == 1'b1) begin
161        0/1     ==>                      next_mshr_entry.state       =   ST_UPDATE   ;
162        0/1     ==>                      next_mshr_entry.link_idx    =   'd0         ;
163        0/1     ==>                      next_mshr_entry.req_data    =   cp_data_i[mshr_entry.link_idx];
164        0/1     ==>                      if (mshr_entry.cmd == BUS_STORE) begin
165        0/1     ==>                          case (mshr_entry.req_size)
166        0/1     ==>                              BYTE    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +:  8]    =   mshr_entry.req_data[ 7:0]   ;
167        0/1     ==>                              HALF    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +: 16]    =   mshr_entry.req_data[15:0]   ;
168        0/1     ==>                              WORD    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +: 32]    =   mshr_entry.req_data[31:0]   ;
169        0/1     ==>                              DOUBLE  :   next_mshr_entry.req_data                                    =   mshr_entry.req_data         ;
170        0/1     ==>                              default :   next_mshr_entry.req_data                                    =   mshr_entry.req_data         ;
171                                             endcase
172                                         end
                   ==>  MISSING_ELSE
173                                     end
                   ==>  MISSING_ELSE
174                                 end
175                                 ST_WAIT_EVICT   : begin
176                                     // IF   the older transaction that evicts the cache block completed
177                                     // ->   Read from Memory
178        0/1     ==>                  if (cp_flag_i[mshr_entry.link_idx] == 1'b1) begin
179        0/1     ==>                      next_mshr_entry.state       =   ST_RD_MEM   ;
180        0/1     ==>                      next_mshr_entry.link_idx    =   'd0         ;
181                                     end
                   ==>  MISSING_ELSE
182                                 end
183                                 ST_RD_MEM   :   begin
184                                     // IF   the read transaction is confirmed by Memory Interface
185                                     // ->   Wait for the data to return from Memory
186        1/1                          if ((memory_grant_i == 1'b1) && (mem2cache_i.response != 'd0)) begin
187        1/1                              next_mshr_entry.state       =   ST_WAIT_MEM             ;
188        1/1                              next_mshr_entry.mem_tag     =   mem2cache_i.response    ;
189                                     end
                        MISSING_ELSE
190                                 end
191                                 ST_WAIT_MEM :   begin
192                                     // IF   the data is returned from the Memory
193                                     // ->   Update the cache data
194        1/1                          if (mem2cache_i.tag == mshr_entry.mem_tag) begin
195        1/1                              next_mshr_entry.state       =   ST_UPDATE           ;
196        1/1                              next_mshr_entry.req_data    =   mem2cache_i.data    ;
197        1/1                              if (mshr_entry.cmd == BUS_STORE) begin
198        1/1                                  case (mshr_entry.req_size)
199        1/1                                      BYTE    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +:  8]    =   mshr_entry.req_data[ 7:0]   ;
200        0/1     ==>                              HALF    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +: 16]    =   mshr_entry.req_data[15:0]   ;
201        0/1     ==>                              WORD    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +: 32]    =   mshr_entry.req_data[31:0]   ;
202        1/1                                      DOUBLE  :   next_mshr_entry.req_data                                    =   mshr_entry.req_data         ;
203        0/1     ==>                              default :   next_mshr_entry.req_data                                    =   mshr_entry.req_data         ;
204                                             endcase
205                                         end
                        MISSING_ELSE
206                                     end
                        MISSING_ELSE
207                                 end
208                                 ST_UPDATE   :   begin
209                                     // IF   the req interface is granted to this entry
210        1/1                          if (cache_mem_grant_i == 1'b1) begin
211                                         // IF   it is a load miss
212                                         // ->   Output data to processor
213        1/1                              if (mshr_entry.cmd == BUS_LOAD) begin
214        1/1                                  next_mshr_entry.state       =   ST_OUTPUT;
215        1/1                                  next_mshr_entry.evict_addr  =   cache_mem_ctrl_i.evict_addr ;
216        1/1                                  next_mshr_entry.evict_data  =   cache_mem_ctrl_i.evict_data ;
217        1/1                                  next_mshr_entry.evict_dirty =   cache_mem_ctrl_i.evict_dirty;
218                                         // IF   a dirty block is evicted
219                                         // ->   Write back the evicted block
220        1/1                              end else if (cache_mem_ctrl_i.evict_dirty == 1'b1) begin
221        1/1                                  next_mshr_entry.state       =   ST_EVICT;
222        1/1                                  next_mshr_entry.evict_addr  =   cache_mem_ctrl_i.evict_addr ;
223        1/1                                  next_mshr_entry.evict_data  =   cache_mem_ctrl_i.evict_data ;
224        1/1                                  next_mshr_entry.evict_dirty =   cache_mem_ctrl_i.evict_dirty;
225                                         // ELSE
226                                         // ->   Miss Handling Completed
227                                         end else begin
228        0/1     ==>                          next_mshr_entry.state       =   ST_IDLE             ;
229        0/1     ==>                          next_mshr_entry.cmd         =   BUS_NONE            ;
230        0/1     ==>                          next_mshr_entry.req_addr    =   'b0                 ;
231        0/1     ==>                          next_mshr_entry.req_data    =   'b0                 ;
232        0/1     ==>                          next_mshr_entry.req_size    =   BYTE                ;
233        0/1     ==>                          next_mshr_entry.evict_addr  =   'b0                 ;
234        0/1     ==>                          next_mshr_entry.evict_data  =   'b0                 ;
235        0/1     ==>                          next_mshr_entry.evict_dirty =   1'b0                ;
236        0/1     ==>                          next_mshr_entry.link_idx    =   'd0                 ;
237        0/1     ==>                          next_mshr_entry.mem_tag     =   'd0                 ;
238        0/1     ==>                          next_mshr_cp_flag           =   1'b1                ;
239        0/1     ==>                          next_mshr_cp_data           =   mshr_entry.req_data ;
240                                         end
241                                     end
                        MISSING_ELSE
242                                 end
243                                 ST_OUTPUT   :   begin
244                                     // IF   the Processor Interface is granted to this entry
245        1/1                          if (proc_grant_i == 1'b1) begin
246                                         // IF   the evicted block is dirty
247                                         // ->   Write back the evicted block
248        1/1                              if (mshr_entry.evict_dirty == 1'b1) begin
249        1/1                                  next_mshr_entry.state       =   ST_EVICT;
250                                         // ELSE
251                                         // ->   Miss Handling Completed
252                                         end else begin
253        0/1     ==>                          next_mshr_entry.state       =   ST_IDLE             ;
254        0/1     ==>                          next_mshr_entry.cmd         =   BUS_NONE            ;
255        0/1     ==>                          next_mshr_entry.req_addr    =   'b0                 ;
256        0/1     ==>                          next_mshr_entry.req_data    =   'b0                 ;
257        0/1     ==>                          next_mshr_entry.req_size    =   BYTE                ;
258        0/1     ==>                          next_mshr_entry.evict_addr  =   'b0                 ;
259        0/1     ==>                          next_mshr_entry.evict_data  =   'b0                 ;
260        0/1     ==>                          next_mshr_entry.evict_dirty =   1'b0                ;
261        0/1     ==>                          next_mshr_entry.link_idx    =   'd0                 ;
262        0/1     ==>                          next_mshr_entry.mem_tag     =   'd0                 ;
263        0/1     ==>                          next_mshr_cp_flag           =   1'b1                ;
264        0/1     ==>                          next_mshr_cp_data           =   mshr_entry.req_data ;
265                                         end
266                                     end
                        MISSING_ELSE
267                                 end
268                                 ST_EVICT    :   begin
269                                     // IF   the write back transaction to Memory is confirmed
270                                     // ->   Miss Handling Completed
271        1/1                          if ((memory_grant_i == 1'b1) && (mem2cache_i.response != 'd0)) begin
272        1/1                              next_mshr_entry.state       =   ST_IDLE             ;
273        1/1                              next_mshr_entry.cmd         =   BUS_NONE            ;
274        1/1                              next_mshr_entry.req_addr    =   'b0                 ;
275        1/1                              next_mshr_entry.req_data    =   'b0                 ;
276        1/1                              next_mshr_entry.req_size    =   BYTE                ;
277        1/1                              next_mshr_entry.evict_addr  =   'b0                 ;
278        1/1                              next_mshr_entry.evict_data  =   'b0                 ;
279        1/1                              next_mshr_entry.evict_dirty =   1'b0                ;
280        1/1                              next_mshr_entry.link_idx    =   'd0                 ;
281        1/1                              next_mshr_entry.mem_tag     =   'd0                 ;
282        1/1                              next_mshr_cp_flag           =   1'b1                ;
283        1/1                              next_mshr_cp_data           =   mshr_entry.req_data ;
284                                     end
                        MISSING_ELSE
285                                 end
286                                 default     :   begin
287        1/1                          next_mshr_entry.state       =   ST_IDLE     ;
288        1/1                          next_mshr_entry.cmd         =   BUS_NONE    ;
289        1/1                          next_mshr_entry.req_addr    =   'b0         ;
290        1/1                          next_mshr_entry.req_data    =   'b0         ;
291        1/1                          next_mshr_entry.req_size    =   BYTE        ;
292        1/1                          next_mshr_entry.evict_addr  =   'b0         ;
293        1/1                          next_mshr_entry.evict_data  =   'b0         ;
294        1/1                          next_mshr_entry.evict_dirty =   1'b0        ;
295        1/1                          next_mshr_entry.link_idx    =   'd0         ;
296        1/1                          next_mshr_entry.mem_tag     =   'd0         ;
297        1/1                          next_mshr_cp_flag           =   1'b0        ;
298        1/1                          next_mshr_cp_data           =   'd0         ;
299                                 end
300                             endcase
301                     
302        1/1                  if (next_mshr_entry.state == ST_IDLE) begin
303        1/1                      next_mshr_entry.linked  =   1'b0;
304        1/1                  end else if ((mshr_hit_i == 1'b1) && (mshr_hit_idx_i == mshr_entry_idx_i)) begin
305        1/1                      next_mshr_entry.linked  =   1'b1;
306                             end
                        MISSING_ELSE
307                         end
308                     
309                     // --------------------------------------------------------------------
310                     // MSHR entry output
311                     // --------------------------------------------------------------------
312                         assign  mshr_entry_o    =   mshr_entry  ;
313                     // --------------------------------------------------------------------
314                     // Processor Interface
315                     // --------------------------------------------------------------------
316                         always_comb begin
317        1/1                  mshr_proc_o.response    =   'd0 ;
318        1/1                  mshr_proc_o.data        =   'b0 ;
319        1/1                  mshr_proc_o.tag         =   'd0 ;
320        1/1                  case (mshr_entry.state)
321                                 ST_IDLE     :   begin
322                                     // IF   the processor request is allocated to this entry
323        1/1                          if ((proc2cache_i.command != BUS_NONE) && (dp_sel_i == 1'b1)) begin
324                                         // IF   The Processor Interface is granted to this entry
325                                         // AND  there is a dependency to older in-flight transaction
326                                         // ->   Confirm the request
327        1/1                              if (((mshr_hit_i && (cp_flag_i[mshr_hit_idx_i] == 1'b0))
328                                         || (evict_hit_i && (cp_flag_i[evict_hit_idx_i] == 1'b0)))) begin
329        1/1                                  mshr_proc_o.response    =   mshr_entry_idx_i;
330                                         // IF   The Processor Interface is granted to this entry
331                                         // AND  The cache_mem Interface is granted to this entry
332                                         // ->   Confirm the request 
333        1/1                              end else if (cache_mem_grant_i == 1'b1) begin
334        1/1                                  mshr_proc_o.response    =   mshr_entry_idx_i;
335                                             // IF   it is a load hit
336                                             // ->   Output data and tag
337        1/1                                  if (cache_mem_ctrl_i.req_hit == 1'b1 && proc2cache_i.command == BUS_LOAD) begin
338        0/1     ==>                              mshr_proc_o.tag     =   mshr_entry_idx_i;
339        0/1     ==>                              case (proc2cache_i.size)
340        0/1     ==>                                  BYTE    :   mshr_proc_o.data    =   {56'b0,cache_mem_ctrl_i.req_data_out[proc2cache_i.addr[2:0]+: 8]};
341        0/1     ==>                                  HALF    :   mshr_proc_o.data    =   {48'b0,cache_mem_ctrl_i.req_data_out[proc2cache_i.addr[2:0]+:16]};
342        0/1     ==>                                  WORD    :   mshr_proc_o.data    =   {32'b0,cache_mem_ctrl_i.req_data_out[proc2cache_i.addr[2:0]+:32]};
343        0/1     ==>                                  DOUBLE  :   mshr_proc_o.data    =   cache_mem_ctrl_i.req_data_out;
344        0/1     ==>                                  default :   mshr_proc_o.data    =   cache_mem_ctrl_i.req_data_out;
345                                                 endcase
346                                             end
                        MISSING_ELSE
347                                         end
                        MISSING_ELSE
348                                     end
                        MISSING_ELSE
349                                 end
350                                 ST_OUTPUT   :   begin
351        1/1                          mshr_proc_o.response    =   'd0                 ;
352        1/1                          mshr_proc_o.tag         =   mshr_entry_idx_i    ;
353        1/1                          case (mshr_entry.req_size)
354        1/1                              BYTE    :   mshr_proc_o.data    =   {56'b0,mshr_entry.req_data[mshr_entry.req_addr[2:0]+: 8]};
355        0/1     ==>                      HALF    :   mshr_proc_o.data    =   {48'b0,mshr_entry.req_data[mshr_entry.req_addr[2:0]+:16]};
356        1/1                              WORD    :   mshr_proc_o.data    =   {32'b0,mshr_entry.req_data[mshr_entry.req_addr[2:0]+:32]};
357        1/1                              DOUBLE  :   mshr_proc_o.data    =   mshr_entry.req_data;
358        0/1     ==>                      default :   mshr_proc_o.data    =   mshr_entry.req_data;
359                                     endcase
360                                 end
                        MISSING_DEFAULT
361                             endcase
362                         end
363                     
364                     // --------------------------------------------------------------------
365                     // cache_mem Interface
366                     // --------------------------------------------------------------------
367                         always_comb begin
368        1/1                  mshr_cache_mem_o.req_cmd        =   REQ_NONE;
369        1/1                  mshr_cache_mem_o.req_addr       =   'b0     ;
370        1/1                  mshr_cache_mem_o.req_data_in    =   'b0     ;
371        1/1                  case (mshr_entry.state)
372                                 ST_IDLE:    begin
373                                     // IF   the processor request is allocated to this entry
374        1/1                          if (dp_sel_i == 1'b1) begin
375        1/1                              case (proc2cache_i.command)
376                                             BUS_LOAD    :   begin
377        1/1                                      mshr_cache_mem_o.req_cmd        =   REQ_LOAD                        ;
378        1/1                                      mshr_cache_mem_o.req_addr       =   proc2cache_i.addr               ;
379        1/1                                      mshr_cache_mem_o.req_data_in    =   cache_mem_ctrl_i.req_data_out   ;
380                                             end
381                                             BUS_STORE   :   begin
382        1/1                                      mshr_cache_mem_o.req_cmd        =   REQ_STORE                       ;
383        1/1                                      mshr_cache_mem_o.req_addr       =   proc2cache_i.addr               ;
384        1/1                                      mshr_cache_mem_o.req_data_in    =   cache_mem_ctrl_i.req_data_out   ;
385        1/1                                      case (proc2cache_i.size)
386        1/1                                          BYTE    :   mshr_cache_mem_o.req_data_in[proc2cache_i.addr[2:0] +:  8]  =   proc2cache_i.data[ 7:0] ;
387        0/1     ==>                                  HALF    :   mshr_cache_mem_o.req_data_in[proc2cache_i.addr[2:0] +: 16]  =   proc2cache_i.data[15:0] ;
388        1/1                                          WORD    :   mshr_cache_mem_o.req_data_in[proc2cache_i.addr[2:0] +: 32]  =   proc2cache_i.data[31:0] ;
389        1/1                                          DOUBLE  :   mshr_cache_mem_o.req_data_in                                =   proc2cache_i.data       ;
                   ==>  MISSING_DEFAULT
390                                                 endcase
391                                             end    
                        MISSING_DEFAULT
392                                         endcase
393                                     end
                        MISSING_ELSE
394                                 end
395                                 ST_UPDATE:  begin
396        1/1                          if (mshr_entry.cmd == BUS_LOAD) begin
397        1/1                              mshr_cache_mem_o.req_cmd    =   REQ_LOAD_MISS       ;
398                                     end else begin
399        1/1                              mshr_cache_mem_o.req_cmd    =   REQ_STORE_MISS      ;
400                                     end
401        1/1                          mshr_cache_mem_o.req_addr       =   mshr_entry.req_addr ;
402        1/1                          mshr_cache_mem_o.req_data_in    =   mshr_entry.req_data ;
403                                 end
                        MISSING_DEFAULT
404                             endcase
405                         end
406                     
407                     // --------------------------------------------------------------------
408                     // Memory Interface
409                     // --------------------------------------------------------------------
410                         always_comb begin
411        1/1                  mshr_memory_o.addr      =   {mshr_entry.req_addr[C_XLEN-1:C_CACHE_OFFSET_WIDTH], {C_CACHE_OFFSET_WIDTH{1'b0}}};
412        1/1                  mshr_memory_o.size      =   DOUBLE              ;
413        1/1                  mshr_memory_o.command   =   BUS_NONE            ;
414        1/1                  mshr_memory_o.data      =   'd0 ;
415        1/1                  case (mshr_entry.state)
416                                 ST_RD_MEM   :   begin
417        1/1                          mshr_memory_o.data      =   'd0 ;
418        1/1                          mshr_memory_o.addr      =   {mshr_entry.req_addr[C_XLEN-1:C_CACHE_OFFSET_WIDTH], {C_CACHE_OFFSET_WIDTH{1'b0}}};
419        1/1                          mshr_memory_o.command   =   BUS_LOAD;
420                                 end
421                                 ST_EVICT    :   begin
422        1/1                          mshr_memory_o.data      =   mshr_entry.evict_data;
423        1/1                          mshr_memory_o.addr      =   {mshr_entry.evict_addr[C_XLEN-1:C_CACHE_OFFSET_WIDTH], {C_CACHE_OFFSET_WIDTH{1'b0}}};
424        1/1                          mshr_memory_o.command   =   BUS_STORE;
425                                 end
                        MISSING_DEFAULT

-------------------------------------------------------------------------------
Toggle Coverage for Instance : cache_tb.dut.cache_ctrl_inst.genblk1[13].mshr_entry_ctrl_inst
                Total Covered Percent 
Totals          72    38      52.78   
Total Bits      4844  3743    77.27   
Total Bits 0->1 2422  1871    77.25   
Total Bits 1->0 2422  1872    77.29   

                                
Ports          48   25   52.08  
Port Bits      3878 3047 78.57  
Port Bits 0->1 1939 1523 78.55  
Port Bits 1->0 1939 1524 78.60  

                                
Signals          24  13  54.17  
Signal Bits      966 696 72.05  
Signal Bits 0->1 483 348 72.05  
Signal Bits 1->0 483 348 72.05  

Port Details
                                     Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i                                Yes    Yes         Yes         INPUT     
rst_i                                No     Yes         No          INPUT     
mshr_entry_idx_i[3:0]                No     No          No          INPUT     
mshr_entry_o.mem_tag[3:0]            Yes    Yes         Yes         OUTPUT    
mshr_entry_o.linked                  No     No          No          OUTPUT    
mshr_entry_o.link_idx[3:0]           No     No          No          OUTPUT    
mshr_entry_o.evict_dirty             Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_data[0]           Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_data[1]           No     No          No          OUTPUT    
mshr_entry_o.evict_data[10:2]        Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_data[11]          No     No          No          OUTPUT    
mshr_entry_o.evict_data[15:12]       Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_data[18:16]       No     No          No          OUTPUT    
mshr_entry_o.evict_data[22:19]       Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_data[24:23]       No     No          No          OUTPUT    
mshr_entry_o.evict_data[27:25]       Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_data[28]          No     No          No          OUTPUT    
mshr_entry_o.evict_data[29]          Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_data[30]          No     No          No          OUTPUT    
mshr_entry_o.evict_data[33:31]       Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_data[35:34]       No     No          No          OUTPUT    
mshr_entry_o.evict_data[36]          Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_data[37]          No     No          No          OUTPUT    
mshr_entry_o.evict_data[42:38]       Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_data[43]          No     No          No          OUTPUT    
mshr_entry_o.evict_data[44]          Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_data[45]          No     No          No          OUTPUT    
mshr_entry_o.evict_data[46]          Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_data[47]          No     No          No          OUTPUT    
mshr_entry_o.evict_data[52:48]       Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_data[55:53]       No     No          No          OUTPUT    
mshr_entry_o.evict_data[56]          Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_data[57]          No     No          No          OUTPUT    
mshr_entry_o.evict_data[59:58]       Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_data[63:60]       No     No          No          OUTPUT    
mshr_entry_o.evict_addr[2:0]         No     No          No          OUTPUT    
mshr_entry_o.evict_addr[15:3]        Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_addr[31:16]       No     No          No          OUTPUT    
mshr_entry_o.req_size[1:0]           Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_data[17:0]          Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_data[18]            No     No          No          OUTPUT    
mshr_entry_o.req_data[46:19]         Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_data[48:47]         No     No          No          OUTPUT    
mshr_entry_o.req_data[49]            Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_data[50]            No     No          No          OUTPUT    
mshr_entry_o.req_data[56:51]         Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_data[57]            No     No          No          OUTPUT    
mshr_entry_o.req_data[63:58]         Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_addr[0]             No     No          No          OUTPUT    
mshr_entry_o.req_addr[1]             Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_addr[2]             No     No          No          OUTPUT    
mshr_entry_o.req_addr[15:3]          Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_addr[31:16]         No     No          No          OUTPUT    
mshr_entry_o.cmd[1:0]                Yes    Yes         Yes         OUTPUT    
mshr_entry_o.state[2:0]              Yes    Yes         Yes         OUTPUT    
proc_grant_i                         Yes    Yes         Yes         INPUT     
proc2cache_i.command[1:0]            Yes    Yes         Yes         INPUT     
proc2cache_i.size[1:0]               Yes    Yes         Yes         INPUT     
proc2cache_i.data[63:0]              Yes    Yes         Yes         INPUT     
proc2cache_i.addr[15:0]              Yes    Yes         Yes         INPUT     
proc2cache_i.addr[31:16]             No     No          No          INPUT     
mshr_proc_o.tag[0]                   Yes    Yes         Yes         OUTPUT    
mshr_proc_o.tag[1]                   No     No          No          OUTPUT    
mshr_proc_o.tag[3:2]                 Yes    Yes         Yes         OUTPUT    
mshr_proc_o.data[63:0]               No     No          No          OUTPUT    
mshr_proc_o.response[0]              Yes    Yes         Yes         OUTPUT    
mshr_proc_o.response[1]              No     No          No          OUTPUT    
mshr_proc_o.response[3:2]            Yes    Yes         Yes         OUTPUT    
cache_mem_grant_i                    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.evict_data[63:0]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.evict_addr[2:0]     No     No          No          INPUT     
cache_mem_ctrl_i.evict_addr[15:3]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.evict_addr[31:16]   No     No          No          INPUT     
cache_mem_ctrl_i.evict_dirty         Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[4:0]   Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[6:5]   No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[8:7]   Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[11:9]  No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[13:12] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[15:14] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[25:16] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[26]    No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[31:27] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[33:32] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[34]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[37:35] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[38]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[41:39] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[42]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[45:43] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[47:46] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[50:48] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[52:51] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[54:53] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[58:55] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[60:59] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[63:61] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_hit             Yes    Yes         Yes         INPUT     
mshr_cache_mem_o.req_data_in[63:0]   Yes    Yes         Yes         OUTPUT    
mshr_cache_mem_o.req_addr[15:0]      Yes    Yes         Yes         OUTPUT    
mshr_cache_mem_o.req_addr[31:16]     No     No          No          OUTPUT    
mshr_cache_mem_o.req_cmd[2:0]        Yes    Yes         Yes         OUTPUT    
memory_grant_i                       Yes    Yes         Yes         INPUT     
mem2cache_i.tag[3:0]                 Yes    Yes         Yes         INPUT     
mem2cache_i.data[63:0]               Yes    Yes         Yes         INPUT     
mem2cache_i.response[3:0]            Yes    Yes         Yes         INPUT     
mshr_memory_o.command[1:0]           Yes    Yes         Yes         OUTPUT    
mshr_memory_o.size[1:0]              No     No          No          OUTPUT    
mshr_memory_o.data[0]                Yes    Yes         Yes         OUTPUT    
mshr_memory_o.data[1]                No     No          No          OUTPUT    
mshr_memory_o.data[10:2]             Yes    Yes         Yes         OUTPUT    
mshr_memory_o.data[11]               No     No          No          OUTPUT    
mshr_memory_o.data[15:12]            Yes    Yes         Yes         OUTPUT    
mshr_memory_o.data[18:16]            No     No          No          OUTPUT    
mshr_memory_o.data[22:19]            Yes    Yes         Yes         OUTPUT    
mshr_memory_o.data[24:23]            No     No          No          OUTPUT    
mshr_memory_o.data[27:25]            Yes    Yes         Yes         OUTPUT    
mshr_memory_o.data[28]               No     No          No          OUTPUT    
mshr_memory_o.data[29]               Yes    Yes         Yes         OUTPUT    
mshr_memory_o.data[30]               No     No          No          OUTPUT    
mshr_memory_o.data[33:31]            Yes    Yes         Yes         OUTPUT    
mshr_memory_o.data[35:34]            No     No          No          OUTPUT    
mshr_memory_o.data[36]               Yes    Yes         Yes         OUTPUT    
mshr_memory_o.data[37]               No     No          No          OUTPUT    
mshr_memory_o.data[42:38]            Yes    Yes         Yes         OUTPUT    
mshr_memory_o.data[43]               No     No          No          OUTPUT    
mshr_memory_o.data[44]               Yes    Yes         Yes         OUTPUT    
mshr_memory_o.data[45]               No     No          No          OUTPUT    
mshr_memory_o.data[46]               Yes    Yes         Yes         OUTPUT    
mshr_memory_o.data[47]               No     No          No          OUTPUT    
mshr_memory_o.data[52:48]            Yes    Yes         Yes         OUTPUT    
mshr_memory_o.data[55:53]            No     No          No          OUTPUT    
mshr_memory_o.data[56]               Yes    Yes         Yes         OUTPUT    
mshr_memory_o.data[57]               No     No          No          OUTPUT    
mshr_memory_o.data[59:58]            Yes    Yes         Yes         OUTPUT    
mshr_memory_o.data[63:60]            No     No          No          OUTPUT    
mshr_memory_o.addr[2:0]              No     No          No          OUTPUT    
mshr_memory_o.addr[15:3]             Yes    Yes         Yes         OUTPUT    
mshr_memory_o.addr[31:16]            No     No          No          OUTPUT    
mshr_hit_i                           Yes    Yes         Yes         INPUT     
mshr_hit_idx_i[3:0]                  Yes    Yes         Yes         INPUT     
evict_hit_i                          No     No          No          INPUT     
evict_hit_idx_i[3:0]                 No     No          No          INPUT     
dp_sel_i                             Yes    Yes         Yes         INPUT     
mshr_cp_flag_o                       Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[17:0]                 Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[18]                   No     No          No          OUTPUT    
mshr_cp_data_o[46:19]                Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[48:47]                No     No          No          OUTPUT    
mshr_cp_data_o[49]                   Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[50]                   No     No          No          OUTPUT    
mshr_cp_data_o[56:51]                Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[57]                   No     No          No          OUTPUT    
mshr_cp_data_o[63:58]                Yes    Yes         Yes         OUTPUT    
cp_flag_i[0]                         No     No          No          INPUT     
cp_flag_i[15:1]                      Yes    Yes         Yes         INPUT     
cp_data_i[8:1][63:0]                 Yes    Yes         Yes         INPUT     
cp_data_i[9][44:0]                   Yes    Yes         Yes         INPUT     
cp_data_i[9][63:46]                  Yes    Yes         Yes         INPUT     
cp_data_i[10][30:1]                  Yes    Yes         Yes         INPUT     
cp_data_i[10][36:32]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][41:40]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][45]                    Yes    Yes         Yes         INPUT     
cp_data_i[10][49:47]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][52:51]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][56:55]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][60]                    Yes    Yes         Yes         INPUT     
cp_data_i[10][62]                    Yes    Yes         Yes         INPUT     
cp_data_i[11][27:0]                  Yes    Yes         Yes         INPUT     
cp_data_i[11][36:29]                 Yes    Yes         Yes         INPUT     
cp_data_i[11][49:39]                 Yes    Yes         Yes         INPUT     
cp_data_i[11][51]                    Yes    Yes         Yes         INPUT     
cp_data_i[11][59:54]                 Yes    Yes         Yes         INPUT     
cp_data_i[11][63:62]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][4:0]                   Yes    Yes         Yes         INPUT     
cp_data_i[12][27:6]                  Yes    Yes         Yes         INPUT     
cp_data_i[12][31:29]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][35:33]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][39]                    Yes    Yes         Yes         INPUT     
cp_data_i[12][44:43]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][48:46]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][50]                    Yes    Yes         Yes         INPUT     
cp_data_i[12][54]                    Yes    Yes         Yes         INPUT     
cp_data_i[12][58:57]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][61]                    Yes    Yes         Yes         INPUT     
cp_data_i[13][17:0]                  Yes    Yes         Yes         INPUT     
cp_data_i[13][46:19]                 Yes    Yes         Yes         INPUT     
cp_data_i[13][49]                    Yes    Yes         Yes         INPUT     
cp_data_i[13][56:51]                 Yes    Yes         Yes         INPUT     
cp_data_i[13][63:58]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][14:1]                  Yes    Yes         Yes         INPUT     
cp_data_i[14][19:16]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][21]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][24:23]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][27]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][32:30]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][37:35]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][39]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][41]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][43]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][46:45]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][51:49]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][59:53]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][62:61]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][15:0]                  Yes    Yes         Yes         INPUT     
cp_data_i[15][37:17]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][40:39]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][42]                    Yes    Yes         Yes         INPUT     
cp_data_i[15][45:44]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][48:47]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][53:51]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][55]                    Yes    Yes         Yes         INPUT     
cp_data_i[15][63:57]                 Yes    Yes         Yes         INPUT     
Other bits of cp_data_i[15:0][63:0]  No     No          No          INPUT     

Signal Details
                                  Toggle Toggle 1->0 Toggle 0->1 
mshr_entry.mem_tag[3:0]           Yes    Yes         Yes         
mshr_entry.linked                 No     No          No          
mshr_entry.link_idx[3:0]          No     No          No          
mshr_entry.evict_dirty            Yes    Yes         Yes         
mshr_entry.evict_data[0]          Yes    Yes         Yes         
mshr_entry.evict_data[1]          No     No          No          
mshr_entry.evict_data[10:2]       Yes    Yes         Yes         
mshr_entry.evict_data[11]         No     No          No          
mshr_entry.evict_data[15:12]      Yes    Yes         Yes         
mshr_entry.evict_data[18:16]      No     No          No          
mshr_entry.evict_data[22:19]      Yes    Yes         Yes         
mshr_entry.evict_data[24:23]      No     No          No          
mshr_entry.evict_data[27:25]      Yes    Yes         Yes         
mshr_entry.evict_data[28]         No     No          No          
mshr_entry.evict_data[29]         Yes    Yes         Yes         
mshr_entry.evict_data[30]         No     No          No          
mshr_entry.evict_data[33:31]      Yes    Yes         Yes         
mshr_entry.evict_data[35:34]      No     No          No          
mshr_entry.evict_data[36]         Yes    Yes         Yes         
mshr_entry.evict_data[37]         No     No          No          
mshr_entry.evict_data[42:38]      Yes    Yes         Yes         
mshr_entry.evict_data[43]         No     No          No          
mshr_entry.evict_data[44]         Yes    Yes         Yes         
mshr_entry.evict_data[45]         No     No          No          
mshr_entry.evict_data[46]         Yes    Yes         Yes         
mshr_entry.evict_data[47]         No     No          No          
mshr_entry.evict_data[52:48]      Yes    Yes         Yes         
mshr_entry.evict_data[55:53]      No     No          No          
mshr_entry.evict_data[56]         Yes    Yes         Yes         
mshr_entry.evict_data[57]         No     No          No          
mshr_entry.evict_data[59:58]      Yes    Yes         Yes         
mshr_entry.evict_data[63:60]      No     No          No          
mshr_entry.evict_addr[2:0]        No     No          No          
mshr_entry.evict_addr[15:3]       Yes    Yes         Yes         
mshr_entry.evict_addr[31:16]      No     No          No          
mshr_entry.req_size[1:0]          Yes    Yes         Yes         
mshr_entry.req_data[17:0]         Yes    Yes         Yes         
mshr_entry.req_data[18]           No     No          No          
mshr_entry.req_data[46:19]        Yes    Yes         Yes         
mshr_entry.req_data[48:47]        No     No          No          
mshr_entry.req_data[49]           Yes    Yes         Yes         
mshr_entry.req_data[50]           No     No          No          
mshr_entry.req_data[56:51]        Yes    Yes         Yes         
mshr_entry.req_data[57]           No     No          No          
mshr_entry.req_data[63:58]        Yes    Yes         Yes         
mshr_entry.req_addr[0]            No     No          No          
mshr_entry.req_addr[1]            Yes    Yes         Yes         
mshr_entry.req_addr[2]            No     No          No          
mshr_entry.req_addr[15:3]         Yes    Yes         Yes         
mshr_entry.req_addr[31:16]        No     No          No          
mshr_entry.cmd[1:0]               Yes    Yes         Yes         
mshr_entry.state[2:0]             Yes    Yes         Yes         
next_mshr_entry.mem_tag[3:0]      Yes    Yes         Yes         
next_mshr_entry.linked            Yes    Yes         Yes         
next_mshr_entry.link_idx[1:0]     No     No          No          
next_mshr_entry.link_idx[3:2]     Yes    Yes         Yes         
next_mshr_entry.evict_dirty       Yes    Yes         Yes         
next_mshr_entry.evict_data[0]     Yes    Yes         Yes         
next_mshr_entry.evict_data[1]     No     No          No          
next_mshr_entry.evict_data[10:2]  Yes    Yes         Yes         
next_mshr_entry.evict_data[11]    No     No          No          
next_mshr_entry.evict_data[15:12] Yes    Yes         Yes         
next_mshr_entry.evict_data[18:16] No     No          No          
next_mshr_entry.evict_data[22:19] Yes    Yes         Yes         
next_mshr_entry.evict_data[24:23] No     No          No          
next_mshr_entry.evict_data[27:25] Yes    Yes         Yes         
next_mshr_entry.evict_data[28]    No     No          No          
next_mshr_entry.evict_data[29]    Yes    Yes         Yes         
next_mshr_entry.evict_data[30]    No     No          No          
next_mshr_entry.evict_data[33:31] Yes    Yes         Yes         
next_mshr_entry.evict_data[35:34] No     No          No          
next_mshr_entry.evict_data[36]    Yes    Yes         Yes         
next_mshr_entry.evict_data[37]    No     No          No          
next_mshr_entry.evict_data[42:38] Yes    Yes         Yes         
next_mshr_entry.evict_data[43]    No     No          No          
next_mshr_entry.evict_data[44]    Yes    Yes         Yes         
next_mshr_entry.evict_data[45]    No     No          No          
next_mshr_entry.evict_data[46]    Yes    Yes         Yes         
next_mshr_entry.evict_data[47]    No     No          No          
next_mshr_entry.evict_data[52:48] Yes    Yes         Yes         
next_mshr_entry.evict_data[55:53] No     No          No          
next_mshr_entry.evict_data[56]    Yes    Yes         Yes         
next_mshr_entry.evict_data[57]    No     No          No          
next_mshr_entry.evict_data[59:58] Yes    Yes         Yes         
next_mshr_entry.evict_data[63:60] No     No          No          
next_mshr_entry.evict_addr[2:0]   No     No          No          
next_mshr_entry.evict_addr[15:3]  Yes    Yes         Yes         
next_mshr_entry.evict_addr[31:16] No     No          No          
next_mshr_entry.req_size[1:0]     Yes    Yes         Yes         
next_mshr_entry.req_data[63:0]    Yes    Yes         Yes         
next_mshr_entry.req_addr[15:0]    Yes    Yes         Yes         
next_mshr_entry.req_addr[31:16]   No     No          No          
next_mshr_entry.cmd[1:0]          Yes    Yes         Yes         
next_mshr_entry.state[2:0]        Yes    Yes         Yes         
next_mshr_cp_flag                 Yes    Yes         Yes         
next_mshr_cp_data[17:0]           Yes    Yes         Yes         
next_mshr_cp_data[18]             No     No          No          
next_mshr_cp_data[46:19]          Yes    Yes         Yes         
next_mshr_cp_data[48:47]          No     No          No          
next_mshr_cp_data[49]             Yes    Yes         Yes         
next_mshr_cp_data[50]             No     No          No          
next_mshr_cp_data[56:51]          Yes    Yes         Yes         
next_mshr_cp_data[57]             No     No          No          
next_mshr_cp_data[63:58]          Yes    Yes         Yes         


-------------------------------------------------------------------------------
===============================================================================
Module Instance : cache_tb.dut.cache_ctrl_inst.genblk1[15].mshr_entry_ctrl_inst
===============================================================================

Instance :

SCORE  LINE   TOGGLE 
 75.56  72.86  78.26 


Instance's subtree :

SCORE  LINE   TOGGLE 
 75.56  72.86  78.26 


Module : 

SCORE  LINE   TOGGLE NAME            
 87.59  90.48  84.70 mshr_entry_ctrl 


Parent : 

SCORE  LINE   TOGGLE NAME            
 92.38 100.00  84.76 cache_ctrl_inst 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : cache_tb.dut.cache_ctrl_inst.genblk1[15].mshr_entry_ctrl_inst

             Line No.   Total   Covered  Percent
TOTAL                      210      153    72.86
ALWAYS             75       17       17   100.00
ALWAYS             97      135       88    65.19
ALWAYS            317       25       15    60.00
ALWAYS            368       22       22   100.00
ALWAYS            411       11       11   100.00

74                          always_ff @(posedge clk_i) begin
75         1/1                  if (rst_i) begin
76         1/1                      mshr_entry.state        <=  `SD ST_IDLE     ;
77         1/1                      mshr_entry.cmd          <=  `SD BUS_NONE    ;
78         1/1                      mshr_entry.req_addr     <=  `SD 'b0         ;
79         1/1                      mshr_entry.req_data     <=  `SD 'b0         ;
80         1/1                      mshr_entry.req_size     <=  `SD BYTE        ;
81         1/1                      mshr_entry.evict_addr   <=  `SD 'b0         ;
82         1/1                      mshr_entry.evict_data   <=  `SD 'b0         ;
83         1/1                      mshr_entry.evict_dirty  <=  `SD 1'b0        ;
84         1/1                      mshr_entry.link_idx     <=  `SD 'd0         ;
85         1/1                      mshr_entry.linked       <=  `SD 1'b0        ;
86         1/1                      mshr_entry.mem_tag      <=  `SD 'd0         ;
87         1/1                      mshr_cp_flag_o          <=  `SD 1'b0        ;
88         1/1                      mshr_cp_data_o          <=  `SD 'b0         ;
89                              end else begin
90         1/1                      mshr_entry              <=  `SD next_mshr_entry     ;
91         1/1                      mshr_cp_flag_o          <=  `SD next_mshr_cp_flag   ;
92         1/1                      mshr_cp_data_o          <=  `SD next_mshr_cp_data   ;
93                              end
94                          end
95                      
96                          always_comb begin
97         1/1                  next_mshr_entry.state       =   mshr_entry.state        ;
98         1/1                  next_mshr_entry.cmd         =   mshr_entry.cmd          ;
99         1/1                  next_mshr_entry.req_addr    =   mshr_entry.req_addr     ;
100        1/1                  next_mshr_entry.req_data    =   mshr_entry.req_data     ;
101        1/1                  next_mshr_entry.req_size    =   mshr_entry.req_size     ;
102        1/1                  next_mshr_entry.evict_addr  =   mshr_entry.evict_addr   ;
103        1/1                  next_mshr_entry.evict_data  =   mshr_entry.evict_data   ;
104        1/1                  next_mshr_entry.evict_dirty =   mshr_entry.evict_dirty  ;
105        1/1                  next_mshr_entry.link_idx    =   mshr_entry.link_idx     ;
106        1/1                  next_mshr_entry.linked      =   mshr_entry.linked       ;
107        1/1                  next_mshr_entry.mem_tag     =   mshr_entry.mem_tag      ;
108        1/1                  next_mshr_cp_flag           =   mshr_cp_flag_o          ;
109        1/1                  next_mshr_cp_data           =   mshr_cp_data_o          ;
110        1/1                  case (mshr_entry.state)
111                                 ST_IDLE     :   begin
112                                     // IF   there is a valid transaction on Processor Interface
113                                     // AND  the Processor Interface is granted to this entry
114                                     // AND  the cache_mem Interface is granted to this entry
115                                     // AND  it is a miss
116                                     // AND  the entry is selected to hold the new miss
117        1/1                          if ((proc2cache_i.command != BUS_NONE) && (dp_sel_i == 1'b1)
118                                     && (proc_grant_i == 1'b1)) begin
119                                         // IF   there is an older in-flight transaction to the same addreess
120                                         // ->   Wait for the completion of older miss to the same address
121        1/1                              if (mshr_hit_i && (cp_flag_i[mshr_hit_idx_i] == 1'b0)) begin
122        1/1                                  next_mshr_entry.state       =   ST_WAIT_DEPEND          ;
123        1/1                                  next_mshr_entry.link_idx    =   mshr_hit_idx_i          ;
124        1/1                                  next_mshr_entry.cmd         =   proc2cache_i.command    ;
125        1/1                                  next_mshr_entry.req_addr    =   proc2cache_i.addr       ;
126        1/1                                  next_mshr_entry.req_size    =   proc2cache_i.size       ;
127        1/1                                  if (proc2cache_i.command == BUS_STORE) begin
128        1/1                                      next_mshr_entry.req_data    =   proc2cache_i.data   ;
129                                             end
                        MISSING_ELSE
130                                         // IF   there is an older in-flight transaction that is in the middle of evicting the data block
131                                         // ->   Wait for the completion of write-back to memory
132        1/1                              end else if (evict_hit_i && (cp_flag_i[evict_hit_idx_i] == 1'b0)) begin
133        0/1     ==>                          next_mshr_entry.state       =   ST_WAIT_EVICT           ;
134        0/1     ==>                          next_mshr_entry.link_idx    =   evict_hit_idx_i         ;
135        0/1     ==>                          next_mshr_entry.cmd         =   proc2cache_i.command    ;
136        0/1     ==>                          next_mshr_entry.req_addr    =   proc2cache_i.addr       ;
137        0/1     ==>                          next_mshr_entry.req_size    =   proc2cache_i.size       ;
138        0/1     ==>                          if (proc2cache_i.command == BUS_STORE) begin
139        0/1     ==>                              next_mshr_entry.req_data    =   proc2cache_i.data   ;
140                                             end
                   ==>  MISSING_ELSE
141                                         // IF   it is a miss, and no dependency to older in-flight transactions.
142                                         // ->   Start miss handling
143        1/1                              end else if ((cache_mem_ctrl_i.req_hit == 1'b0) && (cache_mem_grant_i == 1'b1)) begin
144        1/1                                  next_mshr_entry.state       =   ST_RD_MEM               ;
145        1/1                                  next_mshr_entry.link_idx    =   'd0                     ;
146        1/1                                  next_mshr_entry.cmd         =   proc2cache_i.command    ;
147        1/1                                  next_mshr_entry.req_addr    =   proc2cache_i.addr       ;
148        1/1                                  next_mshr_entry.req_size    =   proc2cache_i.size       ;
149        1/1                                  if (proc2cache_i.command == BUS_STORE) begin
150        1/1                                      next_mshr_entry.req_data    =   proc2cache_i.data   ;
151                                             end
                        MISSING_ELSE
152                                         end
                   ==>  MISSING_ELSE
153                                     end
                        MISSING_ELSE
154        1/1                          next_mshr_cp_flag   =   1'b0    ;
155        1/1                          next_mshr_cp_data   =   'b0     ;
156                                 end
157                                 ST_WAIT_DEPEND  :   begin
158                                     // IF   the older transaction that the entry is linked to completed
159                                     // ->   Update the cache data
160        0/1     ==>                  if (cp_flag_i[mshr_entry.link_idx] == 1'b1) begin
161        0/1     ==>                      next_mshr_entry.state       =   ST_UPDATE   ;
162        0/1     ==>                      next_mshr_entry.link_idx    =   'd0         ;
163        0/1     ==>                      next_mshr_entry.req_data    =   cp_data_i[mshr_entry.link_idx];
164        0/1     ==>                      if (mshr_entry.cmd == BUS_STORE) begin
165        0/1     ==>                          case (mshr_entry.req_size)
166        0/1     ==>                              BYTE    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +:  8]    =   mshr_entry.req_data[ 7:0]   ;
167        0/1     ==>                              HALF    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +: 16]    =   mshr_entry.req_data[15:0]   ;
168        0/1     ==>                              WORD    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +: 32]    =   mshr_entry.req_data[31:0]   ;
169        0/1     ==>                              DOUBLE  :   next_mshr_entry.req_data                                    =   mshr_entry.req_data         ;
170        0/1     ==>                              default :   next_mshr_entry.req_data                                    =   mshr_entry.req_data         ;
171                                             endcase
172                                         end
                   ==>  MISSING_ELSE
173                                     end
                   ==>  MISSING_ELSE
174                                 end
175                                 ST_WAIT_EVICT   : begin
176                                     // IF   the older transaction that evicts the cache block completed
177                                     // ->   Read from Memory
178        0/1     ==>                  if (cp_flag_i[mshr_entry.link_idx] == 1'b1) begin
179        0/1     ==>                      next_mshr_entry.state       =   ST_RD_MEM   ;
180        0/1     ==>                      next_mshr_entry.link_idx    =   'd0         ;
181                                     end
                   ==>  MISSING_ELSE
182                                 end
183                                 ST_RD_MEM   :   begin
184                                     // IF   the read transaction is confirmed by Memory Interface
185                                     // ->   Wait for the data to return from Memory
186        1/1                          if ((memory_grant_i == 1'b1) && (mem2cache_i.response != 'd0)) begin
187        1/1                              next_mshr_entry.state       =   ST_WAIT_MEM             ;
188        1/1                              next_mshr_entry.mem_tag     =   mem2cache_i.response    ;
189                                     end
                        MISSING_ELSE
190                                 end
191                                 ST_WAIT_MEM :   begin
192                                     // IF   the data is returned from the Memory
193                                     // ->   Update the cache data
194        1/1                          if (mem2cache_i.tag == mshr_entry.mem_tag) begin
195        1/1                              next_mshr_entry.state       =   ST_UPDATE           ;
196        1/1                              next_mshr_entry.req_data    =   mem2cache_i.data    ;
197        1/1                              if (mshr_entry.cmd == BUS_STORE) begin
198        1/1                                  case (mshr_entry.req_size)
199        0/1     ==>                              BYTE    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +:  8]    =   mshr_entry.req_data[ 7:0]   ;
200        1/1                                      HALF    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +: 16]    =   mshr_entry.req_data[15:0]   ;
201        1/1                                      WORD    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +: 32]    =   mshr_entry.req_data[31:0]   ;
202        1/1                                      DOUBLE  :   next_mshr_entry.req_data                                    =   mshr_entry.req_data         ;
203        0/1     ==>                              default :   next_mshr_entry.req_data                                    =   mshr_entry.req_data         ;
204                                             endcase
205                                         end
                        MISSING_ELSE
206                                     end
                        MISSING_ELSE
207                                 end
208                                 ST_UPDATE   :   begin
209                                     // IF   the req interface is granted to this entry
210        1/1                          if (cache_mem_grant_i == 1'b1) begin
211                                         // IF   it is a load miss
212                                         // ->   Output data to processor
213        1/1                              if (mshr_entry.cmd == BUS_LOAD) begin
214        1/1                                  next_mshr_entry.state       =   ST_OUTPUT;
215        1/1                                  next_mshr_entry.evict_addr  =   cache_mem_ctrl_i.evict_addr ;
216        1/1                                  next_mshr_entry.evict_data  =   cache_mem_ctrl_i.evict_data ;
217        1/1                                  next_mshr_entry.evict_dirty =   cache_mem_ctrl_i.evict_dirty;
218                                         // IF   a dirty block is evicted
219                                         // ->   Write back the evicted block
220        1/1                              end else if (cache_mem_ctrl_i.evict_dirty == 1'b1) begin
221        1/1                                  next_mshr_entry.state       =   ST_EVICT;
222        1/1                                  next_mshr_entry.evict_addr  =   cache_mem_ctrl_i.evict_addr ;
223        1/1                                  next_mshr_entry.evict_data  =   cache_mem_ctrl_i.evict_data ;
224        1/1                                  next_mshr_entry.evict_dirty =   cache_mem_ctrl_i.evict_dirty;
225                                         // ELSE
226                                         // ->   Miss Handling Completed
227                                         end else begin
228        0/1     ==>                          next_mshr_entry.state       =   ST_IDLE             ;
229        0/1     ==>                          next_mshr_entry.cmd         =   BUS_NONE            ;
230        0/1     ==>                          next_mshr_entry.req_addr    =   'b0                 ;
231        0/1     ==>                          next_mshr_entry.req_data    =   'b0                 ;
232        0/1     ==>                          next_mshr_entry.req_size    =   BYTE                ;
233        0/1     ==>                          next_mshr_entry.evict_addr  =   'b0                 ;
234        0/1     ==>                          next_mshr_entry.evict_data  =   'b0                 ;
235        0/1     ==>                          next_mshr_entry.evict_dirty =   1'b0                ;
236        0/1     ==>                          next_mshr_entry.link_idx    =   'd0                 ;
237        0/1     ==>                          next_mshr_entry.mem_tag     =   'd0                 ;
238        0/1     ==>                          next_mshr_cp_flag           =   1'b1                ;
239        0/1     ==>                          next_mshr_cp_data           =   mshr_entry.req_data ;
240                                         end
241                                     end
                        MISSING_ELSE
242                                 end
243                                 ST_OUTPUT   :   begin
244                                     // IF   the Processor Interface is granted to this entry
245        1/1                          if (proc_grant_i == 1'b1) begin
246                                         // IF   the evicted block is dirty
247                                         // ->   Write back the evicted block
248        1/1                              if (mshr_entry.evict_dirty == 1'b1) begin
249        1/1                                  next_mshr_entry.state       =   ST_EVICT;
250                                         // ELSE
251                                         // ->   Miss Handling Completed
252                                         end else begin
253        0/1     ==>                          next_mshr_entry.state       =   ST_IDLE             ;
254        0/1     ==>                          next_mshr_entry.cmd         =   BUS_NONE            ;
255        0/1     ==>                          next_mshr_entry.req_addr    =   'b0                 ;
256        0/1     ==>                          next_mshr_entry.req_data    =   'b0                 ;
257        0/1     ==>                          next_mshr_entry.req_size    =   BYTE                ;
258        0/1     ==>                          next_mshr_entry.evict_addr  =   'b0                 ;
259        0/1     ==>                          next_mshr_entry.evict_data  =   'b0                 ;
260        0/1     ==>                          next_mshr_entry.evict_dirty =   1'b0                ;
261        0/1     ==>                          next_mshr_entry.link_idx    =   'd0                 ;
262        0/1     ==>                          next_mshr_entry.mem_tag     =   'd0                 ;
263        0/1     ==>                          next_mshr_cp_flag           =   1'b1                ;
264        0/1     ==>                          next_mshr_cp_data           =   mshr_entry.req_data ;
265                                         end
266                                     end
                        MISSING_ELSE
267                                 end
268                                 ST_EVICT    :   begin
269                                     // IF   the write back transaction to Memory is confirmed
270                                     // ->   Miss Handling Completed
271        1/1                          if ((memory_grant_i == 1'b1) && (mem2cache_i.response != 'd0)) begin
272        1/1                              next_mshr_entry.state       =   ST_IDLE             ;
273        1/1                              next_mshr_entry.cmd         =   BUS_NONE            ;
274        1/1                              next_mshr_entry.req_addr    =   'b0                 ;
275        1/1                              next_mshr_entry.req_data    =   'b0                 ;
276        1/1                              next_mshr_entry.req_size    =   BYTE                ;
277        1/1                              next_mshr_entry.evict_addr  =   'b0                 ;
278        1/1                              next_mshr_entry.evict_data  =   'b0                 ;
279        1/1                              next_mshr_entry.evict_dirty =   1'b0                ;
280        1/1                              next_mshr_entry.link_idx    =   'd0                 ;
281        1/1                              next_mshr_entry.mem_tag     =   'd0                 ;
282        1/1                              next_mshr_cp_flag           =   1'b1                ;
283        1/1                              next_mshr_cp_data           =   mshr_entry.req_data ;
284                                     end
                        MISSING_ELSE
285                                 end
286                                 default     :   begin
287        1/1                          next_mshr_entry.state       =   ST_IDLE     ;
288        1/1                          next_mshr_entry.cmd         =   BUS_NONE    ;
289        1/1                          next_mshr_entry.req_addr    =   'b0         ;
290        1/1                          next_mshr_entry.req_data    =   'b0         ;
291        1/1                          next_mshr_entry.req_size    =   BYTE        ;
292        1/1                          next_mshr_entry.evict_addr  =   'b0         ;
293        1/1                          next_mshr_entry.evict_data  =   'b0         ;
294        1/1                          next_mshr_entry.evict_dirty =   1'b0        ;
295        1/1                          next_mshr_entry.link_idx    =   'd0         ;
296        1/1                          next_mshr_entry.mem_tag     =   'd0         ;
297        1/1                          next_mshr_cp_flag           =   1'b0        ;
298        1/1                          next_mshr_cp_data           =   'd0         ;
299                                 end
300                             endcase
301                     
302        1/1                  if (next_mshr_entry.state == ST_IDLE) begin
303        1/1                      next_mshr_entry.linked  =   1'b0;
304        1/1                  end else if ((mshr_hit_i == 1'b1) && (mshr_hit_idx_i == mshr_entry_idx_i)) begin
305        1/1                      next_mshr_entry.linked  =   1'b1;
306                             end
                        MISSING_ELSE
307                         end
308                     
309                     // --------------------------------------------------------------------
310                     // MSHR entry output
311                     // --------------------------------------------------------------------
312                         assign  mshr_entry_o    =   mshr_entry  ;
313                     // --------------------------------------------------------------------
314                     // Processor Interface
315                     // --------------------------------------------------------------------
316                         always_comb begin
317        1/1                  mshr_proc_o.response    =   'd0 ;
318        1/1                  mshr_proc_o.data        =   'b0 ;
319        1/1                  mshr_proc_o.tag         =   'd0 ;
320        1/1                  case (mshr_entry.state)
321                                 ST_IDLE     :   begin
322                                     // IF   the processor request is allocated to this entry
323        1/1                          if ((proc2cache_i.command != BUS_NONE) && (dp_sel_i == 1'b1)) begin
324                                         // IF   The Processor Interface is granted to this entry
325                                         // AND  there is a dependency to older in-flight transaction
326                                         // ->   Confirm the request
327        1/1                              if (((mshr_hit_i && (cp_flag_i[mshr_hit_idx_i] == 1'b0))
328                                         || (evict_hit_i && (cp_flag_i[evict_hit_idx_i] == 1'b0)))) begin
329        1/1                                  mshr_proc_o.response    =   mshr_entry_idx_i;
330                                         // IF   The Processor Interface is granted to this entry
331                                         // AND  The cache_mem Interface is granted to this entry
332                                         // ->   Confirm the request 
333        1/1                              end else if (cache_mem_grant_i == 1'b1) begin
334        1/1                                  mshr_proc_o.response    =   mshr_entry_idx_i;
335                                             // IF   it is a load hit
336                                             // ->   Output data and tag
337        1/1                                  if (cache_mem_ctrl_i.req_hit == 1'b1 && proc2cache_i.command == BUS_LOAD) begin
338        0/1     ==>                              mshr_proc_o.tag     =   mshr_entry_idx_i;
339        0/1     ==>                              case (proc2cache_i.size)
340        0/1     ==>                                  BYTE    :   mshr_proc_o.data    =   {56'b0,cache_mem_ctrl_i.req_data_out[proc2cache_i.addr[2:0]+: 8]};
341        0/1     ==>                                  HALF    :   mshr_proc_o.data    =   {48'b0,cache_mem_ctrl_i.req_data_out[proc2cache_i.addr[2:0]+:16]};
342        0/1     ==>                                  WORD    :   mshr_proc_o.data    =   {32'b0,cache_mem_ctrl_i.req_data_out[proc2cache_i.addr[2:0]+:32]};
343        0/1     ==>                                  DOUBLE  :   mshr_proc_o.data    =   cache_mem_ctrl_i.req_data_out;
344        0/1     ==>                                  default :   mshr_proc_o.data    =   cache_mem_ctrl_i.req_data_out;
345                                                 endcase
346                                             end
                        MISSING_ELSE
347                                         end
                        MISSING_ELSE
348                                     end
                        MISSING_ELSE
349                                 end
350                                 ST_OUTPUT   :   begin
351        1/1                          mshr_proc_o.response    =   'd0                 ;
352        1/1                          mshr_proc_o.tag         =   mshr_entry_idx_i    ;
353        1/1                          case (mshr_entry.req_size)
354        1/1                              BYTE    :   mshr_proc_o.data    =   {56'b0,mshr_entry.req_data[mshr_entry.req_addr[2:0]+: 8]};
355        1/1                              HALF    :   mshr_proc_o.data    =   {48'b0,mshr_entry.req_data[mshr_entry.req_addr[2:0]+:16]};
356        0/1     ==>                      WORD    :   mshr_proc_o.data    =   {32'b0,mshr_entry.req_data[mshr_entry.req_addr[2:0]+:32]};
357        0/1     ==>                      DOUBLE  :   mshr_proc_o.data    =   mshr_entry.req_data;
358        0/1     ==>                      default :   mshr_proc_o.data    =   mshr_entry.req_data;
359                                     endcase
360                                 end
                        MISSING_DEFAULT
361                             endcase
362                         end
363                     
364                     // --------------------------------------------------------------------
365                     // cache_mem Interface
366                     // --------------------------------------------------------------------
367                         always_comb begin
368        1/1                  mshr_cache_mem_o.req_cmd        =   REQ_NONE;
369        1/1                  mshr_cache_mem_o.req_addr       =   'b0     ;
370        1/1                  mshr_cache_mem_o.req_data_in    =   'b0     ;
371        1/1                  case (mshr_entry.state)
372                                 ST_IDLE:    begin
373                                     // IF   the processor request is allocated to this entry
374        1/1                          if (dp_sel_i == 1'b1) begin
375        1/1                              case (proc2cache_i.command)
376                                             BUS_LOAD    :   begin
377        1/1                                      mshr_cache_mem_o.req_cmd        =   REQ_LOAD                        ;
378        1/1                                      mshr_cache_mem_o.req_addr       =   proc2cache_i.addr               ;
379        1/1                                      mshr_cache_mem_o.req_data_in    =   cache_mem_ctrl_i.req_data_out   ;
380                                             end
381                                             BUS_STORE   :   begin
382        1/1                                      mshr_cache_mem_o.req_cmd        =   REQ_STORE                       ;
383        1/1                                      mshr_cache_mem_o.req_addr       =   proc2cache_i.addr               ;
384        1/1                                      mshr_cache_mem_o.req_data_in    =   cache_mem_ctrl_i.req_data_out   ;
385        1/1                                      case (proc2cache_i.size)
386        1/1                                          BYTE    :   mshr_cache_mem_o.req_data_in[proc2cache_i.addr[2:0] +:  8]  =   proc2cache_i.data[ 7:0] ;
387        1/1                                          HALF    :   mshr_cache_mem_o.req_data_in[proc2cache_i.addr[2:0] +: 16]  =   proc2cache_i.data[15:0] ;
388        1/1                                          WORD    :   mshr_cache_mem_o.req_data_in[proc2cache_i.addr[2:0] +: 32]  =   proc2cache_i.data[31:0] ;
389        1/1                                          DOUBLE  :   mshr_cache_mem_o.req_data_in                                =   proc2cache_i.data       ;
                   ==>  MISSING_DEFAULT
390                                                 endcase
391                                             end    
                        MISSING_DEFAULT
392                                         endcase
393                                     end
                        MISSING_ELSE
394                                 end
395                                 ST_UPDATE:  begin
396        1/1                          if (mshr_entry.cmd == BUS_LOAD) begin
397        1/1                              mshr_cache_mem_o.req_cmd    =   REQ_LOAD_MISS       ;
398                                     end else begin
399        1/1                              mshr_cache_mem_o.req_cmd    =   REQ_STORE_MISS      ;
400                                     end
401        1/1                          mshr_cache_mem_o.req_addr       =   mshr_entry.req_addr ;
402        1/1                          mshr_cache_mem_o.req_data_in    =   mshr_entry.req_data ;
403                                 end
                        MISSING_DEFAULT
404                             endcase
405                         end
406                     
407                     // --------------------------------------------------------------------
408                     // Memory Interface
409                     // --------------------------------------------------------------------
410                         always_comb begin
411        1/1                  mshr_memory_o.addr      =   {mshr_entry.req_addr[C_XLEN-1:C_CACHE_OFFSET_WIDTH], {C_CACHE_OFFSET_WIDTH{1'b0}}};
412        1/1                  mshr_memory_o.size      =   DOUBLE              ;
413        1/1                  mshr_memory_o.command   =   BUS_NONE            ;
414        1/1                  mshr_memory_o.data      =   'd0 ;
415        1/1                  case (mshr_entry.state)
416                                 ST_RD_MEM   :   begin
417        1/1                          mshr_memory_o.data      =   'd0 ;
418        1/1                          mshr_memory_o.addr      =   {mshr_entry.req_addr[C_XLEN-1:C_CACHE_OFFSET_WIDTH], {C_CACHE_OFFSET_WIDTH{1'b0}}};
419        1/1                          mshr_memory_o.command   =   BUS_LOAD;
420                                 end
421                                 ST_EVICT    :   begin
422        1/1                          mshr_memory_o.data      =   mshr_entry.evict_data;
423        1/1                          mshr_memory_o.addr      =   {mshr_entry.evict_addr[C_XLEN-1:C_CACHE_OFFSET_WIDTH], {C_CACHE_OFFSET_WIDTH{1'b0}}};
424        1/1                          mshr_memory_o.command   =   BUS_STORE;
425                                 end
                        MISSING_DEFAULT

-------------------------------------------------------------------------------
Toggle Coverage for Instance : cache_tb.dut.cache_ctrl_inst.genblk1[15].mshr_entry_ctrl_inst
                Total Covered Percent 
Totals          72    35      48.61   
Total Bits      4844  3791    78.26   
Total Bits 0->1 2422  1895    78.24   
Total Bits 1->0 2422  1896    78.28   

                                
Ports          48   25   52.08  
Port Bits      3878 3079 79.40  
Port Bits 0->1 1939 1539 79.37  
Port Bits 1->0 1939 1540 79.42  

                                
Signals          24  10  41.67  
Signal Bits      966 712 73.71  
Signal Bits 0->1 483 356 73.71  
Signal Bits 1->0 483 356 73.71  

Port Details
                                     Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i                                Yes    Yes         Yes         INPUT     
rst_i                                No     Yes         No          INPUT     
mshr_entry_idx_i[3:0]                No     No          No          INPUT     
mshr_entry_o.mem_tag[2:0]            Yes    Yes         Yes         OUTPUT    
mshr_entry_o.mem_tag[3]              No     No          No          OUTPUT    
mshr_entry_o.linked                  No     No          No          OUTPUT    
mshr_entry_o.link_idx[3:0]           No     No          No          OUTPUT    
mshr_entry_o.evict_dirty             Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_data[0]           No     No          No          OUTPUT    
mshr_entry_o.evict_data[3:1]         Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_data[4]           No     No          No          OUTPUT    
mshr_entry_o.evict_data[13:5]        Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_data[14]          No     No          No          OUTPUT    
mshr_entry_o.evict_data[15]          Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_data[16]          No     No          No          OUTPUT    
mshr_entry_o.evict_data[18:17]       Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_data[19]          No     No          No          OUTPUT    
mshr_entry_o.evict_data[33:20]       Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_data[34]          No     No          No          OUTPUT    
mshr_entry_o.evict_data[36:35]       Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_data[38:37]       No     No          No          OUTPUT    
mshr_entry_o.evict_data[40:39]       Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_data[41]          No     No          No          OUTPUT    
mshr_entry_o.evict_data[43:42]       Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_data[45:44]       No     No          No          OUTPUT    
mshr_entry_o.evict_data[47:46]       Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_data[48]          No     No          No          OUTPUT    
mshr_entry_o.evict_data[49]          Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_data[50]          No     No          No          OUTPUT    
mshr_entry_o.evict_data[54:51]       Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_data[55]          No     No          No          OUTPUT    
mshr_entry_o.evict_data[56]          Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_data[57]          No     No          No          OUTPUT    
mshr_entry_o.evict_data[63:58]       Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_addr[2:0]         No     No          No          OUTPUT    
mshr_entry_o.evict_addr[15:3]        Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_addr[31:16]       No     No          No          OUTPUT    
mshr_entry_o.req_size[1:0]           Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_data[15:0]          Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_data[16]            No     No          No          OUTPUT    
mshr_entry_o.req_data[37:17]         Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_data[38]            No     No          No          OUTPUT    
mshr_entry_o.req_data[40:39]         Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_data[41]            No     No          No          OUTPUT    
mshr_entry_o.req_data[42]            Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_data[43]            No     No          No          OUTPUT    
mshr_entry_o.req_data[45:44]         Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_data[46]            No     No          No          OUTPUT    
mshr_entry_o.req_data[48:47]         Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_data[50:49]         No     No          No          OUTPUT    
mshr_entry_o.req_data[53:51]         Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_data[54]            No     No          No          OUTPUT    
mshr_entry_o.req_data[55]            Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_data[56]            No     No          No          OUTPUT    
mshr_entry_o.req_data[63:57]         Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_addr[15:0]          Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_addr[31:16]         No     No          No          OUTPUT    
mshr_entry_o.cmd[1:0]                Yes    Yes         Yes         OUTPUT    
mshr_entry_o.state[2:0]              Yes    Yes         Yes         OUTPUT    
proc_grant_i                         Yes    Yes         Yes         INPUT     
proc2cache_i.command[1:0]            Yes    Yes         Yes         INPUT     
proc2cache_i.size[1:0]               Yes    Yes         Yes         INPUT     
proc2cache_i.data[63:0]              Yes    Yes         Yes         INPUT     
proc2cache_i.addr[15:0]              Yes    Yes         Yes         INPUT     
proc2cache_i.addr[31:16]             No     No          No          INPUT     
mshr_proc_o.tag[3:0]                 Yes    Yes         Yes         OUTPUT    
mshr_proc_o.data[0]                  Yes    Yes         Yes         OUTPUT    
mshr_proc_o.data[1]                  No     No          No          OUTPUT    
mshr_proc_o.data[2]                  Yes    Yes         Yes         OUTPUT    
mshr_proc_o.data[3]                  No     No          No          OUTPUT    
mshr_proc_o.data[7:4]                Yes    Yes         Yes         OUTPUT    
mshr_proc_o.data[63:8]               No     No          No          OUTPUT    
mshr_proc_o.response[3:0]            Yes    Yes         Yes         OUTPUT    
cache_mem_grant_i                    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.evict_data[63:0]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.evict_addr[2:0]     No     No          No          INPUT     
cache_mem_ctrl_i.evict_addr[15:3]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.evict_addr[31:16]   No     No          No          INPUT     
cache_mem_ctrl_i.evict_dirty         Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[4:0]   Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[6:5]   No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[8:7]   Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[11:9]  No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[13:12] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[15:14] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[25:16] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[26]    No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[31:27] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[33:32] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[34]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[37:35] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[38]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[41:39] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[42]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[45:43] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[47:46] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[50:48] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[52:51] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[54:53] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[58:55] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[60:59] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[63:61] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_hit             Yes    Yes         Yes         INPUT     
mshr_cache_mem_o.req_data_in[37:0]   Yes    Yes         Yes         OUTPUT    
mshr_cache_mem_o.req_data_in[38]     No     No          No          OUTPUT    
mshr_cache_mem_o.req_data_in[63:39]  Yes    Yes         Yes         OUTPUT    
mshr_cache_mem_o.req_addr[15:0]      Yes    Yes         Yes         OUTPUT    
mshr_cache_mem_o.req_addr[31:16]     No     No          No          OUTPUT    
mshr_cache_mem_o.req_cmd[2:0]        Yes    Yes         Yes         OUTPUT    
memory_grant_i                       Yes    Yes         Yes         INPUT     
mem2cache_i.tag[3:0]                 Yes    Yes         Yes         INPUT     
mem2cache_i.data[63:0]               Yes    Yes         Yes         INPUT     
mem2cache_i.response[3:0]            Yes    Yes         Yes         INPUT     
mshr_memory_o.command[1:0]           Yes    Yes         Yes         OUTPUT    
mshr_memory_o.size[1:0]              No     No          No          OUTPUT    
mshr_memory_o.data[0]                No     No          No          OUTPUT    
mshr_memory_o.data[3:1]              Yes    Yes         Yes         OUTPUT    
mshr_memory_o.data[4]                No     No          No          OUTPUT    
mshr_memory_o.data[13:5]             Yes    Yes         Yes         OUTPUT    
mshr_memory_o.data[14]               No     No          No          OUTPUT    
mshr_memory_o.data[15]               Yes    Yes         Yes         OUTPUT    
mshr_memory_o.data[16]               No     No          No          OUTPUT    
mshr_memory_o.data[18:17]            Yes    Yes         Yes         OUTPUT    
mshr_memory_o.data[19]               No     No          No          OUTPUT    
mshr_memory_o.data[33:20]            Yes    Yes         Yes         OUTPUT    
mshr_memory_o.data[34]               No     No          No          OUTPUT    
mshr_memory_o.data[36:35]            Yes    Yes         Yes         OUTPUT    
mshr_memory_o.data[38:37]            No     No          No          OUTPUT    
mshr_memory_o.data[40:39]            Yes    Yes         Yes         OUTPUT    
mshr_memory_o.data[41]               No     No          No          OUTPUT    
mshr_memory_o.data[43:42]            Yes    Yes         Yes         OUTPUT    
mshr_memory_o.data[45:44]            No     No          No          OUTPUT    
mshr_memory_o.data[47:46]            Yes    Yes         Yes         OUTPUT    
mshr_memory_o.data[48]               No     No          No          OUTPUT    
mshr_memory_o.data[49]               Yes    Yes         Yes         OUTPUT    
mshr_memory_o.data[50]               No     No          No          OUTPUT    
mshr_memory_o.data[54:51]            Yes    Yes         Yes         OUTPUT    
mshr_memory_o.data[55]               No     No          No          OUTPUT    
mshr_memory_o.data[56]               Yes    Yes         Yes         OUTPUT    
mshr_memory_o.data[57]               No     No          No          OUTPUT    
mshr_memory_o.data[63:58]            Yes    Yes         Yes         OUTPUT    
mshr_memory_o.addr[2:0]              No     No          No          OUTPUT    
mshr_memory_o.addr[15:3]             Yes    Yes         Yes         OUTPUT    
mshr_memory_o.addr[31:16]            No     No          No          OUTPUT    
mshr_hit_i                           Yes    Yes         Yes         INPUT     
mshr_hit_idx_i[3:0]                  Yes    Yes         Yes         INPUT     
evict_hit_i                          No     No          No          INPUT     
evict_hit_idx_i[3:0]                 No     No          No          INPUT     
dp_sel_i                             Yes    Yes         Yes         INPUT     
mshr_cp_flag_o                       Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[15:0]                 Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[16]                   No     No          No          OUTPUT    
mshr_cp_data_o[37:17]                Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[38]                   No     No          No          OUTPUT    
mshr_cp_data_o[40:39]                Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[41]                   No     No          No          OUTPUT    
mshr_cp_data_o[42]                   Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[43]                   No     No          No          OUTPUT    
mshr_cp_data_o[45:44]                Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[46]                   No     No          No          OUTPUT    
mshr_cp_data_o[48:47]                Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[50:49]                No     No          No          OUTPUT    
mshr_cp_data_o[53:51]                Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[54]                   No     No          No          OUTPUT    
mshr_cp_data_o[55]                   Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[56]                   No     No          No          OUTPUT    
mshr_cp_data_o[63:57]                Yes    Yes         Yes         OUTPUT    
cp_flag_i[0]                         No     No          No          INPUT     
cp_flag_i[15:1]                      Yes    Yes         Yes         INPUT     
cp_data_i[8:1][63:0]                 Yes    Yes         Yes         INPUT     
cp_data_i[9][44:0]                   Yes    Yes         Yes         INPUT     
cp_data_i[9][63:46]                  Yes    Yes         Yes         INPUT     
cp_data_i[10][30:1]                  Yes    Yes         Yes         INPUT     
cp_data_i[10][36:32]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][41:40]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][45]                    Yes    Yes         Yes         INPUT     
cp_data_i[10][49:47]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][52:51]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][56:55]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][60]                    Yes    Yes         Yes         INPUT     
cp_data_i[10][62]                    Yes    Yes         Yes         INPUT     
cp_data_i[11][27:0]                  Yes    Yes         Yes         INPUT     
cp_data_i[11][36:29]                 Yes    Yes         Yes         INPUT     
cp_data_i[11][49:39]                 Yes    Yes         Yes         INPUT     
cp_data_i[11][51]                    Yes    Yes         Yes         INPUT     
cp_data_i[11][59:54]                 Yes    Yes         Yes         INPUT     
cp_data_i[11][63:62]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][4:0]                   Yes    Yes         Yes         INPUT     
cp_data_i[12][27:6]                  Yes    Yes         Yes         INPUT     
cp_data_i[12][31:29]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][35:33]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][39]                    Yes    Yes         Yes         INPUT     
cp_data_i[12][44:43]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][48:46]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][50]                    Yes    Yes         Yes         INPUT     
cp_data_i[12][54]                    Yes    Yes         Yes         INPUT     
cp_data_i[12][58:57]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][61]                    Yes    Yes         Yes         INPUT     
cp_data_i[13][17:0]                  Yes    Yes         Yes         INPUT     
cp_data_i[13][46:19]                 Yes    Yes         Yes         INPUT     
cp_data_i[13][49]                    Yes    Yes         Yes         INPUT     
cp_data_i[13][56:51]                 Yes    Yes         Yes         INPUT     
cp_data_i[13][63:58]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][14:1]                  Yes    Yes         Yes         INPUT     
cp_data_i[14][19:16]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][21]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][24:23]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][27]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][32:30]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][37:35]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][39]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][41]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][43]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][46:45]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][51:49]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][59:53]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][62:61]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][15:0]                  Yes    Yes         Yes         INPUT     
cp_data_i[15][37:17]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][40:39]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][42]                    Yes    Yes         Yes         INPUT     
cp_data_i[15][45:44]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][48:47]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][53:51]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][55]                    Yes    Yes         Yes         INPUT     
cp_data_i[15][63:57]                 Yes    Yes         Yes         INPUT     
Other bits of cp_data_i[15:0][63:0]  No     No          No          INPUT     

Signal Details
                                  Toggle Toggle 1->0 Toggle 0->1 
mshr_entry.mem_tag[2:0]           Yes    Yes         Yes         
mshr_entry.mem_tag[3]             No     No          No          
mshr_entry.linked                 No     No          No          
mshr_entry.link_idx[3:0]          No     No          No          
mshr_entry.evict_dirty            Yes    Yes         Yes         
mshr_entry.evict_data[0]          No     No          No          
mshr_entry.evict_data[3:1]        Yes    Yes         Yes         
mshr_entry.evict_data[4]          No     No          No          
mshr_entry.evict_data[13:5]       Yes    Yes         Yes         
mshr_entry.evict_data[14]         No     No          No          
mshr_entry.evict_data[15]         Yes    Yes         Yes         
mshr_entry.evict_data[16]         No     No          No          
mshr_entry.evict_data[18:17]      Yes    Yes         Yes         
mshr_entry.evict_data[19]         No     No          No          
mshr_entry.evict_data[33:20]      Yes    Yes         Yes         
mshr_entry.evict_data[34]         No     No          No          
mshr_entry.evict_data[36:35]      Yes    Yes         Yes         
mshr_entry.evict_data[38:37]      No     No          No          
mshr_entry.evict_data[40:39]      Yes    Yes         Yes         
mshr_entry.evict_data[41]         No     No          No          
mshr_entry.evict_data[43:42]      Yes    Yes         Yes         
mshr_entry.evict_data[45:44]      No     No          No          
mshr_entry.evict_data[47:46]      Yes    Yes         Yes         
mshr_entry.evict_data[48]         No     No          No          
mshr_entry.evict_data[49]         Yes    Yes         Yes         
mshr_entry.evict_data[50]         No     No          No          
mshr_entry.evict_data[54:51]      Yes    Yes         Yes         
mshr_entry.evict_data[55]         No     No          No          
mshr_entry.evict_data[56]         Yes    Yes         Yes         
mshr_entry.evict_data[57]         No     No          No          
mshr_entry.evict_data[63:58]      Yes    Yes         Yes         
mshr_entry.evict_addr[2:0]        No     No          No          
mshr_entry.evict_addr[15:3]       Yes    Yes         Yes         
mshr_entry.evict_addr[31:16]      No     No          No          
mshr_entry.req_size[1:0]          Yes    Yes         Yes         
mshr_entry.req_data[15:0]         Yes    Yes         Yes         
mshr_entry.req_data[16]           No     No          No          
mshr_entry.req_data[37:17]        Yes    Yes         Yes         
mshr_entry.req_data[38]           No     No          No          
mshr_entry.req_data[40:39]        Yes    Yes         Yes         
mshr_entry.req_data[41]           No     No          No          
mshr_entry.req_data[42]           Yes    Yes         Yes         
mshr_entry.req_data[43]           No     No          No          
mshr_entry.req_data[45:44]        Yes    Yes         Yes         
mshr_entry.req_data[46]           No     No          No          
mshr_entry.req_data[48:47]        Yes    Yes         Yes         
mshr_entry.req_data[50:49]        No     No          No          
mshr_entry.req_data[53:51]        Yes    Yes         Yes         
mshr_entry.req_data[54]           No     No          No          
mshr_entry.req_data[55]           Yes    Yes         Yes         
mshr_entry.req_data[56]           No     No          No          
mshr_entry.req_data[63:57]        Yes    Yes         Yes         
mshr_entry.req_addr[15:0]         Yes    Yes         Yes         
mshr_entry.req_addr[31:16]        No     No          No          
mshr_entry.cmd[1:0]               Yes    Yes         Yes         
mshr_entry.state[2:0]             Yes    Yes         Yes         
next_mshr_entry.mem_tag[2:0]      Yes    Yes         Yes         
next_mshr_entry.mem_tag[3]        No     No          No          
next_mshr_entry.linked            Yes    Yes         Yes         
next_mshr_entry.link_idx[0]       No     No          No          
next_mshr_entry.link_idx[3:1]     Yes    Yes         Yes         
next_mshr_entry.evict_dirty       Yes    Yes         Yes         
next_mshr_entry.evict_data[0]     No     No          No          
next_mshr_entry.evict_data[3:1]   Yes    Yes         Yes         
next_mshr_entry.evict_data[4]     No     No          No          
next_mshr_entry.evict_data[13:5]  Yes    Yes         Yes         
next_mshr_entry.evict_data[14]    No     No          No          
next_mshr_entry.evict_data[15]    Yes    Yes         Yes         
next_mshr_entry.evict_data[16]    No     No          No          
next_mshr_entry.evict_data[18:17] Yes    Yes         Yes         
next_mshr_entry.evict_data[19]    No     No          No          
next_mshr_entry.evict_data[33:20] Yes    Yes         Yes         
next_mshr_entry.evict_data[34]    No     No          No          
next_mshr_entry.evict_data[36:35] Yes    Yes         Yes         
next_mshr_entry.evict_data[38:37] No     No          No          
next_mshr_entry.evict_data[40:39] Yes    Yes         Yes         
next_mshr_entry.evict_data[41]    No     No          No          
next_mshr_entry.evict_data[43:42] Yes    Yes         Yes         
next_mshr_entry.evict_data[45:44] No     No          No          
next_mshr_entry.evict_data[47:46] Yes    Yes         Yes         
next_mshr_entry.evict_data[48]    No     No          No          
next_mshr_entry.evict_data[49]    Yes    Yes         Yes         
next_mshr_entry.evict_data[50]    No     No          No          
next_mshr_entry.evict_data[54:51] Yes    Yes         Yes         
next_mshr_entry.evict_data[55]    No     No          No          
next_mshr_entry.evict_data[56]    Yes    Yes         Yes         
next_mshr_entry.evict_data[57]    No     No          No          
next_mshr_entry.evict_data[63:58] Yes    Yes         Yes         
next_mshr_entry.evict_addr[2:0]   No     No          No          
next_mshr_entry.evict_addr[15:3]  Yes    Yes         Yes         
next_mshr_entry.evict_addr[31:16] No     No          No          
next_mshr_entry.req_size[1:0]     Yes    Yes         Yes         
next_mshr_entry.req_data[37:0]    Yes    Yes         Yes         
next_mshr_entry.req_data[38]      No     No          No          
next_mshr_entry.req_data[63:39]   Yes    Yes         Yes         
next_mshr_entry.req_addr[15:0]    Yes    Yes         Yes         
next_mshr_entry.req_addr[31:16]   No     No          No          
next_mshr_entry.cmd[1:0]          Yes    Yes         Yes         
next_mshr_entry.state[2:0]        Yes    Yes         Yes         
next_mshr_cp_flag                 Yes    Yes         Yes         
next_mshr_cp_data[15:0]           Yes    Yes         Yes         
next_mshr_cp_data[16]             No     No          No          
next_mshr_cp_data[37:17]          Yes    Yes         Yes         
next_mshr_cp_data[38]             No     No          No          
next_mshr_cp_data[40:39]          Yes    Yes         Yes         
next_mshr_cp_data[41]             No     No          No          
next_mshr_cp_data[42]             Yes    Yes         Yes         
next_mshr_cp_data[43]             No     No          No          
next_mshr_cp_data[45:44]          Yes    Yes         Yes         
next_mshr_cp_data[46]             No     No          No          
next_mshr_cp_data[48:47]          Yes    Yes         Yes         
next_mshr_cp_data[50:49]          No     No          No          
next_mshr_cp_data[53:51]          Yes    Yes         Yes         
next_mshr_cp_data[54]             No     No          No          
next_mshr_cp_data[55]             Yes    Yes         Yes         
next_mshr_cp_data[56]             No     No          No          
next_mshr_cp_data[63:57]          Yes    Yes         Yes         


-------------------------------------------------------------------------------
===============================================================================
Module Instance : cache_tb.dut.cache_ctrl_inst.genblk1[11].mshr_entry_ctrl_inst
===============================================================================

Instance :

SCORE  LINE   TOGGLE 
 76.96  73.81  80.12 


Instance's subtree :

SCORE  LINE   TOGGLE 
 76.96  73.81  80.12 


Module : 

SCORE  LINE   TOGGLE NAME            
 87.59  90.48  84.70 mshr_entry_ctrl 


Parent : 

SCORE  LINE   TOGGLE NAME            
 92.38 100.00  84.76 cache_ctrl_inst 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : cache_tb.dut.cache_ctrl_inst.genblk1[11].mshr_entry_ctrl_inst

             Line No.   Total   Covered  Percent
TOTAL                      210      155    73.81
ALWAYS             75       17       17   100.00
ALWAYS             97      135       88    65.19
ALWAYS            317       25       17    68.00
ALWAYS            368       22       22   100.00
ALWAYS            411       11       11   100.00

74                          always_ff @(posedge clk_i) begin
75         1/1                  if (rst_i) begin
76         1/1                      mshr_entry.state        <=  `SD ST_IDLE     ;
77         1/1                      mshr_entry.cmd          <=  `SD BUS_NONE    ;
78         1/1                      mshr_entry.req_addr     <=  `SD 'b0         ;
79         1/1                      mshr_entry.req_data     <=  `SD 'b0         ;
80         1/1                      mshr_entry.req_size     <=  `SD BYTE        ;
81         1/1                      mshr_entry.evict_addr   <=  `SD 'b0         ;
82         1/1                      mshr_entry.evict_data   <=  `SD 'b0         ;
83         1/1                      mshr_entry.evict_dirty  <=  `SD 1'b0        ;
84         1/1                      mshr_entry.link_idx     <=  `SD 'd0         ;
85         1/1                      mshr_entry.linked       <=  `SD 1'b0        ;
86         1/1                      mshr_entry.mem_tag      <=  `SD 'd0         ;
87         1/1                      mshr_cp_flag_o          <=  `SD 1'b0        ;
88         1/1                      mshr_cp_data_o          <=  `SD 'b0         ;
89                              end else begin
90         1/1                      mshr_entry              <=  `SD next_mshr_entry     ;
91         1/1                      mshr_cp_flag_o          <=  `SD next_mshr_cp_flag   ;
92         1/1                      mshr_cp_data_o          <=  `SD next_mshr_cp_data   ;
93                              end
94                          end
95                      
96                          always_comb begin
97         1/1                  next_mshr_entry.state       =   mshr_entry.state        ;
98         1/1                  next_mshr_entry.cmd         =   mshr_entry.cmd          ;
99         1/1                  next_mshr_entry.req_addr    =   mshr_entry.req_addr     ;
100        1/1                  next_mshr_entry.req_data    =   mshr_entry.req_data     ;
101        1/1                  next_mshr_entry.req_size    =   mshr_entry.req_size     ;
102        1/1                  next_mshr_entry.evict_addr  =   mshr_entry.evict_addr   ;
103        1/1                  next_mshr_entry.evict_data  =   mshr_entry.evict_data   ;
104        1/1                  next_mshr_entry.evict_dirty =   mshr_entry.evict_dirty  ;
105        1/1                  next_mshr_entry.link_idx    =   mshr_entry.link_idx     ;
106        1/1                  next_mshr_entry.linked      =   mshr_entry.linked       ;
107        1/1                  next_mshr_entry.mem_tag     =   mshr_entry.mem_tag      ;
108        1/1                  next_mshr_cp_flag           =   mshr_cp_flag_o          ;
109        1/1                  next_mshr_cp_data           =   mshr_cp_data_o          ;
110        1/1                  case (mshr_entry.state)
111                                 ST_IDLE     :   begin
112                                     // IF   there is a valid transaction on Processor Interface
113                                     // AND  the Processor Interface is granted to this entry
114                                     // AND  the cache_mem Interface is granted to this entry
115                                     // AND  it is a miss
116                                     // AND  the entry is selected to hold the new miss
117        1/1                          if ((proc2cache_i.command != BUS_NONE) && (dp_sel_i == 1'b1)
118                                     && (proc_grant_i == 1'b1)) begin
119                                         // IF   there is an older in-flight transaction to the same addreess
120                                         // ->   Wait for the completion of older miss to the same address
121        1/1                              if (mshr_hit_i && (cp_flag_i[mshr_hit_idx_i] == 1'b0)) begin
122        1/1                                  next_mshr_entry.state       =   ST_WAIT_DEPEND          ;
123        1/1                                  next_mshr_entry.link_idx    =   mshr_hit_idx_i          ;
124        1/1                                  next_mshr_entry.cmd         =   proc2cache_i.command    ;
125        1/1                                  next_mshr_entry.req_addr    =   proc2cache_i.addr       ;
126        1/1                                  next_mshr_entry.req_size    =   proc2cache_i.size       ;
127        1/1                                  if (proc2cache_i.command == BUS_STORE) begin
128        1/1                                      next_mshr_entry.req_data    =   proc2cache_i.data   ;
129                                             end
                        MISSING_ELSE
130                                         // IF   there is an older in-flight transaction that is in the middle of evicting the data block
131                                         // ->   Wait for the completion of write-back to memory
132        1/1                              end else if (evict_hit_i && (cp_flag_i[evict_hit_idx_i] == 1'b0)) begin
133        0/1     ==>                          next_mshr_entry.state       =   ST_WAIT_EVICT           ;
134        0/1     ==>                          next_mshr_entry.link_idx    =   evict_hit_idx_i         ;
135        0/1     ==>                          next_mshr_entry.cmd         =   proc2cache_i.command    ;
136        0/1     ==>                          next_mshr_entry.req_addr    =   proc2cache_i.addr       ;
137        0/1     ==>                          next_mshr_entry.req_size    =   proc2cache_i.size       ;
138        0/1     ==>                          if (proc2cache_i.command == BUS_STORE) begin
139        0/1     ==>                              next_mshr_entry.req_data    =   proc2cache_i.data   ;
140                                             end
                   ==>  MISSING_ELSE
141                                         // IF   it is a miss, and no dependency to older in-flight transactions.
142                                         // ->   Start miss handling
143        1/1                              end else if ((cache_mem_ctrl_i.req_hit == 1'b0) && (cache_mem_grant_i == 1'b1)) begin
144        1/1                                  next_mshr_entry.state       =   ST_RD_MEM               ;
145        1/1                                  next_mshr_entry.link_idx    =   'd0                     ;
146        1/1                                  next_mshr_entry.cmd         =   proc2cache_i.command    ;
147        1/1                                  next_mshr_entry.req_addr    =   proc2cache_i.addr       ;
148        1/1                                  next_mshr_entry.req_size    =   proc2cache_i.size       ;
149        1/1                                  if (proc2cache_i.command == BUS_STORE) begin
150        1/1                                      next_mshr_entry.req_data    =   proc2cache_i.data   ;
151                                             end
                        MISSING_ELSE
152                                         end
                   ==>  MISSING_ELSE
153                                     end
                        MISSING_ELSE
154        1/1                          next_mshr_cp_flag   =   1'b0    ;
155        1/1                          next_mshr_cp_data   =   'b0     ;
156                                 end
157                                 ST_WAIT_DEPEND  :   begin
158                                     // IF   the older transaction that the entry is linked to completed
159                                     // ->   Update the cache data
160        0/1     ==>                  if (cp_flag_i[mshr_entry.link_idx] == 1'b1) begin
161        0/1     ==>                      next_mshr_entry.state       =   ST_UPDATE   ;
162        0/1     ==>                      next_mshr_entry.link_idx    =   'd0         ;
163        0/1     ==>                      next_mshr_entry.req_data    =   cp_data_i[mshr_entry.link_idx];
164        0/1     ==>                      if (mshr_entry.cmd == BUS_STORE) begin
165        0/1     ==>                          case (mshr_entry.req_size)
166        0/1     ==>                              BYTE    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +:  8]    =   mshr_entry.req_data[ 7:0]   ;
167        0/1     ==>                              HALF    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +: 16]    =   mshr_entry.req_data[15:0]   ;
168        0/1     ==>                              WORD    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +: 32]    =   mshr_entry.req_data[31:0]   ;
169        0/1     ==>                              DOUBLE  :   next_mshr_entry.req_data                                    =   mshr_entry.req_data         ;
170        0/1     ==>                              default :   next_mshr_entry.req_data                                    =   mshr_entry.req_data         ;
171                                             endcase
172                                         end
                   ==>  MISSING_ELSE
173                                     end
                   ==>  MISSING_ELSE
174                                 end
175                                 ST_WAIT_EVICT   : begin
176                                     // IF   the older transaction that evicts the cache block completed
177                                     // ->   Read from Memory
178        0/1     ==>                  if (cp_flag_i[mshr_entry.link_idx] == 1'b1) begin
179        0/1     ==>                      next_mshr_entry.state       =   ST_RD_MEM   ;
180        0/1     ==>                      next_mshr_entry.link_idx    =   'd0         ;
181                                     end
                   ==>  MISSING_ELSE
182                                 end
183                                 ST_RD_MEM   :   begin
184                                     // IF   the read transaction is confirmed by Memory Interface
185                                     // ->   Wait for the data to return from Memory
186        1/1                          if ((memory_grant_i == 1'b1) && (mem2cache_i.response != 'd0)) begin
187        1/1                              next_mshr_entry.state       =   ST_WAIT_MEM             ;
188        1/1                              next_mshr_entry.mem_tag     =   mem2cache_i.response    ;
189                                     end
                        MISSING_ELSE
190                                 end
191                                 ST_WAIT_MEM :   begin
192                                     // IF   the data is returned from the Memory
193                                     // ->   Update the cache data
194        1/1                          if (mem2cache_i.tag == mshr_entry.mem_tag) begin
195        1/1                              next_mshr_entry.state       =   ST_UPDATE           ;
196        1/1                              next_mshr_entry.req_data    =   mem2cache_i.data    ;
197        1/1                              if (mshr_entry.cmd == BUS_STORE) begin
198        1/1                                  case (mshr_entry.req_size)
199        1/1                                      BYTE    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +:  8]    =   mshr_entry.req_data[ 7:0]   ;
200        0/1     ==>                              HALF    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +: 16]    =   mshr_entry.req_data[15:0]   ;
201        1/1                                      WORD    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +: 32]    =   mshr_entry.req_data[31:0]   ;
202        1/1                                      DOUBLE  :   next_mshr_entry.req_data                                    =   mshr_entry.req_data         ;
203        0/1     ==>                              default :   next_mshr_entry.req_data                                    =   mshr_entry.req_data         ;
204                                             endcase
205                                         end
                        MISSING_ELSE
206                                     end
                        MISSING_ELSE
207                                 end
208                                 ST_UPDATE   :   begin
209                                     // IF   the req interface is granted to this entry
210        1/1                          if (cache_mem_grant_i == 1'b1) begin
211                                         // IF   it is a load miss
212                                         // ->   Output data to processor
213        1/1                              if (mshr_entry.cmd == BUS_LOAD) begin
214        1/1                                  next_mshr_entry.state       =   ST_OUTPUT;
215        1/1                                  next_mshr_entry.evict_addr  =   cache_mem_ctrl_i.evict_addr ;
216        1/1                                  next_mshr_entry.evict_data  =   cache_mem_ctrl_i.evict_data ;
217        1/1                                  next_mshr_entry.evict_dirty =   cache_mem_ctrl_i.evict_dirty;
218                                         // IF   a dirty block is evicted
219                                         // ->   Write back the evicted block
220        1/1                              end else if (cache_mem_ctrl_i.evict_dirty == 1'b1) begin
221        1/1                                  next_mshr_entry.state       =   ST_EVICT;
222        1/1                                  next_mshr_entry.evict_addr  =   cache_mem_ctrl_i.evict_addr ;
223        1/1                                  next_mshr_entry.evict_data  =   cache_mem_ctrl_i.evict_data ;
224        1/1                                  next_mshr_entry.evict_dirty =   cache_mem_ctrl_i.evict_dirty;
225                                         // ELSE
226                                         // ->   Miss Handling Completed
227                                         end else begin
228        0/1     ==>                          next_mshr_entry.state       =   ST_IDLE             ;
229        0/1     ==>                          next_mshr_entry.cmd         =   BUS_NONE            ;
230        0/1     ==>                          next_mshr_entry.req_addr    =   'b0                 ;
231        0/1     ==>                          next_mshr_entry.req_data    =   'b0                 ;
232        0/1     ==>                          next_mshr_entry.req_size    =   BYTE                ;
233        0/1     ==>                          next_mshr_entry.evict_addr  =   'b0                 ;
234        0/1     ==>                          next_mshr_entry.evict_data  =   'b0                 ;
235        0/1     ==>                          next_mshr_entry.evict_dirty =   1'b0                ;
236        0/1     ==>                          next_mshr_entry.link_idx    =   'd0                 ;
237        0/1     ==>                          next_mshr_entry.mem_tag     =   'd0                 ;
238        0/1     ==>                          next_mshr_cp_flag           =   1'b1                ;
239        0/1     ==>                          next_mshr_cp_data           =   mshr_entry.req_data ;
240                                         end
241                                     end
                        MISSING_ELSE
242                                 end
243                                 ST_OUTPUT   :   begin
244                                     // IF   the Processor Interface is granted to this entry
245        1/1                          if (proc_grant_i == 1'b1) begin
246                                         // IF   the evicted block is dirty
247                                         // ->   Write back the evicted block
248        1/1                              if (mshr_entry.evict_dirty == 1'b1) begin
249        1/1                                  next_mshr_entry.state       =   ST_EVICT;
250                                         // ELSE
251                                         // ->   Miss Handling Completed
252                                         end else begin
253        0/1     ==>                          next_mshr_entry.state       =   ST_IDLE             ;
254        0/1     ==>                          next_mshr_entry.cmd         =   BUS_NONE            ;
255        0/1     ==>                          next_mshr_entry.req_addr    =   'b0                 ;
256        0/1     ==>                          next_mshr_entry.req_data    =   'b0                 ;
257        0/1     ==>                          next_mshr_entry.req_size    =   BYTE                ;
258        0/1     ==>                          next_mshr_entry.evict_addr  =   'b0                 ;
259        0/1     ==>                          next_mshr_entry.evict_data  =   'b0                 ;
260        0/1     ==>                          next_mshr_entry.evict_dirty =   1'b0                ;
261        0/1     ==>                          next_mshr_entry.link_idx    =   'd0                 ;
262        0/1     ==>                          next_mshr_entry.mem_tag     =   'd0                 ;
263        0/1     ==>                          next_mshr_cp_flag           =   1'b1                ;
264        0/1     ==>                          next_mshr_cp_data           =   mshr_entry.req_data ;
265                                         end
266                                     end
                        MISSING_ELSE
267                                 end
268                                 ST_EVICT    :   begin
269                                     // IF   the write back transaction to Memory is confirmed
270                                     // ->   Miss Handling Completed
271        1/1                          if ((memory_grant_i == 1'b1) && (mem2cache_i.response != 'd0)) begin
272        1/1                              next_mshr_entry.state       =   ST_IDLE             ;
273        1/1                              next_mshr_entry.cmd         =   BUS_NONE            ;
274        1/1                              next_mshr_entry.req_addr    =   'b0                 ;
275        1/1                              next_mshr_entry.req_data    =   'b0                 ;
276        1/1                              next_mshr_entry.req_size    =   BYTE                ;
277        1/1                              next_mshr_entry.evict_addr  =   'b0                 ;
278        1/1                              next_mshr_entry.evict_data  =   'b0                 ;
279        1/1                              next_mshr_entry.evict_dirty =   1'b0                ;
280        1/1                              next_mshr_entry.link_idx    =   'd0                 ;
281        1/1                              next_mshr_entry.mem_tag     =   'd0                 ;
282        1/1                              next_mshr_cp_flag           =   1'b1                ;
283        1/1                              next_mshr_cp_data           =   mshr_entry.req_data ;
284                                     end
                        MISSING_ELSE
285                                 end
286                                 default     :   begin
287        1/1                          next_mshr_entry.state       =   ST_IDLE     ;
288        1/1                          next_mshr_entry.cmd         =   BUS_NONE    ;
289        1/1                          next_mshr_entry.req_addr    =   'b0         ;
290        1/1                          next_mshr_entry.req_data    =   'b0         ;
291        1/1                          next_mshr_entry.req_size    =   BYTE        ;
292        1/1                          next_mshr_entry.evict_addr  =   'b0         ;
293        1/1                          next_mshr_entry.evict_data  =   'b0         ;
294        1/1                          next_mshr_entry.evict_dirty =   1'b0        ;
295        1/1                          next_mshr_entry.link_idx    =   'd0         ;
296        1/1                          next_mshr_entry.mem_tag     =   'd0         ;
297        1/1                          next_mshr_cp_flag           =   1'b0        ;
298        1/1                          next_mshr_cp_data           =   'd0         ;
299                                 end
300                             endcase
301                     
302        1/1                  if (next_mshr_entry.state == ST_IDLE) begin
303        1/1                      next_mshr_entry.linked  =   1'b0;
304        1/1                  end else if ((mshr_hit_i == 1'b1) && (mshr_hit_idx_i == mshr_entry_idx_i)) begin
305        1/1                      next_mshr_entry.linked  =   1'b1;
306                             end
                        MISSING_ELSE
307                         end
308                     
309                     // --------------------------------------------------------------------
310                     // MSHR entry output
311                     // --------------------------------------------------------------------
312                         assign  mshr_entry_o    =   mshr_entry  ;
313                     // --------------------------------------------------------------------
314                     // Processor Interface
315                     // --------------------------------------------------------------------
316                         always_comb begin
317        1/1                  mshr_proc_o.response    =   'd0 ;
318        1/1                  mshr_proc_o.data        =   'b0 ;
319        1/1                  mshr_proc_o.tag         =   'd0 ;
320        1/1                  case (mshr_entry.state)
321                                 ST_IDLE     :   begin
322                                     // IF   the processor request is allocated to this entry
323        1/1                          if ((proc2cache_i.command != BUS_NONE) && (dp_sel_i == 1'b1)) begin
324                                         // IF   The Processor Interface is granted to this entry
325                                         // AND  there is a dependency to older in-flight transaction
326                                         // ->   Confirm the request
327        1/1                              if (((mshr_hit_i && (cp_flag_i[mshr_hit_idx_i] == 1'b0))
328                                         || (evict_hit_i && (cp_flag_i[evict_hit_idx_i] == 1'b0)))) begin
329        1/1                                  mshr_proc_o.response    =   mshr_entry_idx_i;
330                                         // IF   The Processor Interface is granted to this entry
331                                         // AND  The cache_mem Interface is granted to this entry
332                                         // ->   Confirm the request 
333        1/1                              end else if (cache_mem_grant_i == 1'b1) begin
334        1/1                                  mshr_proc_o.response    =   mshr_entry_idx_i;
335                                             // IF   it is a load hit
336                                             // ->   Output data and tag
337        1/1                                  if (cache_mem_ctrl_i.req_hit == 1'b1 && proc2cache_i.command == BUS_LOAD) begin
338        0/1     ==>                              mshr_proc_o.tag     =   mshr_entry_idx_i;
339        0/1     ==>                              case (proc2cache_i.size)
340        0/1     ==>                                  BYTE    :   mshr_proc_o.data    =   {56'b0,cache_mem_ctrl_i.req_data_out[proc2cache_i.addr[2:0]+: 8]};
341        0/1     ==>                                  HALF    :   mshr_proc_o.data    =   {48'b0,cache_mem_ctrl_i.req_data_out[proc2cache_i.addr[2:0]+:16]};
342        0/1     ==>                                  WORD    :   mshr_proc_o.data    =   {32'b0,cache_mem_ctrl_i.req_data_out[proc2cache_i.addr[2:0]+:32]};
343        0/1     ==>                                  DOUBLE  :   mshr_proc_o.data    =   cache_mem_ctrl_i.req_data_out;
344        0/1     ==>                                  default :   mshr_proc_o.data    =   cache_mem_ctrl_i.req_data_out;
345                                                 endcase
346                                             end
                        MISSING_ELSE
347                                         end
                        MISSING_ELSE
348                                     end
                        MISSING_ELSE
349                                 end
350                                 ST_OUTPUT   :   begin
351        1/1                          mshr_proc_o.response    =   'd0                 ;
352        1/1                          mshr_proc_o.tag         =   mshr_entry_idx_i    ;
353        1/1                          case (mshr_entry.req_size)
354        1/1                              BYTE    :   mshr_proc_o.data    =   {56'b0,mshr_entry.req_data[mshr_entry.req_addr[2:0]+: 8]};
355        1/1                              HALF    :   mshr_proc_o.data    =   {48'b0,mshr_entry.req_data[mshr_entry.req_addr[2:0]+:16]};
356        1/1                              WORD    :   mshr_proc_o.data    =   {32'b0,mshr_entry.req_data[mshr_entry.req_addr[2:0]+:32]};
357        1/1                              DOUBLE  :   mshr_proc_o.data    =   mshr_entry.req_data;
358        0/1     ==>                      default :   mshr_proc_o.data    =   mshr_entry.req_data;
359                                     endcase
360                                 end
                        MISSING_DEFAULT
361                             endcase
362                         end
363                     
364                     // --------------------------------------------------------------------
365                     // cache_mem Interface
366                     // --------------------------------------------------------------------
367                         always_comb begin
368        1/1                  mshr_cache_mem_o.req_cmd        =   REQ_NONE;
369        1/1                  mshr_cache_mem_o.req_addr       =   'b0     ;
370        1/1                  mshr_cache_mem_o.req_data_in    =   'b0     ;
371        1/1                  case (mshr_entry.state)
372                                 ST_IDLE:    begin
373                                     // IF   the processor request is allocated to this entry
374        1/1                          if (dp_sel_i == 1'b1) begin
375        1/1                              case (proc2cache_i.command)
376                                             BUS_LOAD    :   begin
377        1/1                                      mshr_cache_mem_o.req_cmd        =   REQ_LOAD                        ;
378        1/1                                      mshr_cache_mem_o.req_addr       =   proc2cache_i.addr               ;
379        1/1                                      mshr_cache_mem_o.req_data_in    =   cache_mem_ctrl_i.req_data_out   ;
380                                             end
381                                             BUS_STORE   :   begin
382        1/1                                      mshr_cache_mem_o.req_cmd        =   REQ_STORE                       ;
383        1/1                                      mshr_cache_mem_o.req_addr       =   proc2cache_i.addr               ;
384        1/1                                      mshr_cache_mem_o.req_data_in    =   cache_mem_ctrl_i.req_data_out   ;
385        1/1                                      case (proc2cache_i.size)
386        1/1                                          BYTE    :   mshr_cache_mem_o.req_data_in[proc2cache_i.addr[2:0] +:  8]  =   proc2cache_i.data[ 7:0] ;
387        1/1                                          HALF    :   mshr_cache_mem_o.req_data_in[proc2cache_i.addr[2:0] +: 16]  =   proc2cache_i.data[15:0] ;
388        1/1                                          WORD    :   mshr_cache_mem_o.req_data_in[proc2cache_i.addr[2:0] +: 32]  =   proc2cache_i.data[31:0] ;
389        1/1                                          DOUBLE  :   mshr_cache_mem_o.req_data_in                                =   proc2cache_i.data       ;
                   ==>  MISSING_DEFAULT
390                                                 endcase
391                                             end    
                        MISSING_DEFAULT
392                                         endcase
393                                     end
                        MISSING_ELSE
394                                 end
395                                 ST_UPDATE:  begin
396        1/1                          if (mshr_entry.cmd == BUS_LOAD) begin
397        1/1                              mshr_cache_mem_o.req_cmd    =   REQ_LOAD_MISS       ;
398                                     end else begin
399        1/1                              mshr_cache_mem_o.req_cmd    =   REQ_STORE_MISS      ;
400                                     end
401        1/1                          mshr_cache_mem_o.req_addr       =   mshr_entry.req_addr ;
402        1/1                          mshr_cache_mem_o.req_data_in    =   mshr_entry.req_data ;
403                                 end
                        MISSING_DEFAULT
404                             endcase
405                         end
406                     
407                     // --------------------------------------------------------------------
408                     // Memory Interface
409                     // --------------------------------------------------------------------
410                         always_comb begin
411        1/1                  mshr_memory_o.addr      =   {mshr_entry.req_addr[C_XLEN-1:C_CACHE_OFFSET_WIDTH], {C_CACHE_OFFSET_WIDTH{1'b0}}};
412        1/1                  mshr_memory_o.size      =   DOUBLE              ;
413        1/1                  mshr_memory_o.command   =   BUS_NONE            ;
414        1/1                  mshr_memory_o.data      =   'd0 ;
415        1/1                  case (mshr_entry.state)
416                                 ST_RD_MEM   :   begin
417        1/1                          mshr_memory_o.data      =   'd0 ;
418        1/1                          mshr_memory_o.addr      =   {mshr_entry.req_addr[C_XLEN-1:C_CACHE_OFFSET_WIDTH], {C_CACHE_OFFSET_WIDTH{1'b0}}};
419        1/1                          mshr_memory_o.command   =   BUS_LOAD;
420                                 end
421                                 ST_EVICT    :   begin
422        1/1                          mshr_memory_o.data      =   mshr_entry.evict_data;
423        1/1                          mshr_memory_o.addr      =   {mshr_entry.evict_addr[C_XLEN-1:C_CACHE_OFFSET_WIDTH], {C_CACHE_OFFSET_WIDTH{1'b0}}};
424        1/1                          mshr_memory_o.command   =   BUS_STORE;
425                                 end
                        MISSING_DEFAULT

-------------------------------------------------------------------------------
Toggle Coverage for Instance : cache_tb.dut.cache_ctrl_inst.genblk1[11].mshr_entry_ctrl_inst
                Total Covered Percent 
Totals          72    36      50.00   
Total Bits      4844  3881    80.12   
Total Bits 0->1 2422  1940    80.10   
Total Bits 1->0 2422  1941    80.14   

                                
Ports          48   24   50.00  
Port Bits      3878 3127 80.63  
Port Bits 0->1 1939 1563 80.61  
Port Bits 1->0 1939 1564 80.66  

                                
Signals          24  12  50.00  
Signal Bits      966 754 78.05  
Signal Bits 0->1 483 377 78.05  
Signal Bits 1->0 483 377 78.05  

Port Details
                                     Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i                                Yes    Yes         Yes         INPUT     
rst_i                                No     Yes         No          INPUT     
mshr_entry_idx_i[3:0]                No     No          No          INPUT     
mshr_entry_o.mem_tag[3:0]            Yes    Yes         Yes         OUTPUT    
mshr_entry_o.linked                  No     No          No          OUTPUT    
mshr_entry_o.link_idx[3:0]           No     No          No          OUTPUT    
mshr_entry_o.evict_dirty             Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_data[0]           No     No          No          OUTPUT    
mshr_entry_o.evict_data[10:1]        Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_data[11]          No     No          No          OUTPUT    
mshr_entry_o.evict_data[16:12]       Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_data[17]          No     No          No          OUTPUT    
mshr_entry_o.evict_data[63:18]       Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_addr[2:0]         No     No          No          OUTPUT    
mshr_entry_o.evict_addr[15:3]        Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_addr[31:16]       No     No          No          OUTPUT    
mshr_entry_o.req_size[1:0]           Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_data[27:0]          Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_data[28]            No     No          No          OUTPUT    
mshr_entry_o.req_data[36:29]         Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_data[38:37]         No     No          No          OUTPUT    
mshr_entry_o.req_data[49:39]         Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_data[50]            No     No          No          OUTPUT    
mshr_entry_o.req_data[51]            Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_data[53:52]         No     No          No          OUTPUT    
mshr_entry_o.req_data[59:54]         Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_data[61:60]         No     No          No          OUTPUT    
mshr_entry_o.req_data[63:62]         Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_addr[15:0]          Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_addr[31:16]         No     No          No          OUTPUT    
mshr_entry_o.cmd[1:0]                Yes    Yes         Yes         OUTPUT    
mshr_entry_o.state[2:0]              Yes    Yes         Yes         OUTPUT    
proc_grant_i                         Yes    Yes         Yes         INPUT     
proc2cache_i.command[1:0]            Yes    Yes         Yes         INPUT     
proc2cache_i.size[1:0]               Yes    Yes         Yes         INPUT     
proc2cache_i.data[63:0]              Yes    Yes         Yes         INPUT     
proc2cache_i.addr[15:0]              Yes    Yes         Yes         INPUT     
proc2cache_i.addr[31:16]             No     No          No          INPUT     
mshr_proc_o.tag[1:0]                 Yes    Yes         Yes         OUTPUT    
mshr_proc_o.tag[2]                   No     No          No          OUTPUT    
mshr_proc_o.tag[3]                   Yes    Yes         Yes         OUTPUT    
mshr_proc_o.data[4:0]                No     No          No          OUTPUT    
mshr_proc_o.data[9:5]                Yes    Yes         Yes         OUTPUT    
mshr_proc_o.data[13:10]              No     No          No          OUTPUT    
mshr_proc_o.data[15:14]              Yes    Yes         Yes         OUTPUT    
mshr_proc_o.data[63:16]              No     No          No          OUTPUT    
mshr_proc_o.response[1:0]            Yes    Yes         Yes         OUTPUT    
mshr_proc_o.response[2]              No     No          No          OUTPUT    
mshr_proc_o.response[3]              Yes    Yes         Yes         OUTPUT    
cache_mem_grant_i                    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.evict_data[63:0]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.evict_addr[2:0]     No     No          No          INPUT     
cache_mem_ctrl_i.evict_addr[15:3]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.evict_addr[31:16]   No     No          No          INPUT     
cache_mem_ctrl_i.evict_dirty         Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[4:0]   Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[6:5]   No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[8:7]   Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[11:9]  No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[13:12] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[15:14] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[25:16] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[26]    No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[31:27] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[33:32] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[34]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[37:35] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[38]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[41:39] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[42]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[45:43] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[47:46] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[50:48] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[52:51] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[54:53] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[58:55] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[60:59] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[63:61] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_hit             Yes    Yes         Yes         INPUT     
mshr_cache_mem_o.req_data_in[49:0]   Yes    Yes         Yes         OUTPUT    
mshr_cache_mem_o.req_data_in[50]     No     No          No          OUTPUT    
mshr_cache_mem_o.req_data_in[52:51]  Yes    Yes         Yes         OUTPUT    
mshr_cache_mem_o.req_data_in[53]     No     No          No          OUTPUT    
mshr_cache_mem_o.req_data_in[59:54]  Yes    Yes         Yes         OUTPUT    
mshr_cache_mem_o.req_data_in[60]     No     No          No          OUTPUT    
mshr_cache_mem_o.req_data_in[63:61]  Yes    Yes         Yes         OUTPUT    
mshr_cache_mem_o.req_addr[15:0]      Yes    Yes         Yes         OUTPUT    
mshr_cache_mem_o.req_addr[31:16]     No     No          No          OUTPUT    
mshr_cache_mem_o.req_cmd[2:0]        Yes    Yes         Yes         OUTPUT    
memory_grant_i                       Yes    Yes         Yes         INPUT     
mem2cache_i.tag[3:0]                 Yes    Yes         Yes         INPUT     
mem2cache_i.data[63:0]               Yes    Yes         Yes         INPUT     
mem2cache_i.response[3:0]            Yes    Yes         Yes         INPUT     
mshr_memory_o.command[1:0]           Yes    Yes         Yes         OUTPUT    
mshr_memory_o.size[1:0]              No     No          No          OUTPUT    
mshr_memory_o.data[0]                No     No          No          OUTPUT    
mshr_memory_o.data[10:1]             Yes    Yes         Yes         OUTPUT    
mshr_memory_o.data[11]               No     No          No          OUTPUT    
mshr_memory_o.data[16:12]            Yes    Yes         Yes         OUTPUT    
mshr_memory_o.data[17]               No     No          No          OUTPUT    
mshr_memory_o.data[63:18]            Yes    Yes         Yes         OUTPUT    
mshr_memory_o.addr[2:0]              No     No          No          OUTPUT    
mshr_memory_o.addr[15:3]             Yes    Yes         Yes         OUTPUT    
mshr_memory_o.addr[31:16]            No     No          No          OUTPUT    
mshr_hit_i                           Yes    Yes         Yes         INPUT     
mshr_hit_idx_i[3:0]                  Yes    Yes         Yes         INPUT     
evict_hit_i                          No     No          No          INPUT     
evict_hit_idx_i[3:0]                 No     No          No          INPUT     
dp_sel_i                             Yes    Yes         Yes         INPUT     
mshr_cp_flag_o                       Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[27:0]                 Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[28]                   No     No          No          OUTPUT    
mshr_cp_data_o[36:29]                Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[38:37]                No     No          No          OUTPUT    
mshr_cp_data_o[49:39]                Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[50]                   No     No          No          OUTPUT    
mshr_cp_data_o[51]                   Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[53:52]                No     No          No          OUTPUT    
mshr_cp_data_o[59:54]                Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[61:60]                No     No          No          OUTPUT    
mshr_cp_data_o[63:62]                Yes    Yes         Yes         OUTPUT    
cp_flag_i[0]                         No     No          No          INPUT     
cp_flag_i[15:1]                      Yes    Yes         Yes         INPUT     
cp_data_i[8:1][63:0]                 Yes    Yes         Yes         INPUT     
cp_data_i[9][44:0]                   Yes    Yes         Yes         INPUT     
cp_data_i[9][63:46]                  Yes    Yes         Yes         INPUT     
cp_data_i[10][30:1]                  Yes    Yes         Yes         INPUT     
cp_data_i[10][36:32]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][41:40]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][45]                    Yes    Yes         Yes         INPUT     
cp_data_i[10][49:47]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][52:51]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][56:55]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][60]                    Yes    Yes         Yes         INPUT     
cp_data_i[10][62]                    Yes    Yes         Yes         INPUT     
cp_data_i[11][27:0]                  Yes    Yes         Yes         INPUT     
cp_data_i[11][36:29]                 Yes    Yes         Yes         INPUT     
cp_data_i[11][49:39]                 Yes    Yes         Yes         INPUT     
cp_data_i[11][51]                    Yes    Yes         Yes         INPUT     
cp_data_i[11][59:54]                 Yes    Yes         Yes         INPUT     
cp_data_i[11][63:62]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][4:0]                   Yes    Yes         Yes         INPUT     
cp_data_i[12][27:6]                  Yes    Yes         Yes         INPUT     
cp_data_i[12][31:29]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][35:33]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][39]                    Yes    Yes         Yes         INPUT     
cp_data_i[12][44:43]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][48:46]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][50]                    Yes    Yes         Yes         INPUT     
cp_data_i[12][54]                    Yes    Yes         Yes         INPUT     
cp_data_i[12][58:57]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][61]                    Yes    Yes         Yes         INPUT     
cp_data_i[13][17:0]                  Yes    Yes         Yes         INPUT     
cp_data_i[13][46:19]                 Yes    Yes         Yes         INPUT     
cp_data_i[13][49]                    Yes    Yes         Yes         INPUT     
cp_data_i[13][56:51]                 Yes    Yes         Yes         INPUT     
cp_data_i[13][63:58]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][14:1]                  Yes    Yes         Yes         INPUT     
cp_data_i[14][19:16]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][21]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][24:23]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][27]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][32:30]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][37:35]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][39]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][41]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][43]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][46:45]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][51:49]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][59:53]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][62:61]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][15:0]                  Yes    Yes         Yes         INPUT     
cp_data_i[15][37:17]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][40:39]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][42]                    Yes    Yes         Yes         INPUT     
cp_data_i[15][45:44]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][48:47]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][53:51]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][55]                    Yes    Yes         Yes         INPUT     
cp_data_i[15][63:57]                 Yes    Yes         Yes         INPUT     
Other bits of cp_data_i[15:0][63:0]  No     No          No          INPUT     

Signal Details
                                  Toggle Toggle 1->0 Toggle 0->1 
mshr_entry.mem_tag[3:0]           Yes    Yes         Yes         
mshr_entry.linked                 No     No          No          
mshr_entry.link_idx[3:0]          No     No          No          
mshr_entry.evict_dirty            Yes    Yes         Yes         
mshr_entry.evict_data[0]          No     No          No          
mshr_entry.evict_data[10:1]       Yes    Yes         Yes         
mshr_entry.evict_data[11]         No     No          No          
mshr_entry.evict_data[16:12]      Yes    Yes         Yes         
mshr_entry.evict_data[17]         No     No          No          
mshr_entry.evict_data[63:18]      Yes    Yes         Yes         
mshr_entry.evict_addr[2:0]        No     No          No          
mshr_entry.evict_addr[15:3]       Yes    Yes         Yes         
mshr_entry.evict_addr[31:16]      No     No          No          
mshr_entry.req_size[1:0]          Yes    Yes         Yes         
mshr_entry.req_data[27:0]         Yes    Yes         Yes         
mshr_entry.req_data[28]           No     No          No          
mshr_entry.req_data[36:29]        Yes    Yes         Yes         
mshr_entry.req_data[38:37]        No     No          No          
mshr_entry.req_data[49:39]        Yes    Yes         Yes         
mshr_entry.req_data[50]           No     No          No          
mshr_entry.req_data[51]           Yes    Yes         Yes         
mshr_entry.req_data[53:52]        No     No          No          
mshr_entry.req_data[59:54]        Yes    Yes         Yes         
mshr_entry.req_data[61:60]        No     No          No          
mshr_entry.req_data[63:62]        Yes    Yes         Yes         
mshr_entry.req_addr[15:0]         Yes    Yes         Yes         
mshr_entry.req_addr[31:16]        No     No          No          
mshr_entry.cmd[1:0]               Yes    Yes         Yes         
mshr_entry.state[2:0]             Yes    Yes         Yes         
next_mshr_entry.mem_tag[3:0]      Yes    Yes         Yes         
next_mshr_entry.linked            Yes    Yes         Yes         
next_mshr_entry.link_idx[0]       No     No          No          
next_mshr_entry.link_idx[1]       Yes    Yes         Yes         
next_mshr_entry.link_idx[2]       No     No          No          
next_mshr_entry.link_idx[3]       Yes    Yes         Yes         
next_mshr_entry.evict_dirty       Yes    Yes         Yes         
next_mshr_entry.evict_data[0]     No     No          No          
next_mshr_entry.evict_data[10:1]  Yes    Yes         Yes         
next_mshr_entry.evict_data[11]    No     No          No          
next_mshr_entry.evict_data[16:12] Yes    Yes         Yes         
next_mshr_entry.evict_data[17]    No     No          No          
next_mshr_entry.evict_data[63:18] Yes    Yes         Yes         
next_mshr_entry.evict_addr[2:0]   No     No          No          
next_mshr_entry.evict_addr[15:3]  Yes    Yes         Yes         
next_mshr_entry.evict_addr[31:16] No     No          No          
next_mshr_entry.req_size[1:0]     Yes    Yes         Yes         
next_mshr_entry.req_data[36:0]    Yes    Yes         Yes         
next_mshr_entry.req_data[38:37]   No     No          No          
next_mshr_entry.req_data[49:39]   Yes    Yes         Yes         
next_mshr_entry.req_data[50]      No     No          No          
next_mshr_entry.req_data[51]      Yes    Yes         Yes         
next_mshr_entry.req_data[53:52]   No     No          No          
next_mshr_entry.req_data[59:54]   Yes    Yes         Yes         
next_mshr_entry.req_data[61:60]   No     No          No          
next_mshr_entry.req_data[63:62]   Yes    Yes         Yes         
next_mshr_entry.req_addr[15:0]    Yes    Yes         Yes         
next_mshr_entry.req_addr[31:16]   No     No          No          
next_mshr_entry.cmd[1:0]          Yes    Yes         Yes         
next_mshr_entry.state[2:0]        Yes    Yes         Yes         
next_mshr_cp_flag                 Yes    Yes         Yes         
next_mshr_cp_data[27:0]           Yes    Yes         Yes         
next_mshr_cp_data[28]             No     No          No          
next_mshr_cp_data[36:29]          Yes    Yes         Yes         
next_mshr_cp_data[38:37]          No     No          No          
next_mshr_cp_data[49:39]          Yes    Yes         Yes         
next_mshr_cp_data[50]             No     No          No          
next_mshr_cp_data[51]             Yes    Yes         Yes         
next_mshr_cp_data[53:52]          No     No          No          
next_mshr_cp_data[59:54]          Yes    Yes         Yes         
next_mshr_cp_data[61:60]          No     No          No          
next_mshr_cp_data[63:62]          Yes    Yes         Yes         


-------------------------------------------------------------------------------
===============================================================================
Module Instance : cache_tb.dut.cache_ctrl_inst.genblk1[10].mshr_entry_ctrl_inst
===============================================================================

Instance :

SCORE  LINE   TOGGLE 
 78.87  79.52  78.22 


Instance's subtree :

SCORE  LINE   TOGGLE 
 78.87  79.52  78.22 


Module : 

SCORE  LINE   TOGGLE NAME            
 87.59  90.48  84.70 mshr_entry_ctrl 


Parent : 

SCORE  LINE   TOGGLE NAME            
 92.38 100.00  84.76 cache_ctrl_inst 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : cache_tb.dut.cache_ctrl_inst.genblk1[10].mshr_entry_ctrl_inst

             Line No.   Total   Covered  Percent
TOTAL                      210      167    79.52
ALWAYS             75       17       17   100.00
ALWAYS             97      135      100    74.07
ALWAYS            317       25       17    68.00
ALWAYS            368       22       22   100.00
ALWAYS            411       11       11   100.00

74                          always_ff @(posedge clk_i) begin
75         1/1                  if (rst_i) begin
76         1/1                      mshr_entry.state        <=  `SD ST_IDLE     ;
77         1/1                      mshr_entry.cmd          <=  `SD BUS_NONE    ;
78         1/1                      mshr_entry.req_addr     <=  `SD 'b0         ;
79         1/1                      mshr_entry.req_data     <=  `SD 'b0         ;
80         1/1                      mshr_entry.req_size     <=  `SD BYTE        ;
81         1/1                      mshr_entry.evict_addr   <=  `SD 'b0         ;
82         1/1                      mshr_entry.evict_data   <=  `SD 'b0         ;
83         1/1                      mshr_entry.evict_dirty  <=  `SD 1'b0        ;
84         1/1                      mshr_entry.link_idx     <=  `SD 'd0         ;
85         1/1                      mshr_entry.linked       <=  `SD 1'b0        ;
86         1/1                      mshr_entry.mem_tag      <=  `SD 'd0         ;
87         1/1                      mshr_cp_flag_o          <=  `SD 1'b0        ;
88         1/1                      mshr_cp_data_o          <=  `SD 'b0         ;
89                              end else begin
90         1/1                      mshr_entry              <=  `SD next_mshr_entry     ;
91         1/1                      mshr_cp_flag_o          <=  `SD next_mshr_cp_flag   ;
92         1/1                      mshr_cp_data_o          <=  `SD next_mshr_cp_data   ;
93                              end
94                          end
95                      
96                          always_comb begin
97         1/1                  next_mshr_entry.state       =   mshr_entry.state        ;
98         1/1                  next_mshr_entry.cmd         =   mshr_entry.cmd          ;
99         1/1                  next_mshr_entry.req_addr    =   mshr_entry.req_addr     ;
100        1/1                  next_mshr_entry.req_data    =   mshr_entry.req_data     ;
101        1/1                  next_mshr_entry.req_size    =   mshr_entry.req_size     ;
102        1/1                  next_mshr_entry.evict_addr  =   mshr_entry.evict_addr   ;
103        1/1                  next_mshr_entry.evict_data  =   mshr_entry.evict_data   ;
104        1/1                  next_mshr_entry.evict_dirty =   mshr_entry.evict_dirty  ;
105        1/1                  next_mshr_entry.link_idx    =   mshr_entry.link_idx     ;
106        1/1                  next_mshr_entry.linked      =   mshr_entry.linked       ;
107        1/1                  next_mshr_entry.mem_tag     =   mshr_entry.mem_tag      ;
108        1/1                  next_mshr_cp_flag           =   mshr_cp_flag_o          ;
109        1/1                  next_mshr_cp_data           =   mshr_cp_data_o          ;
110        1/1                  case (mshr_entry.state)
111                                 ST_IDLE     :   begin
112                                     // IF   there is a valid transaction on Processor Interface
113                                     // AND  the Processor Interface is granted to this entry
114                                     // AND  the cache_mem Interface is granted to this entry
115                                     // AND  it is a miss
116                                     // AND  the entry is selected to hold the new miss
117        1/1                          if ((proc2cache_i.command != BUS_NONE) && (dp_sel_i == 1'b1)
118                                     && (proc_grant_i == 1'b1)) begin
119                                         // IF   there is an older in-flight transaction to the same addreess
120                                         // ->   Wait for the completion of older miss to the same address
121        1/1                              if (mshr_hit_i && (cp_flag_i[mshr_hit_idx_i] == 1'b0)) begin
122        1/1                                  next_mshr_entry.state       =   ST_WAIT_DEPEND          ;
123        1/1                                  next_mshr_entry.link_idx    =   mshr_hit_idx_i          ;
124        1/1                                  next_mshr_entry.cmd         =   proc2cache_i.command    ;
125        1/1                                  next_mshr_entry.req_addr    =   proc2cache_i.addr       ;
126        1/1                                  next_mshr_entry.req_size    =   proc2cache_i.size       ;
127        1/1                                  if (proc2cache_i.command == BUS_STORE) begin
128        1/1                                      next_mshr_entry.req_data    =   proc2cache_i.data   ;
129                                             end
                        MISSING_ELSE
130                                         // IF   there is an older in-flight transaction that is in the middle of evicting the data block
131                                         // ->   Wait for the completion of write-back to memory
132        1/1                              end else if (evict_hit_i && (cp_flag_i[evict_hit_idx_i] == 1'b0)) begin
133        0/1     ==>                          next_mshr_entry.state       =   ST_WAIT_EVICT           ;
134        0/1     ==>                          next_mshr_entry.link_idx    =   evict_hit_idx_i         ;
135        0/1     ==>                          next_mshr_entry.cmd         =   proc2cache_i.command    ;
136        0/1     ==>                          next_mshr_entry.req_addr    =   proc2cache_i.addr       ;
137        0/1     ==>                          next_mshr_entry.req_size    =   proc2cache_i.size       ;
138        0/1     ==>                          if (proc2cache_i.command == BUS_STORE) begin
139        0/1     ==>                              next_mshr_entry.req_data    =   proc2cache_i.data   ;
140                                             end
                   ==>  MISSING_ELSE
141                                         // IF   it is a miss, and no dependency to older in-flight transactions.
142                                         // ->   Start miss handling
143        1/1                              end else if ((cache_mem_ctrl_i.req_hit == 1'b0) && (cache_mem_grant_i == 1'b1)) begin
144        1/1                                  next_mshr_entry.state       =   ST_RD_MEM               ;
145        1/1                                  next_mshr_entry.link_idx    =   'd0                     ;
146        1/1                                  next_mshr_entry.cmd         =   proc2cache_i.command    ;
147        1/1                                  next_mshr_entry.req_addr    =   proc2cache_i.addr       ;
148        1/1                                  next_mshr_entry.req_size    =   proc2cache_i.size       ;
149        1/1                                  if (proc2cache_i.command == BUS_STORE) begin
150        1/1                                      next_mshr_entry.req_data    =   proc2cache_i.data   ;
151                                             end
                        MISSING_ELSE
152                                         end
                   ==>  MISSING_ELSE
153                                     end
                        MISSING_ELSE
154        1/1                          next_mshr_cp_flag   =   1'b0    ;
155        1/1                          next_mshr_cp_data   =   'b0     ;
156                                 end
157                                 ST_WAIT_DEPEND  :   begin
158                                     // IF   the older transaction that the entry is linked to completed
159                                     // ->   Update the cache data
160        0/1     ==>                  if (cp_flag_i[mshr_entry.link_idx] == 1'b1) begin
161        0/1     ==>                      next_mshr_entry.state       =   ST_UPDATE   ;
162        0/1     ==>                      next_mshr_entry.link_idx    =   'd0         ;
163        0/1     ==>                      next_mshr_entry.req_data    =   cp_data_i[mshr_entry.link_idx];
164        0/1     ==>                      if (mshr_entry.cmd == BUS_STORE) begin
165        0/1     ==>                          case (mshr_entry.req_size)
166        0/1     ==>                              BYTE    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +:  8]    =   mshr_entry.req_data[ 7:0]   ;
167        0/1     ==>                              HALF    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +: 16]    =   mshr_entry.req_data[15:0]   ;
168        0/1     ==>                              WORD    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +: 32]    =   mshr_entry.req_data[31:0]   ;
169        0/1     ==>                              DOUBLE  :   next_mshr_entry.req_data                                    =   mshr_entry.req_data         ;
170        0/1     ==>                              default :   next_mshr_entry.req_data                                    =   mshr_entry.req_data         ;
171                                             endcase
172                                         end
                   ==>  MISSING_ELSE
173                                     end
                   ==>  MISSING_ELSE
174                                 end
175                                 ST_WAIT_EVICT   : begin
176                                     // IF   the older transaction that evicts the cache block completed
177                                     // ->   Read from Memory
178        0/1     ==>                  if (cp_flag_i[mshr_entry.link_idx] == 1'b1) begin
179        0/1     ==>                      next_mshr_entry.state       =   ST_RD_MEM   ;
180        0/1     ==>                      next_mshr_entry.link_idx    =   'd0         ;
181                                     end
                   ==>  MISSING_ELSE
182                                 end
183                                 ST_RD_MEM   :   begin
184                                     // IF   the read transaction is confirmed by Memory Interface
185                                     // ->   Wait for the data to return from Memory
186        1/1                          if ((memory_grant_i == 1'b1) && (mem2cache_i.response != 'd0)) begin
187        1/1                              next_mshr_entry.state       =   ST_WAIT_MEM             ;
188        1/1                              next_mshr_entry.mem_tag     =   mem2cache_i.response    ;
189                                     end
                        MISSING_ELSE
190                                 end
191                                 ST_WAIT_MEM :   begin
192                                     // IF   the data is returned from the Memory
193                                     // ->   Update the cache data
194        1/1                          if (mem2cache_i.tag == mshr_entry.mem_tag) begin
195        1/1                              next_mshr_entry.state       =   ST_UPDATE           ;
196        1/1                              next_mshr_entry.req_data    =   mem2cache_i.data    ;
197        1/1                              if (mshr_entry.cmd == BUS_STORE) begin
198        1/1                                  case (mshr_entry.req_size)
199        1/1                                      BYTE    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +:  8]    =   mshr_entry.req_data[ 7:0]   ;
200        1/1                                      HALF    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +: 16]    =   mshr_entry.req_data[15:0]   ;
201        1/1                                      WORD    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +: 32]    =   mshr_entry.req_data[31:0]   ;
202        0/1     ==>                              DOUBLE  :   next_mshr_entry.req_data                                    =   mshr_entry.req_data         ;
203        0/1     ==>                              default :   next_mshr_entry.req_data                                    =   mshr_entry.req_data         ;
204                                             endcase
205                                         end
                        MISSING_ELSE
206                                     end
                        MISSING_ELSE
207                                 end
208                                 ST_UPDATE   :   begin
209                                     // IF   the req interface is granted to this entry
210        1/1                          if (cache_mem_grant_i == 1'b1) begin
211                                         // IF   it is a load miss
212                                         // ->   Output data to processor
213        1/1                              if (mshr_entry.cmd == BUS_LOAD) begin
214        1/1                                  next_mshr_entry.state       =   ST_OUTPUT;
215        1/1                                  next_mshr_entry.evict_addr  =   cache_mem_ctrl_i.evict_addr ;
216        1/1                                  next_mshr_entry.evict_data  =   cache_mem_ctrl_i.evict_data ;
217        1/1                                  next_mshr_entry.evict_dirty =   cache_mem_ctrl_i.evict_dirty;
218                                         // IF   a dirty block is evicted
219                                         // ->   Write back the evicted block
220        1/1                              end else if (cache_mem_ctrl_i.evict_dirty == 1'b1) begin
221        1/1                                  next_mshr_entry.state       =   ST_EVICT;
222        1/1                                  next_mshr_entry.evict_addr  =   cache_mem_ctrl_i.evict_addr ;
223        1/1                                  next_mshr_entry.evict_data  =   cache_mem_ctrl_i.evict_data ;
224        1/1                                  next_mshr_entry.evict_dirty =   cache_mem_ctrl_i.evict_dirty;
225                                         // ELSE
226                                         // ->   Miss Handling Completed
227                                         end else begin
228        1/1                                  next_mshr_entry.state       =   ST_IDLE             ;
229        1/1                                  next_mshr_entry.cmd         =   BUS_NONE            ;
230        1/1                                  next_mshr_entry.req_addr    =   'b0                 ;
231        1/1                                  next_mshr_entry.req_data    =   'b0                 ;
232        1/1                                  next_mshr_entry.req_size    =   BYTE                ;
233        1/1                                  next_mshr_entry.evict_addr  =   'b0                 ;
234        1/1                                  next_mshr_entry.evict_data  =   'b0                 ;
235        1/1                                  next_mshr_entry.evict_dirty =   1'b0                ;
236        1/1                                  next_mshr_entry.link_idx    =   'd0                 ;
237        1/1                                  next_mshr_entry.mem_tag     =   'd0                 ;
238        1/1                                  next_mshr_cp_flag           =   1'b1                ;
239        1/1                                  next_mshr_cp_data           =   mshr_entry.req_data ;
240                                         end
241                                     end
                        MISSING_ELSE
242                                 end
243                                 ST_OUTPUT   :   begin
244                                     // IF   the Processor Interface is granted to this entry
245        1/1                          if (proc_grant_i == 1'b1) begin
246                                         // IF   the evicted block is dirty
247                                         // ->   Write back the evicted block
248        1/1                              if (mshr_entry.evict_dirty == 1'b1) begin
249        1/1                                  next_mshr_entry.state       =   ST_EVICT;
250                                         // ELSE
251                                         // ->   Miss Handling Completed
252                                         end else begin
253        0/1     ==>                          next_mshr_entry.state       =   ST_IDLE             ;
254        0/1     ==>                          next_mshr_entry.cmd         =   BUS_NONE            ;
255        0/1     ==>                          next_mshr_entry.req_addr    =   'b0                 ;
256        0/1     ==>                          next_mshr_entry.req_data    =   'b0                 ;
257        0/1     ==>                          next_mshr_entry.req_size    =   BYTE                ;
258        0/1     ==>                          next_mshr_entry.evict_addr  =   'b0                 ;
259        0/1     ==>                          next_mshr_entry.evict_data  =   'b0                 ;
260        0/1     ==>                          next_mshr_entry.evict_dirty =   1'b0                ;
261        0/1     ==>                          next_mshr_entry.link_idx    =   'd0                 ;
262        0/1     ==>                          next_mshr_entry.mem_tag     =   'd0                 ;
263        0/1     ==>                          next_mshr_cp_flag           =   1'b1                ;
264        0/1     ==>                          next_mshr_cp_data           =   mshr_entry.req_data ;
265                                         end
266                                     end
                        MISSING_ELSE
267                                 end
268                                 ST_EVICT    :   begin
269                                     // IF   the write back transaction to Memory is confirmed
270                                     // ->   Miss Handling Completed
271        1/1                          if ((memory_grant_i == 1'b1) && (mem2cache_i.response != 'd0)) begin
272        1/1                              next_mshr_entry.state       =   ST_IDLE             ;
273        1/1                              next_mshr_entry.cmd         =   BUS_NONE            ;
274        1/1                              next_mshr_entry.req_addr    =   'b0                 ;
275        1/1                              next_mshr_entry.req_data    =   'b0                 ;
276        1/1                              next_mshr_entry.req_size    =   BYTE                ;
277        1/1                              next_mshr_entry.evict_addr  =   'b0                 ;
278        1/1                              next_mshr_entry.evict_data  =   'b0                 ;
279        1/1                              next_mshr_entry.evict_dirty =   1'b0                ;
280        1/1                              next_mshr_entry.link_idx    =   'd0                 ;
281        1/1                              next_mshr_entry.mem_tag     =   'd0                 ;
282        1/1                              next_mshr_cp_flag           =   1'b1                ;
283        1/1                              next_mshr_cp_data           =   mshr_entry.req_data ;
284                                     end
                        MISSING_ELSE
285                                 end
286                                 default     :   begin
287        1/1                          next_mshr_entry.state       =   ST_IDLE     ;
288        1/1                          next_mshr_entry.cmd         =   BUS_NONE    ;
289        1/1                          next_mshr_entry.req_addr    =   'b0         ;
290        1/1                          next_mshr_entry.req_data    =   'b0         ;
291        1/1                          next_mshr_entry.req_size    =   BYTE        ;
292        1/1                          next_mshr_entry.evict_addr  =   'b0         ;
293        1/1                          next_mshr_entry.evict_data  =   'b0         ;
294        1/1                          next_mshr_entry.evict_dirty =   1'b0        ;
295        1/1                          next_mshr_entry.link_idx    =   'd0         ;
296        1/1                          next_mshr_entry.mem_tag     =   'd0         ;
297        1/1                          next_mshr_cp_flag           =   1'b0        ;
298        1/1                          next_mshr_cp_data           =   'd0         ;
299                                 end
300                             endcase
301                     
302        1/1                  if (next_mshr_entry.state == ST_IDLE) begin
303        1/1                      next_mshr_entry.linked  =   1'b0;
304        1/1                  end else if ((mshr_hit_i == 1'b1) && (mshr_hit_idx_i == mshr_entry_idx_i)) begin
305        1/1                      next_mshr_entry.linked  =   1'b1;
306                             end
                        MISSING_ELSE
307                         end
308                     
309                     // --------------------------------------------------------------------
310                     // MSHR entry output
311                     // --------------------------------------------------------------------
312                         assign  mshr_entry_o    =   mshr_entry  ;
313                     // --------------------------------------------------------------------
314                     // Processor Interface
315                     // --------------------------------------------------------------------
316                         always_comb begin
317        1/1                  mshr_proc_o.response    =   'd0 ;
318        1/1                  mshr_proc_o.data        =   'b0 ;
319        1/1                  mshr_proc_o.tag         =   'd0 ;
320        1/1                  case (mshr_entry.state)
321                                 ST_IDLE     :   begin
322                                     // IF   the processor request is allocated to this entry
323        1/1                          if ((proc2cache_i.command != BUS_NONE) && (dp_sel_i == 1'b1)) begin
324                                         // IF   The Processor Interface is granted to this entry
325                                         // AND  there is a dependency to older in-flight transaction
326                                         // ->   Confirm the request
327        1/1                              if (((mshr_hit_i && (cp_flag_i[mshr_hit_idx_i] == 1'b0))
328                                         || (evict_hit_i && (cp_flag_i[evict_hit_idx_i] == 1'b0)))) begin
329        1/1                                  mshr_proc_o.response    =   mshr_entry_idx_i;
330                                         // IF   The Processor Interface is granted to this entry
331                                         // AND  The cache_mem Interface is granted to this entry
332                                         // ->   Confirm the request 
333        1/1                              end else if (cache_mem_grant_i == 1'b1) begin
334        1/1                                  mshr_proc_o.response    =   mshr_entry_idx_i;
335                                             // IF   it is a load hit
336                                             // ->   Output data and tag
337        1/1                                  if (cache_mem_ctrl_i.req_hit == 1'b1 && proc2cache_i.command == BUS_LOAD) begin
338        0/1     ==>                              mshr_proc_o.tag     =   mshr_entry_idx_i;
339        0/1     ==>                              case (proc2cache_i.size)
340        0/1     ==>                                  BYTE    :   mshr_proc_o.data    =   {56'b0,cache_mem_ctrl_i.req_data_out[proc2cache_i.addr[2:0]+: 8]};
341        0/1     ==>                                  HALF    :   mshr_proc_o.data    =   {48'b0,cache_mem_ctrl_i.req_data_out[proc2cache_i.addr[2:0]+:16]};
342        0/1     ==>                                  WORD    :   mshr_proc_o.data    =   {32'b0,cache_mem_ctrl_i.req_data_out[proc2cache_i.addr[2:0]+:32]};
343        0/1     ==>                                  DOUBLE  :   mshr_proc_o.data    =   cache_mem_ctrl_i.req_data_out;
344        0/1     ==>                                  default :   mshr_proc_o.data    =   cache_mem_ctrl_i.req_data_out;
345                                                 endcase
346                                             end
                        MISSING_ELSE
347                                         end
                        MISSING_ELSE
348                                     end
                        MISSING_ELSE
349                                 end
350                                 ST_OUTPUT   :   begin
351        1/1                          mshr_proc_o.response    =   'd0                 ;
352        1/1                          mshr_proc_o.tag         =   mshr_entry_idx_i    ;
353        1/1                          case (mshr_entry.req_size)
354        1/1                              BYTE    :   mshr_proc_o.data    =   {56'b0,mshr_entry.req_data[mshr_entry.req_addr[2:0]+: 8]};
355        1/1                              HALF    :   mshr_proc_o.data    =   {48'b0,mshr_entry.req_data[mshr_entry.req_addr[2:0]+:16]};
356        1/1                              WORD    :   mshr_proc_o.data    =   {32'b0,mshr_entry.req_data[mshr_entry.req_addr[2:0]+:32]};
357        1/1                              DOUBLE  :   mshr_proc_o.data    =   mshr_entry.req_data;
358        0/1     ==>                      default :   mshr_proc_o.data    =   mshr_entry.req_data;
359                                     endcase
360                                 end
                        MISSING_DEFAULT
361                             endcase
362                         end
363                     
364                     // --------------------------------------------------------------------
365                     // cache_mem Interface
366                     // --------------------------------------------------------------------
367                         always_comb begin
368        1/1                  mshr_cache_mem_o.req_cmd        =   REQ_NONE;
369        1/1                  mshr_cache_mem_o.req_addr       =   'b0     ;
370        1/1                  mshr_cache_mem_o.req_data_in    =   'b0     ;
371        1/1                  case (mshr_entry.state)
372                                 ST_IDLE:    begin
373                                     // IF   the processor request is allocated to this entry
374        1/1                          if (dp_sel_i == 1'b1) begin
375        1/1                              case (proc2cache_i.command)
376                                             BUS_LOAD    :   begin
377        1/1                                      mshr_cache_mem_o.req_cmd        =   REQ_LOAD                        ;
378        1/1                                      mshr_cache_mem_o.req_addr       =   proc2cache_i.addr               ;
379        1/1                                      mshr_cache_mem_o.req_data_in    =   cache_mem_ctrl_i.req_data_out   ;
380                                             end
381                                             BUS_STORE   :   begin
382        1/1                                      mshr_cache_mem_o.req_cmd        =   REQ_STORE                       ;
383        1/1                                      mshr_cache_mem_o.req_addr       =   proc2cache_i.addr               ;
384        1/1                                      mshr_cache_mem_o.req_data_in    =   cache_mem_ctrl_i.req_data_out   ;
385        1/1                                      case (proc2cache_i.size)
386        1/1                                          BYTE    :   mshr_cache_mem_o.req_data_in[proc2cache_i.addr[2:0] +:  8]  =   proc2cache_i.data[ 7:0] ;
387        1/1                                          HALF    :   mshr_cache_mem_o.req_data_in[proc2cache_i.addr[2:0] +: 16]  =   proc2cache_i.data[15:0] ;
388        1/1                                          WORD    :   mshr_cache_mem_o.req_data_in[proc2cache_i.addr[2:0] +: 32]  =   proc2cache_i.data[31:0] ;
389        1/1                                          DOUBLE  :   mshr_cache_mem_o.req_data_in                                =   proc2cache_i.data       ;
                   ==>  MISSING_DEFAULT
390                                                 endcase
391                                             end    
                        MISSING_DEFAULT
392                                         endcase
393                                     end
                        MISSING_ELSE
394                                 end
395                                 ST_UPDATE:  begin
396        1/1                          if (mshr_entry.cmd == BUS_LOAD) begin
397        1/1                              mshr_cache_mem_o.req_cmd    =   REQ_LOAD_MISS       ;
398                                     end else begin
399        1/1                              mshr_cache_mem_o.req_cmd    =   REQ_STORE_MISS      ;
400                                     end
401        1/1                          mshr_cache_mem_o.req_addr       =   mshr_entry.req_addr ;
402        1/1                          mshr_cache_mem_o.req_data_in    =   mshr_entry.req_data ;
403                                 end
                        MISSING_DEFAULT
404                             endcase
405                         end
406                     
407                     // --------------------------------------------------------------------
408                     // Memory Interface
409                     // --------------------------------------------------------------------
410                         always_comb begin
411        1/1                  mshr_memory_o.addr      =   {mshr_entry.req_addr[C_XLEN-1:C_CACHE_OFFSET_WIDTH], {C_CACHE_OFFSET_WIDTH{1'b0}}};
412        1/1                  mshr_memory_o.size      =   DOUBLE              ;
413        1/1                  mshr_memory_o.command   =   BUS_NONE            ;
414        1/1                  mshr_memory_o.data      =   'd0 ;
415        1/1                  case (mshr_entry.state)
416                                 ST_RD_MEM   :   begin
417        1/1                          mshr_memory_o.data      =   'd0 ;
418        1/1                          mshr_memory_o.addr      =   {mshr_entry.req_addr[C_XLEN-1:C_CACHE_OFFSET_WIDTH], {C_CACHE_OFFSET_WIDTH{1'b0}}};
419        1/1                          mshr_memory_o.command   =   BUS_LOAD;
420                                 end
421                                 ST_EVICT    :   begin
422        1/1                          mshr_memory_o.data      =   mshr_entry.evict_data;
423        1/1                          mshr_memory_o.addr      =   {mshr_entry.evict_addr[C_XLEN-1:C_CACHE_OFFSET_WIDTH], {C_CACHE_OFFSET_WIDTH{1'b0}}};
424        1/1                          mshr_memory_o.command   =   BUS_STORE;
425                                 end
                        MISSING_DEFAULT

-------------------------------------------------------------------------------
Toggle Coverage for Instance : cache_tb.dut.cache_ctrl_inst.genblk1[10].mshr_entry_ctrl_inst
                Total Covered Percent 
Totals          72    38      52.78   
Total Bits      4844  3789    78.22   
Total Bits 0->1 2422  1894    78.20   
Total Bits 1->0 2422  1895    78.24   

                                
Ports          48   25   52.08  
Port Bits      3878 3067 79.09  
Port Bits 0->1 1939 1533 79.06  
Port Bits 1->0 1939 1534 79.11  

                                
Signals          24  13  54.17  
Signal Bits      966 722 74.74  
Signal Bits 0->1 483 361 74.74  
Signal Bits 1->0 483 361 74.74  

Port Details
                                     Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i                                Yes    Yes         Yes         INPUT     
rst_i                                No     Yes         No          INPUT     
mshr_entry_idx_i[3:0]                No     No          No          INPUT     
mshr_entry_o.mem_tag[3:0]            Yes    Yes         Yes         OUTPUT    
mshr_entry_o.linked                  No     No          No          OUTPUT    
mshr_entry_o.link_idx[3:0]           No     No          No          OUTPUT    
mshr_entry_o.evict_dirty             Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_data[33:0]        Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_data[34]          No     No          No          OUTPUT    
mshr_entry_o.evict_data[43:35]       Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_data[47:44]       No     No          No          OUTPUT    
mshr_entry_o.evict_data[48]          Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_data[49]          No     No          No          OUTPUT    
mshr_entry_o.evict_data[61:50]       Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_data[62]          No     No          No          OUTPUT    
mshr_entry_o.evict_data[63]          Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_addr[2:0]         No     No          No          OUTPUT    
mshr_entry_o.evict_addr[15:3]        Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_addr[31:16]       No     No          No          OUTPUT    
mshr_entry_o.req_size[1:0]           Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_data[36:0]          Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_data[39:37]         No     No          No          OUTPUT    
mshr_entry_o.req_data[41:40]         Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_data[44:42]         No     No          No          OUTPUT    
mshr_entry_o.req_data[45]            Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_data[46]            No     No          No          OUTPUT    
mshr_entry_o.req_data[49:47]         Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_data[50]            No     No          No          OUTPUT    
mshr_entry_o.req_data[52:51]         Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_data[54:53]         No     No          No          OUTPUT    
mshr_entry_o.req_data[56:55]         Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_data[59:57]         No     No          No          OUTPUT    
mshr_entry_o.req_data[60]            Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_data[61]            No     No          No          OUTPUT    
mshr_entry_o.req_data[62]            Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_data[63]            No     No          No          OUTPUT    
mshr_entry_o.req_addr[15:0]          Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_addr[31:16]         No     No          No          OUTPUT    
mshr_entry_o.cmd[1:0]                Yes    Yes         Yes         OUTPUT    
mshr_entry_o.state[2:0]              Yes    Yes         Yes         OUTPUT    
proc_grant_i                         Yes    Yes         Yes         INPUT     
proc2cache_i.command[1:0]            Yes    Yes         Yes         INPUT     
proc2cache_i.size[1:0]               Yes    Yes         Yes         INPUT     
proc2cache_i.data[63:0]              Yes    Yes         Yes         INPUT     
proc2cache_i.addr[15:0]              Yes    Yes         Yes         INPUT     
proc2cache_i.addr[31:16]             No     No          No          INPUT     
mshr_proc_o.tag[0]                   No     No          No          OUTPUT    
mshr_proc_o.tag[1]                   Yes    Yes         Yes         OUTPUT    
mshr_proc_o.tag[2]                   No     No          No          OUTPUT    
mshr_proc_o.tag[3]                   Yes    Yes         Yes         OUTPUT    
mshr_proc_o.data[63:0]               No     No          No          OUTPUT    
mshr_proc_o.response[0]              No     No          No          OUTPUT    
mshr_proc_o.response[1]              Yes    Yes         Yes         OUTPUT    
mshr_proc_o.response[2]              No     No          No          OUTPUT    
mshr_proc_o.response[3]              Yes    Yes         Yes         OUTPUT    
cache_mem_grant_i                    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.evict_data[63:0]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.evict_addr[2:0]     No     No          No          INPUT     
cache_mem_ctrl_i.evict_addr[15:3]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.evict_addr[31:16]   No     No          No          INPUT     
cache_mem_ctrl_i.evict_dirty         Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[4:0]   Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[6:5]   No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[8:7]   Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[11:9]  No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[13:12] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[15:14] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[25:16] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[26]    No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[31:27] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[33:32] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[34]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[37:35] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[38]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[41:39] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[42]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[45:43] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[47:46] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[50:48] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[52:51] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[54:53] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[58:55] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[60:59] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[63:61] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_hit             Yes    Yes         Yes         INPUT     
mshr_cache_mem_o.req_data_in[63:0]   Yes    Yes         Yes         OUTPUT    
mshr_cache_mem_o.req_addr[15:0]      Yes    Yes         Yes         OUTPUT    
mshr_cache_mem_o.req_addr[31:16]     No     No          No          OUTPUT    
mshr_cache_mem_o.req_cmd[2:0]        Yes    Yes         Yes         OUTPUT    
memory_grant_i                       Yes    Yes         Yes         INPUT     
mem2cache_i.tag[3:0]                 Yes    Yes         Yes         INPUT     
mem2cache_i.data[63:0]               Yes    Yes         Yes         INPUT     
mem2cache_i.response[3:0]            Yes    Yes         Yes         INPUT     
mshr_memory_o.command[1:0]           Yes    Yes         Yes         OUTPUT    
mshr_memory_o.size[1:0]              No     No          No          OUTPUT    
mshr_memory_o.data[33:0]             Yes    Yes         Yes         OUTPUT    
mshr_memory_o.data[34]               No     No          No          OUTPUT    
mshr_memory_o.data[43:35]            Yes    Yes         Yes         OUTPUT    
mshr_memory_o.data[47:44]            No     No          No          OUTPUT    
mshr_memory_o.data[48]               Yes    Yes         Yes         OUTPUT    
mshr_memory_o.data[49]               No     No          No          OUTPUT    
mshr_memory_o.data[61:50]            Yes    Yes         Yes         OUTPUT    
mshr_memory_o.data[62]               No     No          No          OUTPUT    
mshr_memory_o.data[63]               Yes    Yes         Yes         OUTPUT    
mshr_memory_o.addr[2:0]              No     No          No          OUTPUT    
mshr_memory_o.addr[15:3]             Yes    Yes         Yes         OUTPUT    
mshr_memory_o.addr[31:16]            No     No          No          OUTPUT    
mshr_hit_i                           Yes    Yes         Yes         INPUT     
mshr_hit_idx_i[3:0]                  Yes    Yes         Yes         INPUT     
evict_hit_i                          No     No          No          INPUT     
evict_hit_idx_i[3:0]                 No     No          No          INPUT     
dp_sel_i                             Yes    Yes         Yes         INPUT     
mshr_cp_flag_o                       Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[0]                    No     No          No          OUTPUT    
mshr_cp_data_o[30:1]                 Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[31]                   No     No          No          OUTPUT    
mshr_cp_data_o[36:32]                Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[39:37]                No     No          No          OUTPUT    
mshr_cp_data_o[41:40]                Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[44:42]                No     No          No          OUTPUT    
mshr_cp_data_o[45]                   Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[46]                   No     No          No          OUTPUT    
mshr_cp_data_o[49:47]                Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[50]                   No     No          No          OUTPUT    
mshr_cp_data_o[52:51]                Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[54:53]                No     No          No          OUTPUT    
mshr_cp_data_o[56:55]                Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[59:57]                No     No          No          OUTPUT    
mshr_cp_data_o[60]                   Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[61]                   No     No          No          OUTPUT    
mshr_cp_data_o[62]                   Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[63]                   No     No          No          OUTPUT    
cp_flag_i[0]                         No     No          No          INPUT     
cp_flag_i[15:1]                      Yes    Yes         Yes         INPUT     
cp_data_i[8:1][63:0]                 Yes    Yes         Yes         INPUT     
cp_data_i[9][44:0]                   Yes    Yes         Yes         INPUT     
cp_data_i[9][63:46]                  Yes    Yes         Yes         INPUT     
cp_data_i[10][30:1]                  Yes    Yes         Yes         INPUT     
cp_data_i[10][36:32]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][41:40]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][45]                    Yes    Yes         Yes         INPUT     
cp_data_i[10][49:47]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][52:51]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][56:55]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][60]                    Yes    Yes         Yes         INPUT     
cp_data_i[10][62]                    Yes    Yes         Yes         INPUT     
cp_data_i[11][27:0]                  Yes    Yes         Yes         INPUT     
cp_data_i[11][36:29]                 Yes    Yes         Yes         INPUT     
cp_data_i[11][49:39]                 Yes    Yes         Yes         INPUT     
cp_data_i[11][51]                    Yes    Yes         Yes         INPUT     
cp_data_i[11][59:54]                 Yes    Yes         Yes         INPUT     
cp_data_i[11][63:62]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][4:0]                   Yes    Yes         Yes         INPUT     
cp_data_i[12][27:6]                  Yes    Yes         Yes         INPUT     
cp_data_i[12][31:29]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][35:33]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][39]                    Yes    Yes         Yes         INPUT     
cp_data_i[12][44:43]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][48:46]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][50]                    Yes    Yes         Yes         INPUT     
cp_data_i[12][54]                    Yes    Yes         Yes         INPUT     
cp_data_i[12][58:57]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][61]                    Yes    Yes         Yes         INPUT     
cp_data_i[13][17:0]                  Yes    Yes         Yes         INPUT     
cp_data_i[13][46:19]                 Yes    Yes         Yes         INPUT     
cp_data_i[13][49]                    Yes    Yes         Yes         INPUT     
cp_data_i[13][56:51]                 Yes    Yes         Yes         INPUT     
cp_data_i[13][63:58]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][14:1]                  Yes    Yes         Yes         INPUT     
cp_data_i[14][19:16]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][21]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][24:23]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][27]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][32:30]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][37:35]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][39]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][41]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][43]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][46:45]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][51:49]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][59:53]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][62:61]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][15:0]                  Yes    Yes         Yes         INPUT     
cp_data_i[15][37:17]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][40:39]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][42]                    Yes    Yes         Yes         INPUT     
cp_data_i[15][45:44]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][48:47]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][53:51]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][55]                    Yes    Yes         Yes         INPUT     
cp_data_i[15][63:57]                 Yes    Yes         Yes         INPUT     
Other bits of cp_data_i[15:0][63:0]  No     No          No          INPUT     

Signal Details
                                  Toggle Toggle 1->0 Toggle 0->1 
mshr_entry.mem_tag[3:0]           Yes    Yes         Yes         
mshr_entry.linked                 No     No          No          
mshr_entry.link_idx[3:0]          No     No          No          
mshr_entry.evict_dirty            Yes    Yes         Yes         
mshr_entry.evict_data[33:0]       Yes    Yes         Yes         
mshr_entry.evict_data[34]         No     No          No          
mshr_entry.evict_data[43:35]      Yes    Yes         Yes         
mshr_entry.evict_data[47:44]      No     No          No          
mshr_entry.evict_data[48]         Yes    Yes         Yes         
mshr_entry.evict_data[49]         No     No          No          
mshr_entry.evict_data[61:50]      Yes    Yes         Yes         
mshr_entry.evict_data[62]         No     No          No          
mshr_entry.evict_data[63]         Yes    Yes         Yes         
mshr_entry.evict_addr[2:0]        No     No          No          
mshr_entry.evict_addr[15:3]       Yes    Yes         Yes         
mshr_entry.evict_addr[31:16]      No     No          No          
mshr_entry.req_size[1:0]          Yes    Yes         Yes         
mshr_entry.req_data[36:0]         Yes    Yes         Yes         
mshr_entry.req_data[39:37]        No     No          No          
mshr_entry.req_data[41:40]        Yes    Yes         Yes         
mshr_entry.req_data[44:42]        No     No          No          
mshr_entry.req_data[45]           Yes    Yes         Yes         
mshr_entry.req_data[46]           No     No          No          
mshr_entry.req_data[49:47]        Yes    Yes         Yes         
mshr_entry.req_data[50]           No     No          No          
mshr_entry.req_data[52:51]        Yes    Yes         Yes         
mshr_entry.req_data[54:53]        No     No          No          
mshr_entry.req_data[56:55]        Yes    Yes         Yes         
mshr_entry.req_data[59:57]        No     No          No          
mshr_entry.req_data[60]           Yes    Yes         Yes         
mshr_entry.req_data[61]           No     No          No          
mshr_entry.req_data[62]           Yes    Yes         Yes         
mshr_entry.req_data[63]           No     No          No          
mshr_entry.req_addr[15:0]         Yes    Yes         Yes         
mshr_entry.req_addr[31:16]        No     No          No          
mshr_entry.cmd[1:0]               Yes    Yes         Yes         
mshr_entry.state[2:0]             Yes    Yes         Yes         
next_mshr_entry.mem_tag[3:0]      Yes    Yes         Yes         
next_mshr_entry.linked            Yes    Yes         Yes         
next_mshr_entry.link_idx[1:0]     Yes    Yes         Yes         
next_mshr_entry.link_idx[2]       No     No          No          
next_mshr_entry.link_idx[3]       Yes    Yes         Yes         
next_mshr_entry.evict_dirty       Yes    Yes         Yes         
next_mshr_entry.evict_data[33:0]  Yes    Yes         Yes         
next_mshr_entry.evict_data[34]    No     No          No          
next_mshr_entry.evict_data[43:35] Yes    Yes         Yes         
next_mshr_entry.evict_data[47:44] No     No          No          
next_mshr_entry.evict_data[48]    Yes    Yes         Yes         
next_mshr_entry.evict_data[49]    No     No          No          
next_mshr_entry.evict_data[61:50] Yes    Yes         Yes         
next_mshr_entry.evict_data[62]    No     No          No          
next_mshr_entry.evict_data[63]    Yes    Yes         Yes         
next_mshr_entry.evict_addr[2:0]   No     No          No          
next_mshr_entry.evict_addr[15:3]  Yes    Yes         Yes         
next_mshr_entry.evict_addr[31:16] No     No          No          
next_mshr_entry.req_size[1:0]     Yes    Yes         Yes         
next_mshr_entry.req_data[63:0]    Yes    Yes         Yes         
next_mshr_entry.req_addr[15:0]    Yes    Yes         Yes         
next_mshr_entry.req_addr[31:16]   No     No          No          
next_mshr_entry.cmd[1:0]          Yes    Yes         Yes         
next_mshr_entry.state[2:0]        Yes    Yes         Yes         
next_mshr_cp_flag                 Yes    Yes         Yes         
next_mshr_cp_data[0]              No     No          No          
next_mshr_cp_data[30:1]           Yes    Yes         Yes         
next_mshr_cp_data[31]             No     No          No          
next_mshr_cp_data[36:32]          Yes    Yes         Yes         
next_mshr_cp_data[39:37]          No     No          No          
next_mshr_cp_data[41:40]          Yes    Yes         Yes         
next_mshr_cp_data[44:42]          No     No          No          
next_mshr_cp_data[45]             Yes    Yes         Yes         
next_mshr_cp_data[46]             No     No          No          
next_mshr_cp_data[49:47]          Yes    Yes         Yes         
next_mshr_cp_data[50]             No     No          No          
next_mshr_cp_data[52:51]          Yes    Yes         Yes         
next_mshr_cp_data[54:53]          No     No          No          
next_mshr_cp_data[56:55]          Yes    Yes         Yes         
next_mshr_cp_data[59:57]          No     No          No          
next_mshr_cp_data[60]             Yes    Yes         Yes         
next_mshr_cp_data[61]             No     No          No          
next_mshr_cp_data[62]             Yes    Yes         Yes         
next_mshr_cp_data[63]             No     No          No          


-------------------------------------------------------------------------------
===============================================================================
Module Instance : cache_tb.dut.cache_ctrl_inst.genblk1[8].mshr_entry_ctrl_inst
===============================================================================

Instance :

SCORE  LINE   TOGGLE 
 80.97  80.00  81.94 


Instance's subtree :

SCORE  LINE   TOGGLE 
 80.97  80.00  81.94 


Module : 

SCORE  LINE   TOGGLE NAME            
 87.59  90.48  84.70 mshr_entry_ctrl 


Parent : 

SCORE  LINE   TOGGLE NAME            
 92.38 100.00  84.76 cache_ctrl_inst 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : cache_tb.dut.cache_ctrl_inst.genblk1[8].mshr_entry_ctrl_inst

             Line No.   Total   Covered  Percent
TOTAL                      210      168    80.00
ALWAYS             75       17       17   100.00
ALWAYS             97      135      101    74.81
ALWAYS            317       25       17    68.00
ALWAYS            368       22       22   100.00
ALWAYS            411       11       11   100.00

74                          always_ff @(posedge clk_i) begin
75         1/1                  if (rst_i) begin
76         1/1                      mshr_entry.state        <=  `SD ST_IDLE     ;
77         1/1                      mshr_entry.cmd          <=  `SD BUS_NONE    ;
78         1/1                      mshr_entry.req_addr     <=  `SD 'b0         ;
79         1/1                      mshr_entry.req_data     <=  `SD 'b0         ;
80         1/1                      mshr_entry.req_size     <=  `SD BYTE        ;
81         1/1                      mshr_entry.evict_addr   <=  `SD 'b0         ;
82         1/1                      mshr_entry.evict_data   <=  `SD 'b0         ;
83         1/1                      mshr_entry.evict_dirty  <=  `SD 1'b0        ;
84         1/1                      mshr_entry.link_idx     <=  `SD 'd0         ;
85         1/1                      mshr_entry.linked       <=  `SD 1'b0        ;
86         1/1                      mshr_entry.mem_tag      <=  `SD 'd0         ;
87         1/1                      mshr_cp_flag_o          <=  `SD 1'b0        ;
88         1/1                      mshr_cp_data_o          <=  `SD 'b0         ;
89                              end else begin
90         1/1                      mshr_entry              <=  `SD next_mshr_entry     ;
91         1/1                      mshr_cp_flag_o          <=  `SD next_mshr_cp_flag   ;
92         1/1                      mshr_cp_data_o          <=  `SD next_mshr_cp_data   ;
93                              end
94                          end
95                      
96                          always_comb begin
97         1/1                  next_mshr_entry.state       =   mshr_entry.state        ;
98         1/1                  next_mshr_entry.cmd         =   mshr_entry.cmd          ;
99         1/1                  next_mshr_entry.req_addr    =   mshr_entry.req_addr     ;
100        1/1                  next_mshr_entry.req_data    =   mshr_entry.req_data     ;
101        1/1                  next_mshr_entry.req_size    =   mshr_entry.req_size     ;
102        1/1                  next_mshr_entry.evict_addr  =   mshr_entry.evict_addr   ;
103        1/1                  next_mshr_entry.evict_data  =   mshr_entry.evict_data   ;
104        1/1                  next_mshr_entry.evict_dirty =   mshr_entry.evict_dirty  ;
105        1/1                  next_mshr_entry.link_idx    =   mshr_entry.link_idx     ;
106        1/1                  next_mshr_entry.linked      =   mshr_entry.linked       ;
107        1/1                  next_mshr_entry.mem_tag     =   mshr_entry.mem_tag      ;
108        1/1                  next_mshr_cp_flag           =   mshr_cp_flag_o          ;
109        1/1                  next_mshr_cp_data           =   mshr_cp_data_o          ;
110        1/1                  case (mshr_entry.state)
111                                 ST_IDLE     :   begin
112                                     // IF   there is a valid transaction on Processor Interface
113                                     // AND  the Processor Interface is granted to this entry
114                                     // AND  the cache_mem Interface is granted to this entry
115                                     // AND  it is a miss
116                                     // AND  the entry is selected to hold the new miss
117        1/1                          if ((proc2cache_i.command != BUS_NONE) && (dp_sel_i == 1'b1)
118                                     && (proc_grant_i == 1'b1)) begin
119                                         // IF   there is an older in-flight transaction to the same addreess
120                                         // ->   Wait for the completion of older miss to the same address
121        1/1                              if (mshr_hit_i && (cp_flag_i[mshr_hit_idx_i] == 1'b0)) begin
122        1/1                                  next_mshr_entry.state       =   ST_WAIT_DEPEND          ;
123        1/1                                  next_mshr_entry.link_idx    =   mshr_hit_idx_i          ;
124        1/1                                  next_mshr_entry.cmd         =   proc2cache_i.command    ;
125        1/1                                  next_mshr_entry.req_addr    =   proc2cache_i.addr       ;
126        1/1                                  next_mshr_entry.req_size    =   proc2cache_i.size       ;
127        1/1                                  if (proc2cache_i.command == BUS_STORE) begin
128        1/1                                      next_mshr_entry.req_data    =   proc2cache_i.data   ;
129                                             end
                        MISSING_ELSE
130                                         // IF   there is an older in-flight transaction that is in the middle of evicting the data block
131                                         // ->   Wait for the completion of write-back to memory
132        1/1                              end else if (evict_hit_i && (cp_flag_i[evict_hit_idx_i] == 1'b0)) begin
133        0/1     ==>                          next_mshr_entry.state       =   ST_WAIT_EVICT           ;
134        0/1     ==>                          next_mshr_entry.link_idx    =   evict_hit_idx_i         ;
135        0/1     ==>                          next_mshr_entry.cmd         =   proc2cache_i.command    ;
136        0/1     ==>                          next_mshr_entry.req_addr    =   proc2cache_i.addr       ;
137        0/1     ==>                          next_mshr_entry.req_size    =   proc2cache_i.size       ;
138        0/1     ==>                          if (proc2cache_i.command == BUS_STORE) begin
139        0/1     ==>                              next_mshr_entry.req_data    =   proc2cache_i.data   ;
140                                             end
                   ==>  MISSING_ELSE
141                                         // IF   it is a miss, and no dependency to older in-flight transactions.
142                                         // ->   Start miss handling
143        1/1                              end else if ((cache_mem_ctrl_i.req_hit == 1'b0) && (cache_mem_grant_i == 1'b1)) begin
144        1/1                                  next_mshr_entry.state       =   ST_RD_MEM               ;
145        1/1                                  next_mshr_entry.link_idx    =   'd0                     ;
146        1/1                                  next_mshr_entry.cmd         =   proc2cache_i.command    ;
147        1/1                                  next_mshr_entry.req_addr    =   proc2cache_i.addr       ;
148        1/1                                  next_mshr_entry.req_size    =   proc2cache_i.size       ;
149        1/1                                  if (proc2cache_i.command == BUS_STORE) begin
150        1/1                                      next_mshr_entry.req_data    =   proc2cache_i.data   ;
151                                             end
                        MISSING_ELSE
152                                         end
                        MISSING_ELSE
153                                     end
                        MISSING_ELSE
154        1/1                          next_mshr_cp_flag   =   1'b0    ;
155        1/1                          next_mshr_cp_data   =   'b0     ;
156                                 end
157                                 ST_WAIT_DEPEND  :   begin
158                                     // IF   the older transaction that the entry is linked to completed
159                                     // ->   Update the cache data
160        0/1     ==>                  if (cp_flag_i[mshr_entry.link_idx] == 1'b1) begin
161        0/1     ==>                      next_mshr_entry.state       =   ST_UPDATE   ;
162        0/1     ==>                      next_mshr_entry.link_idx    =   'd0         ;
163        0/1     ==>                      next_mshr_entry.req_data    =   cp_data_i[mshr_entry.link_idx];
164        0/1     ==>                      if (mshr_entry.cmd == BUS_STORE) begin
165        0/1     ==>                          case (mshr_entry.req_size)
166        0/1     ==>                              BYTE    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +:  8]    =   mshr_entry.req_data[ 7:0]   ;
167        0/1     ==>                              HALF    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +: 16]    =   mshr_entry.req_data[15:0]   ;
168        0/1     ==>                              WORD    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +: 32]    =   mshr_entry.req_data[31:0]   ;
169        0/1     ==>                              DOUBLE  :   next_mshr_entry.req_data                                    =   mshr_entry.req_data         ;
170        0/1     ==>                              default :   next_mshr_entry.req_data                                    =   mshr_entry.req_data         ;
171                                             endcase
172                                         end
                   ==>  MISSING_ELSE
173                                     end
                   ==>  MISSING_ELSE
174                                 end
175                                 ST_WAIT_EVICT   : begin
176                                     // IF   the older transaction that evicts the cache block completed
177                                     // ->   Read from Memory
178        0/1     ==>                  if (cp_flag_i[mshr_entry.link_idx] == 1'b1) begin
179        0/1     ==>                      next_mshr_entry.state       =   ST_RD_MEM   ;
180        0/1     ==>                      next_mshr_entry.link_idx    =   'd0         ;
181                                     end
                   ==>  MISSING_ELSE
182                                 end
183                                 ST_RD_MEM   :   begin
184                                     // IF   the read transaction is confirmed by Memory Interface
185                                     // ->   Wait for the data to return from Memory
186        1/1                          if ((memory_grant_i == 1'b1) && (mem2cache_i.response != 'd0)) begin
187        1/1                              next_mshr_entry.state       =   ST_WAIT_MEM             ;
188        1/1                              next_mshr_entry.mem_tag     =   mem2cache_i.response    ;
189                                     end
                        MISSING_ELSE
190                                 end
191                                 ST_WAIT_MEM :   begin
192                                     // IF   the data is returned from the Memory
193                                     // ->   Update the cache data
194        1/1                          if (mem2cache_i.tag == mshr_entry.mem_tag) begin
195        1/1                              next_mshr_entry.state       =   ST_UPDATE           ;
196        1/1                              next_mshr_entry.req_data    =   mem2cache_i.data    ;
197        1/1                              if (mshr_entry.cmd == BUS_STORE) begin
198        1/1                                  case (mshr_entry.req_size)
199        1/1                                      BYTE    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +:  8]    =   mshr_entry.req_data[ 7:0]   ;
200        1/1                                      HALF    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +: 16]    =   mshr_entry.req_data[15:0]   ;
201        1/1                                      WORD    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +: 32]    =   mshr_entry.req_data[31:0]   ;
202        1/1                                      DOUBLE  :   next_mshr_entry.req_data                                    =   mshr_entry.req_data         ;
203        0/1     ==>                              default :   next_mshr_entry.req_data                                    =   mshr_entry.req_data         ;
204                                             endcase
205                                         end
                        MISSING_ELSE
206                                     end
                        MISSING_ELSE
207                                 end
208                                 ST_UPDATE   :   begin
209                                     // IF   the req interface is granted to this entry
210        1/1                          if (cache_mem_grant_i == 1'b1) begin
211                                         // IF   it is a load miss
212                                         // ->   Output data to processor
213        1/1                              if (mshr_entry.cmd == BUS_LOAD) begin
214        1/1                                  next_mshr_entry.state       =   ST_OUTPUT;
215        1/1                                  next_mshr_entry.evict_addr  =   cache_mem_ctrl_i.evict_addr ;
216        1/1                                  next_mshr_entry.evict_data  =   cache_mem_ctrl_i.evict_data ;
217        1/1                                  next_mshr_entry.evict_dirty =   cache_mem_ctrl_i.evict_dirty;
218                                         // IF   a dirty block is evicted
219                                         // ->   Write back the evicted block
220        1/1                              end else if (cache_mem_ctrl_i.evict_dirty == 1'b1) begin
221        1/1                                  next_mshr_entry.state       =   ST_EVICT;
222        1/1                                  next_mshr_entry.evict_addr  =   cache_mem_ctrl_i.evict_addr ;
223        1/1                                  next_mshr_entry.evict_data  =   cache_mem_ctrl_i.evict_data ;
224        1/1                                  next_mshr_entry.evict_dirty =   cache_mem_ctrl_i.evict_dirty;
225                                         // ELSE
226                                         // ->   Miss Handling Completed
227                                         end else begin
228        1/1                                  next_mshr_entry.state       =   ST_IDLE             ;
229        1/1                                  next_mshr_entry.cmd         =   BUS_NONE            ;
230        1/1                                  next_mshr_entry.req_addr    =   'b0                 ;
231        1/1                                  next_mshr_entry.req_data    =   'b0                 ;
232        1/1                                  next_mshr_entry.req_size    =   BYTE                ;
233        1/1                                  next_mshr_entry.evict_addr  =   'b0                 ;
234        1/1                                  next_mshr_entry.evict_data  =   'b0                 ;
235        1/1                                  next_mshr_entry.evict_dirty =   1'b0                ;
236        1/1                                  next_mshr_entry.link_idx    =   'd0                 ;
237        1/1                                  next_mshr_entry.mem_tag     =   'd0                 ;
238        1/1                                  next_mshr_cp_flag           =   1'b1                ;
239        1/1                                  next_mshr_cp_data           =   mshr_entry.req_data ;
240                                         end
241                                     end
                        MISSING_ELSE
242                                 end
243                                 ST_OUTPUT   :   begin
244                                     // IF   the Processor Interface is granted to this entry
245        1/1                          if (proc_grant_i == 1'b1) begin
246                                         // IF   the evicted block is dirty
247                                         // ->   Write back the evicted block
248        1/1                              if (mshr_entry.evict_dirty == 1'b1) begin
249        1/1                                  next_mshr_entry.state       =   ST_EVICT;
250                                         // ELSE
251                                         // ->   Miss Handling Completed
252                                         end else begin
253        0/1     ==>                          next_mshr_entry.state       =   ST_IDLE             ;
254        0/1     ==>                          next_mshr_entry.cmd         =   BUS_NONE            ;
255        0/1     ==>                          next_mshr_entry.req_addr    =   'b0                 ;
256        0/1     ==>                          next_mshr_entry.req_data    =   'b0                 ;
257        0/1     ==>                          next_mshr_entry.req_size    =   BYTE                ;
258        0/1     ==>                          next_mshr_entry.evict_addr  =   'b0                 ;
259        0/1     ==>                          next_mshr_entry.evict_data  =   'b0                 ;
260        0/1     ==>                          next_mshr_entry.evict_dirty =   1'b0                ;
261        0/1     ==>                          next_mshr_entry.link_idx    =   'd0                 ;
262        0/1     ==>                          next_mshr_entry.mem_tag     =   'd0                 ;
263        0/1     ==>                          next_mshr_cp_flag           =   1'b1                ;
264        0/1     ==>                          next_mshr_cp_data           =   mshr_entry.req_data ;
265                                         end
266                                     end
                        MISSING_ELSE
267                                 end
268                                 ST_EVICT    :   begin
269                                     // IF   the write back transaction to Memory is confirmed
270                                     // ->   Miss Handling Completed
271        1/1                          if ((memory_grant_i == 1'b1) && (mem2cache_i.response != 'd0)) begin
272        1/1                              next_mshr_entry.state       =   ST_IDLE             ;
273        1/1                              next_mshr_entry.cmd         =   BUS_NONE            ;
274        1/1                              next_mshr_entry.req_addr    =   'b0                 ;
275        1/1                              next_mshr_entry.req_data    =   'b0                 ;
276        1/1                              next_mshr_entry.req_size    =   BYTE                ;
277        1/1                              next_mshr_entry.evict_addr  =   'b0                 ;
278        1/1                              next_mshr_entry.evict_data  =   'b0                 ;
279        1/1                              next_mshr_entry.evict_dirty =   1'b0                ;
280        1/1                              next_mshr_entry.link_idx    =   'd0                 ;
281        1/1                              next_mshr_entry.mem_tag     =   'd0                 ;
282        1/1                              next_mshr_cp_flag           =   1'b1                ;
283        1/1                              next_mshr_cp_data           =   mshr_entry.req_data ;
284                                     end
                        MISSING_ELSE
285                                 end
286                                 default     :   begin
287        1/1                          next_mshr_entry.state       =   ST_IDLE     ;
288        1/1                          next_mshr_entry.cmd         =   BUS_NONE    ;
289        1/1                          next_mshr_entry.req_addr    =   'b0         ;
290        1/1                          next_mshr_entry.req_data    =   'b0         ;
291        1/1                          next_mshr_entry.req_size    =   BYTE        ;
292        1/1                          next_mshr_entry.evict_addr  =   'b0         ;
293        1/1                          next_mshr_entry.evict_data  =   'b0         ;
294        1/1                          next_mshr_entry.evict_dirty =   1'b0        ;
295        1/1                          next_mshr_entry.link_idx    =   'd0         ;
296        1/1                          next_mshr_entry.mem_tag     =   'd0         ;
297        1/1                          next_mshr_cp_flag           =   1'b0        ;
298        1/1                          next_mshr_cp_data           =   'd0         ;
299                                 end
300                             endcase
301                     
302        1/1                  if (next_mshr_entry.state == ST_IDLE) begin
303        1/1                      next_mshr_entry.linked  =   1'b0;
304        1/1                  end else if ((mshr_hit_i == 1'b1) && (mshr_hit_idx_i == mshr_entry_idx_i)) begin
305        1/1                      next_mshr_entry.linked  =   1'b1;
306                             end
                        MISSING_ELSE
307                         end
308                     
309                     // --------------------------------------------------------------------
310                     // MSHR entry output
311                     // --------------------------------------------------------------------
312                         assign  mshr_entry_o    =   mshr_entry  ;
313                     // --------------------------------------------------------------------
314                     // Processor Interface
315                     // --------------------------------------------------------------------
316                         always_comb begin
317        1/1                  mshr_proc_o.response    =   'd0 ;
318        1/1                  mshr_proc_o.data        =   'b0 ;
319        1/1                  mshr_proc_o.tag         =   'd0 ;
320        1/1                  case (mshr_entry.state)
321                                 ST_IDLE     :   begin
322                                     // IF   the processor request is allocated to this entry
323        1/1                          if ((proc2cache_i.command != BUS_NONE) && (dp_sel_i == 1'b1)) begin
324                                         // IF   The Processor Interface is granted to this entry
325                                         // AND  there is a dependency to older in-flight transaction
326                                         // ->   Confirm the request
327        1/1                              if (((mshr_hit_i && (cp_flag_i[mshr_hit_idx_i] == 1'b0))
328                                         || (evict_hit_i && (cp_flag_i[evict_hit_idx_i] == 1'b0)))) begin
329        1/1                                  mshr_proc_o.response    =   mshr_entry_idx_i;
330                                         // IF   The Processor Interface is granted to this entry
331                                         // AND  The cache_mem Interface is granted to this entry
332                                         // ->   Confirm the request 
333        1/1                              end else if (cache_mem_grant_i == 1'b1) begin
334        1/1                                  mshr_proc_o.response    =   mshr_entry_idx_i;
335                                             // IF   it is a load hit
336                                             // ->   Output data and tag
337        1/1                                  if (cache_mem_ctrl_i.req_hit == 1'b1 && proc2cache_i.command == BUS_LOAD) begin
338        0/1     ==>                              mshr_proc_o.tag     =   mshr_entry_idx_i;
339        0/1     ==>                              case (proc2cache_i.size)
340        0/1     ==>                                  BYTE    :   mshr_proc_o.data    =   {56'b0,cache_mem_ctrl_i.req_data_out[proc2cache_i.addr[2:0]+: 8]};
341        0/1     ==>                                  HALF    :   mshr_proc_o.data    =   {48'b0,cache_mem_ctrl_i.req_data_out[proc2cache_i.addr[2:0]+:16]};
342        0/1     ==>                                  WORD    :   mshr_proc_o.data    =   {32'b0,cache_mem_ctrl_i.req_data_out[proc2cache_i.addr[2:0]+:32]};
343        0/1     ==>                                  DOUBLE  :   mshr_proc_o.data    =   cache_mem_ctrl_i.req_data_out;
344        0/1     ==>                                  default :   mshr_proc_o.data    =   cache_mem_ctrl_i.req_data_out;
345                                                 endcase
346                                             end
                        MISSING_ELSE
347                                         end
                        MISSING_ELSE
348                                     end
                        MISSING_ELSE
349                                 end
350                                 ST_OUTPUT   :   begin
351        1/1                          mshr_proc_o.response    =   'd0                 ;
352        1/1                          mshr_proc_o.tag         =   mshr_entry_idx_i    ;
353        1/1                          case (mshr_entry.req_size)
354        1/1                              BYTE    :   mshr_proc_o.data    =   {56'b0,mshr_entry.req_data[mshr_entry.req_addr[2:0]+: 8]};
355        1/1                              HALF    :   mshr_proc_o.data    =   {48'b0,mshr_entry.req_data[mshr_entry.req_addr[2:0]+:16]};
356        1/1                              WORD    :   mshr_proc_o.data    =   {32'b0,mshr_entry.req_data[mshr_entry.req_addr[2:0]+:32]};
357        1/1                              DOUBLE  :   mshr_proc_o.data    =   mshr_entry.req_data;
358        0/1     ==>                      default :   mshr_proc_o.data    =   mshr_entry.req_data;
359                                     endcase
360                                 end
                        MISSING_DEFAULT
361                             endcase
362                         end
363                     
364                     // --------------------------------------------------------------------
365                     // cache_mem Interface
366                     // --------------------------------------------------------------------
367                         always_comb begin
368        1/1                  mshr_cache_mem_o.req_cmd        =   REQ_NONE;
369        1/1                  mshr_cache_mem_o.req_addr       =   'b0     ;
370        1/1                  mshr_cache_mem_o.req_data_in    =   'b0     ;
371        1/1                  case (mshr_entry.state)
372                                 ST_IDLE:    begin
373                                     // IF   the processor request is allocated to this entry
374        1/1                          if (dp_sel_i == 1'b1) begin
375        1/1                              case (proc2cache_i.command)
376                                             BUS_LOAD    :   begin
377        1/1                                      mshr_cache_mem_o.req_cmd        =   REQ_LOAD                        ;
378        1/1                                      mshr_cache_mem_o.req_addr       =   proc2cache_i.addr               ;
379        1/1                                      mshr_cache_mem_o.req_data_in    =   cache_mem_ctrl_i.req_data_out   ;
380                                             end
381                                             BUS_STORE   :   begin
382        1/1                                      mshr_cache_mem_o.req_cmd        =   REQ_STORE                       ;
383        1/1                                      mshr_cache_mem_o.req_addr       =   proc2cache_i.addr               ;
384        1/1                                      mshr_cache_mem_o.req_data_in    =   cache_mem_ctrl_i.req_data_out   ;
385        1/1                                      case (proc2cache_i.size)
386        1/1                                          BYTE    :   mshr_cache_mem_o.req_data_in[proc2cache_i.addr[2:0] +:  8]  =   proc2cache_i.data[ 7:0] ;
387        1/1                                          HALF    :   mshr_cache_mem_o.req_data_in[proc2cache_i.addr[2:0] +: 16]  =   proc2cache_i.data[15:0] ;
388        1/1                                          WORD    :   mshr_cache_mem_o.req_data_in[proc2cache_i.addr[2:0] +: 32]  =   proc2cache_i.data[31:0] ;
389        1/1                                          DOUBLE  :   mshr_cache_mem_o.req_data_in                                =   proc2cache_i.data       ;
                   ==>  MISSING_DEFAULT
390                                                 endcase
391                                             end    
                        MISSING_DEFAULT
392                                         endcase
393                                     end
                        MISSING_ELSE
394                                 end
395                                 ST_UPDATE:  begin
396        1/1                          if (mshr_entry.cmd == BUS_LOAD) begin
397        1/1                              mshr_cache_mem_o.req_cmd    =   REQ_LOAD_MISS       ;
398                                     end else begin
399        1/1                              mshr_cache_mem_o.req_cmd    =   REQ_STORE_MISS      ;
400                                     end
401        1/1                          mshr_cache_mem_o.req_addr       =   mshr_entry.req_addr ;
402        1/1                          mshr_cache_mem_o.req_data_in    =   mshr_entry.req_data ;
403                                 end
                        MISSING_DEFAULT
404                             endcase
405                         end
406                     
407                     // --------------------------------------------------------------------
408                     // Memory Interface
409                     // --------------------------------------------------------------------
410                         always_comb begin
411        1/1                  mshr_memory_o.addr      =   {mshr_entry.req_addr[C_XLEN-1:C_CACHE_OFFSET_WIDTH], {C_CACHE_OFFSET_WIDTH{1'b0}}};
412        1/1                  mshr_memory_o.size      =   DOUBLE              ;
413        1/1                  mshr_memory_o.command   =   BUS_NONE            ;
414        1/1                  mshr_memory_o.data      =   'd0 ;
415        1/1                  case (mshr_entry.state)
416                                 ST_RD_MEM   :   begin
417        1/1                          mshr_memory_o.data      =   'd0 ;
418        1/1                          mshr_memory_o.addr      =   {mshr_entry.req_addr[C_XLEN-1:C_CACHE_OFFSET_WIDTH], {C_CACHE_OFFSET_WIDTH{1'b0}}};
419        1/1                          mshr_memory_o.command   =   BUS_LOAD;
420                                 end
421                                 ST_EVICT    :   begin
422        1/1                          mshr_memory_o.data      =   mshr_entry.evict_data;
423        1/1                          mshr_memory_o.addr      =   {mshr_entry.evict_addr[C_XLEN-1:C_CACHE_OFFSET_WIDTH], {C_CACHE_OFFSET_WIDTH{1'b0}}};
424        1/1                          mshr_memory_o.command   =   BUS_STORE;
425                                 end
                        MISSING_DEFAULT

-------------------------------------------------------------------------------
Toggle Coverage for Instance : cache_tb.dut.cache_ctrl_inst.genblk1[8].mshr_entry_ctrl_inst
                Total Covered Percent 
Totals          72    46      63.89   
Total Bits      4844  3969    81.94   
Total Bits 0->1 2422  1984    81.92   
Total Bits 1->0 2422  1985    81.96   

                                
Ports          48   29   60.42  
Port Bits      3878 3155 81.36  
Port Bits 0->1 1939 1577 81.33  
Port Bits 1->0 1939 1578 81.38  

                                
Signals          24  17  70.83  
Signal Bits      966 814 84.27  
Signal Bits 0->1 483 407 84.27  
Signal Bits 1->0 483 407 84.27  

Port Details
                                     Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i                                Yes    Yes         Yes         INPUT     
rst_i                                No     Yes         No          INPUT     
mshr_entry_idx_i[3:0]                No     No          No          INPUT     
mshr_entry_o.mem_tag[3:0]            Yes    Yes         Yes         OUTPUT    
mshr_entry_o.linked                  No     No          No          OUTPUT    
mshr_entry_o.link_idx[3:0]           No     No          No          OUTPUT    
mshr_entry_o.evict_dirty             Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_data[63:0]        Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_addr[2:0]         No     No          No          OUTPUT    
mshr_entry_o.evict_addr[15:3]        Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_addr[31:16]       No     No          No          OUTPUT    
mshr_entry_o.req_size[1:0]           Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_data[63:0]          Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_addr[15:0]          Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_addr[31:16]         No     No          No          OUTPUT    
mshr_entry_o.cmd[1:0]                Yes    Yes         Yes         OUTPUT    
mshr_entry_o.state[2:0]              Yes    Yes         Yes         OUTPUT    
proc_grant_i                         Yes    Yes         Yes         INPUT     
proc2cache_i.command[1:0]            Yes    Yes         Yes         INPUT     
proc2cache_i.size[1:0]               Yes    Yes         Yes         INPUT     
proc2cache_i.data[63:0]              Yes    Yes         Yes         INPUT     
proc2cache_i.addr[15:0]              Yes    Yes         Yes         INPUT     
proc2cache_i.addr[31:16]             No     No          No          INPUT     
mshr_proc_o.tag[2:0]                 No     No          No          OUTPUT    
mshr_proc_o.tag[3]                   Yes    Yes         Yes         OUTPUT    
mshr_proc_o.data[63:0]               No     No          No          OUTPUT    
mshr_proc_o.response[2:0]            No     No          No          OUTPUT    
mshr_proc_o.response[3]              Yes    Yes         Yes         OUTPUT    
cache_mem_grant_i                    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.evict_data[63:0]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.evict_addr[2:0]     No     No          No          INPUT     
cache_mem_ctrl_i.evict_addr[15:3]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.evict_addr[31:16]   No     No          No          INPUT     
cache_mem_ctrl_i.evict_dirty         Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[4:0]   Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[6:5]   No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[8:7]   Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[11:9]  No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[13:12] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[15:14] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[25:16] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[26]    No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[31:27] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[33:32] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[34]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[37:35] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[38]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[41:39] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[42]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[45:43] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[47:46] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[50:48] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[52:51] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[54:53] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[58:55] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[60:59] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[63:61] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_hit             Yes    Yes         Yes         INPUT     
mshr_cache_mem_o.req_data_in[63:0]   Yes    Yes         Yes         OUTPUT    
mshr_cache_mem_o.req_addr[15:0]      Yes    Yes         Yes         OUTPUT    
mshr_cache_mem_o.req_addr[31:16]     No     No          No          OUTPUT    
mshr_cache_mem_o.req_cmd[2:0]        Yes    Yes         Yes         OUTPUT    
memory_grant_i                       Yes    Yes         Yes         INPUT     
mem2cache_i.tag[3:0]                 Yes    Yes         Yes         INPUT     
mem2cache_i.data[63:0]               Yes    Yes         Yes         INPUT     
mem2cache_i.response[3:0]            Yes    Yes         Yes         INPUT     
mshr_memory_o.command[1:0]           Yes    Yes         Yes         OUTPUT    
mshr_memory_o.size[1:0]              No     No          No          OUTPUT    
mshr_memory_o.data[63:0]             Yes    Yes         Yes         OUTPUT    
mshr_memory_o.addr[2:0]              No     No          No          OUTPUT    
mshr_memory_o.addr[15:3]             Yes    Yes         Yes         OUTPUT    
mshr_memory_o.addr[31:16]            No     No          No          OUTPUT    
mshr_hit_i                           Yes    Yes         Yes         INPUT     
mshr_hit_idx_i[3:0]                  Yes    Yes         Yes         INPUT     
evict_hit_i                          No     No          No          INPUT     
evict_hit_idx_i[3:0]                 No     No          No          INPUT     
dp_sel_i                             Yes    Yes         Yes         INPUT     
mshr_cp_flag_o                       Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[63:0]                 Yes    Yes         Yes         OUTPUT    
cp_flag_i[0]                         No     No          No          INPUT     
cp_flag_i[15:1]                      Yes    Yes         Yes         INPUT     
cp_data_i[8:1][63:0]                 Yes    Yes         Yes         INPUT     
cp_data_i[9][44:0]                   Yes    Yes         Yes         INPUT     
cp_data_i[9][63:46]                  Yes    Yes         Yes         INPUT     
cp_data_i[10][30:1]                  Yes    Yes         Yes         INPUT     
cp_data_i[10][36:32]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][41:40]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][45]                    Yes    Yes         Yes         INPUT     
cp_data_i[10][49:47]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][52:51]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][56:55]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][60]                    Yes    Yes         Yes         INPUT     
cp_data_i[10][62]                    Yes    Yes         Yes         INPUT     
cp_data_i[11][27:0]                  Yes    Yes         Yes         INPUT     
cp_data_i[11][36:29]                 Yes    Yes         Yes         INPUT     
cp_data_i[11][49:39]                 Yes    Yes         Yes         INPUT     
cp_data_i[11][51]                    Yes    Yes         Yes         INPUT     
cp_data_i[11][59:54]                 Yes    Yes         Yes         INPUT     
cp_data_i[11][63:62]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][4:0]                   Yes    Yes         Yes         INPUT     
cp_data_i[12][27:6]                  Yes    Yes         Yes         INPUT     
cp_data_i[12][31:29]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][35:33]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][39]                    Yes    Yes         Yes         INPUT     
cp_data_i[12][44:43]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][48:46]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][50]                    Yes    Yes         Yes         INPUT     
cp_data_i[12][54]                    Yes    Yes         Yes         INPUT     
cp_data_i[12][58:57]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][61]                    Yes    Yes         Yes         INPUT     
cp_data_i[13][17:0]                  Yes    Yes         Yes         INPUT     
cp_data_i[13][46:19]                 Yes    Yes         Yes         INPUT     
cp_data_i[13][49]                    Yes    Yes         Yes         INPUT     
cp_data_i[13][56:51]                 Yes    Yes         Yes         INPUT     
cp_data_i[13][63:58]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][14:1]                  Yes    Yes         Yes         INPUT     
cp_data_i[14][19:16]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][21]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][24:23]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][27]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][32:30]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][37:35]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][39]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][41]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][43]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][46:45]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][51:49]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][59:53]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][62:61]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][15:0]                  Yes    Yes         Yes         INPUT     
cp_data_i[15][37:17]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][40:39]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][42]                    Yes    Yes         Yes         INPUT     
cp_data_i[15][45:44]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][48:47]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][53:51]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][55]                    Yes    Yes         Yes         INPUT     
cp_data_i[15][63:57]                 Yes    Yes         Yes         INPUT     
Other bits of cp_data_i[15:0][63:0]  No     No          No          INPUT     

Signal Details
                                  Toggle Toggle 1->0 Toggle 0->1 
mshr_entry.mem_tag[3:0]           Yes    Yes         Yes         
mshr_entry.linked                 No     No          No          
mshr_entry.link_idx[3:0]          No     No          No          
mshr_entry.evict_dirty            Yes    Yes         Yes         
mshr_entry.evict_data[63:0]       Yes    Yes         Yes         
mshr_entry.evict_addr[2:0]        No     No          No          
mshr_entry.evict_addr[15:3]       Yes    Yes         Yes         
mshr_entry.evict_addr[31:16]      No     No          No          
mshr_entry.req_size[1:0]          Yes    Yes         Yes         
mshr_entry.req_data[63:0]         Yes    Yes         Yes         
mshr_entry.req_addr[15:0]         Yes    Yes         Yes         
mshr_entry.req_addr[31:16]        No     No          No          
mshr_entry.cmd[1:0]               Yes    Yes         Yes         
mshr_entry.state[2:0]             Yes    Yes         Yes         
next_mshr_entry.mem_tag[3:0]      Yes    Yes         Yes         
next_mshr_entry.linked            Yes    Yes         Yes         
next_mshr_entry.link_idx[2:0]     Yes    Yes         Yes         
next_mshr_entry.link_idx[3]       No     No          No          
next_mshr_entry.evict_dirty       Yes    Yes         Yes         
next_mshr_entry.evict_data[63:0]  Yes    Yes         Yes         
next_mshr_entry.evict_addr[2:0]   No     No          No          
next_mshr_entry.evict_addr[15:3]  Yes    Yes         Yes         
next_mshr_entry.evict_addr[31:16] No     No          No          
next_mshr_entry.req_size[1:0]     Yes    Yes         Yes         
next_mshr_entry.req_data[63:0]    Yes    Yes         Yes         
next_mshr_entry.req_addr[15:0]    Yes    Yes         Yes         
next_mshr_entry.req_addr[31:16]   No     No          No          
next_mshr_entry.cmd[1:0]          Yes    Yes         Yes         
next_mshr_entry.state[2:0]        Yes    Yes         Yes         
next_mshr_cp_flag                 Yes    Yes         Yes         
next_mshr_cp_data[63:0]           Yes    Yes         Yes         


-------------------------------------------------------------------------------
===============================================================================
Module Instance : cache_tb.dut.cache_ctrl_inst.genblk1[9].mshr_entry_ctrl_inst
===============================================================================

Instance :

SCORE  LINE   TOGGLE 
 83.68  85.71  81.65 


Instance's subtree :

SCORE  LINE   TOGGLE 
 83.68  85.71  81.65 


Module : 

SCORE  LINE   TOGGLE NAME            
 87.59  90.48  84.70 mshr_entry_ctrl 


Parent : 

SCORE  LINE   TOGGLE NAME            
 92.38 100.00  84.76 cache_ctrl_inst 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : cache_tb.dut.cache_ctrl_inst.genblk1[9].mshr_entry_ctrl_inst

             Line No.   Total   Covered  Percent
TOTAL                      210      180    85.71
ALWAYS             75       17       17   100.00
ALWAYS             97      135      113    83.70
ALWAYS            317       25       17    68.00
ALWAYS            368       22       22   100.00
ALWAYS            411       11       11   100.00

74                          always_ff @(posedge clk_i) begin
75         1/1                  if (rst_i) begin
76         1/1                      mshr_entry.state        <=  `SD ST_IDLE     ;
77         1/1                      mshr_entry.cmd          <=  `SD BUS_NONE    ;
78         1/1                      mshr_entry.req_addr     <=  `SD 'b0         ;
79         1/1                      mshr_entry.req_data     <=  `SD 'b0         ;
80         1/1                      mshr_entry.req_size     <=  `SD BYTE        ;
81         1/1                      mshr_entry.evict_addr   <=  `SD 'b0         ;
82         1/1                      mshr_entry.evict_data   <=  `SD 'b0         ;
83         1/1                      mshr_entry.evict_dirty  <=  `SD 1'b0        ;
84         1/1                      mshr_entry.link_idx     <=  `SD 'd0         ;
85         1/1                      mshr_entry.linked       <=  `SD 1'b0        ;
86         1/1                      mshr_entry.mem_tag      <=  `SD 'd0         ;
87         1/1                      mshr_cp_flag_o          <=  `SD 1'b0        ;
88         1/1                      mshr_cp_data_o          <=  `SD 'b0         ;
89                              end else begin
90         1/1                      mshr_entry              <=  `SD next_mshr_entry     ;
91         1/1                      mshr_cp_flag_o          <=  `SD next_mshr_cp_flag   ;
92         1/1                      mshr_cp_data_o          <=  `SD next_mshr_cp_data   ;
93                              end
94                          end
95                      
96                          always_comb begin
97         1/1                  next_mshr_entry.state       =   mshr_entry.state        ;
98         1/1                  next_mshr_entry.cmd         =   mshr_entry.cmd          ;
99         1/1                  next_mshr_entry.req_addr    =   mshr_entry.req_addr     ;
100        1/1                  next_mshr_entry.req_data    =   mshr_entry.req_data     ;
101        1/1                  next_mshr_entry.req_size    =   mshr_entry.req_size     ;
102        1/1                  next_mshr_entry.evict_addr  =   mshr_entry.evict_addr   ;
103        1/1                  next_mshr_entry.evict_data  =   mshr_entry.evict_data   ;
104        1/1                  next_mshr_entry.evict_dirty =   mshr_entry.evict_dirty  ;
105        1/1                  next_mshr_entry.link_idx    =   mshr_entry.link_idx     ;
106        1/1                  next_mshr_entry.linked      =   mshr_entry.linked       ;
107        1/1                  next_mshr_entry.mem_tag     =   mshr_entry.mem_tag      ;
108        1/1                  next_mshr_cp_flag           =   mshr_cp_flag_o          ;
109        1/1                  next_mshr_cp_data           =   mshr_cp_data_o          ;
110        1/1                  case (mshr_entry.state)
111                                 ST_IDLE     :   begin
112                                     // IF   there is a valid transaction on Processor Interface
113                                     // AND  the Processor Interface is granted to this entry
114                                     // AND  the cache_mem Interface is granted to this entry
115                                     // AND  it is a miss
116                                     // AND  the entry is selected to hold the new miss
117        1/1                          if ((proc2cache_i.command != BUS_NONE) && (dp_sel_i == 1'b1)
118                                     && (proc_grant_i == 1'b1)) begin
119                                         // IF   there is an older in-flight transaction to the same addreess
120                                         // ->   Wait for the completion of older miss to the same address
121        1/1                              if (mshr_hit_i && (cp_flag_i[mshr_hit_idx_i] == 1'b0)) begin
122        1/1                                  next_mshr_entry.state       =   ST_WAIT_DEPEND          ;
123        1/1                                  next_mshr_entry.link_idx    =   mshr_hit_idx_i          ;
124        1/1                                  next_mshr_entry.cmd         =   proc2cache_i.command    ;
125        1/1                                  next_mshr_entry.req_addr    =   proc2cache_i.addr       ;
126        1/1                                  next_mshr_entry.req_size    =   proc2cache_i.size       ;
127        1/1                                  if (proc2cache_i.command == BUS_STORE) begin
128        1/1                                      next_mshr_entry.req_data    =   proc2cache_i.data   ;
129                                             end
                        MISSING_ELSE
130                                         // IF   there is an older in-flight transaction that is in the middle of evicting the data block
131                                         // ->   Wait for the completion of write-back to memory
132        1/1                              end else if (evict_hit_i && (cp_flag_i[evict_hit_idx_i] == 1'b0)) begin
133        0/1     ==>                          next_mshr_entry.state       =   ST_WAIT_EVICT           ;
134        0/1     ==>                          next_mshr_entry.link_idx    =   evict_hit_idx_i         ;
135        0/1     ==>                          next_mshr_entry.cmd         =   proc2cache_i.command    ;
136        0/1     ==>                          next_mshr_entry.req_addr    =   proc2cache_i.addr       ;
137        0/1     ==>                          next_mshr_entry.req_size    =   proc2cache_i.size       ;
138        0/1     ==>                          if (proc2cache_i.command == BUS_STORE) begin
139        0/1     ==>                              next_mshr_entry.req_data    =   proc2cache_i.data   ;
140                                             end
                   ==>  MISSING_ELSE
141                                         // IF   it is a miss, and no dependency to older in-flight transactions.
142                                         // ->   Start miss handling
143        1/1                              end else if ((cache_mem_ctrl_i.req_hit == 1'b0) && (cache_mem_grant_i == 1'b1)) begin
144        1/1                                  next_mshr_entry.state       =   ST_RD_MEM               ;
145        1/1                                  next_mshr_entry.link_idx    =   'd0                     ;
146        1/1                                  next_mshr_entry.cmd         =   proc2cache_i.command    ;
147        1/1                                  next_mshr_entry.req_addr    =   proc2cache_i.addr       ;
148        1/1                                  next_mshr_entry.req_size    =   proc2cache_i.size       ;
149        1/1                                  if (proc2cache_i.command == BUS_STORE) begin
150        1/1                                      next_mshr_entry.req_data    =   proc2cache_i.data   ;
151                                             end
                        MISSING_ELSE
152                                         end
                        MISSING_ELSE
153                                     end
                        MISSING_ELSE
154        1/1                          next_mshr_cp_flag   =   1'b0    ;
155        1/1                          next_mshr_cp_data   =   'b0     ;
156                                 end
157                                 ST_WAIT_DEPEND  :   begin
158                                     // IF   the older transaction that the entry is linked to completed
159                                     // ->   Update the cache data
160        0/1     ==>                  if (cp_flag_i[mshr_entry.link_idx] == 1'b1) begin
161        0/1     ==>                      next_mshr_entry.state       =   ST_UPDATE   ;
162        0/1     ==>                      next_mshr_entry.link_idx    =   'd0         ;
163        0/1     ==>                      next_mshr_entry.req_data    =   cp_data_i[mshr_entry.link_idx];
164        0/1     ==>                      if (mshr_entry.cmd == BUS_STORE) begin
165        0/1     ==>                          case (mshr_entry.req_size)
166        0/1     ==>                              BYTE    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +:  8]    =   mshr_entry.req_data[ 7:0]   ;
167        0/1     ==>                              HALF    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +: 16]    =   mshr_entry.req_data[15:0]   ;
168        0/1     ==>                              WORD    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +: 32]    =   mshr_entry.req_data[31:0]   ;
169        0/1     ==>                              DOUBLE  :   next_mshr_entry.req_data                                    =   mshr_entry.req_data         ;
170        0/1     ==>                              default :   next_mshr_entry.req_data                                    =   mshr_entry.req_data         ;
171                                             endcase
172                                         end
                   ==>  MISSING_ELSE
173                                     end
                   ==>  MISSING_ELSE
174                                 end
175                                 ST_WAIT_EVICT   : begin
176                                     // IF   the older transaction that evicts the cache block completed
177                                     // ->   Read from Memory
178        0/1     ==>                  if (cp_flag_i[mshr_entry.link_idx] == 1'b1) begin
179        0/1     ==>                      next_mshr_entry.state       =   ST_RD_MEM   ;
180        0/1     ==>                      next_mshr_entry.link_idx    =   'd0         ;
181                                     end
                   ==>  MISSING_ELSE
182                                 end
183                                 ST_RD_MEM   :   begin
184                                     // IF   the read transaction is confirmed by Memory Interface
185                                     // ->   Wait for the data to return from Memory
186        1/1                          if ((memory_grant_i == 1'b1) && (mem2cache_i.response != 'd0)) begin
187        1/1                              next_mshr_entry.state       =   ST_WAIT_MEM             ;
188        1/1                              next_mshr_entry.mem_tag     =   mem2cache_i.response    ;
189                                     end
                        MISSING_ELSE
190                                 end
191                                 ST_WAIT_MEM :   begin
192                                     // IF   the data is returned from the Memory
193                                     // ->   Update the cache data
194        1/1                          if (mem2cache_i.tag == mshr_entry.mem_tag) begin
195        1/1                              next_mshr_entry.state       =   ST_UPDATE           ;
196        1/1                              next_mshr_entry.req_data    =   mem2cache_i.data    ;
197        1/1                              if (mshr_entry.cmd == BUS_STORE) begin
198        1/1                                  case (mshr_entry.req_size)
199        1/1                                      BYTE    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +:  8]    =   mshr_entry.req_data[ 7:0]   ;
200        1/1                                      HALF    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +: 16]    =   mshr_entry.req_data[15:0]   ;
201        1/1                                      WORD    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +: 32]    =   mshr_entry.req_data[31:0]   ;
202        1/1                                      DOUBLE  :   next_mshr_entry.req_data                                    =   mshr_entry.req_data         ;
203        0/1     ==>                              default :   next_mshr_entry.req_data                                    =   mshr_entry.req_data         ;
204                                             endcase
205                                         end
                        MISSING_ELSE
206                                     end
                        MISSING_ELSE
207                                 end
208                                 ST_UPDATE   :   begin
209                                     // IF   the req interface is granted to this entry
210        1/1                          if (cache_mem_grant_i == 1'b1) begin
211                                         // IF   it is a load miss
212                                         // ->   Output data to processor
213        1/1                              if (mshr_entry.cmd == BUS_LOAD) begin
214        1/1                                  next_mshr_entry.state       =   ST_OUTPUT;
215        1/1                                  next_mshr_entry.evict_addr  =   cache_mem_ctrl_i.evict_addr ;
216        1/1                                  next_mshr_entry.evict_data  =   cache_mem_ctrl_i.evict_data ;
217        1/1                                  next_mshr_entry.evict_dirty =   cache_mem_ctrl_i.evict_dirty;
218                                         // IF   a dirty block is evicted
219                                         // ->   Write back the evicted block
220        1/1                              end else if (cache_mem_ctrl_i.evict_dirty == 1'b1) begin
221        1/1                                  next_mshr_entry.state       =   ST_EVICT;
222        1/1                                  next_mshr_entry.evict_addr  =   cache_mem_ctrl_i.evict_addr ;
223        1/1                                  next_mshr_entry.evict_data  =   cache_mem_ctrl_i.evict_data ;
224        1/1                                  next_mshr_entry.evict_dirty =   cache_mem_ctrl_i.evict_dirty;
225                                         // ELSE
226                                         // ->   Miss Handling Completed
227                                         end else begin
228        1/1                                  next_mshr_entry.state       =   ST_IDLE             ;
229        1/1                                  next_mshr_entry.cmd         =   BUS_NONE            ;
230        1/1                                  next_mshr_entry.req_addr    =   'b0                 ;
231        1/1                                  next_mshr_entry.req_data    =   'b0                 ;
232        1/1                                  next_mshr_entry.req_size    =   BYTE                ;
233        1/1                                  next_mshr_entry.evict_addr  =   'b0                 ;
234        1/1                                  next_mshr_entry.evict_data  =   'b0                 ;
235        1/1                                  next_mshr_entry.evict_dirty =   1'b0                ;
236        1/1                                  next_mshr_entry.link_idx    =   'd0                 ;
237        1/1                                  next_mshr_entry.mem_tag     =   'd0                 ;
238        1/1                                  next_mshr_cp_flag           =   1'b1                ;
239        1/1                                  next_mshr_cp_data           =   mshr_entry.req_data ;
240                                         end
241                                     end
                        MISSING_ELSE
242                                 end
243                                 ST_OUTPUT   :   begin
244                                     // IF   the Processor Interface is granted to this entry
245        1/1                          if (proc_grant_i == 1'b1) begin
246                                         // IF   the evicted block is dirty
247                                         // ->   Write back the evicted block
248        1/1                              if (mshr_entry.evict_dirty == 1'b1) begin
249        1/1                                  next_mshr_entry.state       =   ST_EVICT;
250                                         // ELSE
251                                         // ->   Miss Handling Completed
252                                         end else begin
253        1/1                                  next_mshr_entry.state       =   ST_IDLE             ;
254        1/1                                  next_mshr_entry.cmd         =   BUS_NONE            ;
255        1/1                                  next_mshr_entry.req_addr    =   'b0                 ;
256        1/1                                  next_mshr_entry.req_data    =   'b0                 ;
257        1/1                                  next_mshr_entry.req_size    =   BYTE                ;
258        1/1                                  next_mshr_entry.evict_addr  =   'b0                 ;
259        1/1                                  next_mshr_entry.evict_data  =   'b0                 ;
260        1/1                                  next_mshr_entry.evict_dirty =   1'b0                ;
261        1/1                                  next_mshr_entry.link_idx    =   'd0                 ;
262        1/1                                  next_mshr_entry.mem_tag     =   'd0                 ;
263        1/1                                  next_mshr_cp_flag           =   1'b1                ;
264        1/1                                  next_mshr_cp_data           =   mshr_entry.req_data ;
265                                         end
266                                     end
                        MISSING_ELSE
267                                 end
268                                 ST_EVICT    :   begin
269                                     // IF   the write back transaction to Memory is confirmed
270                                     // ->   Miss Handling Completed
271        1/1                          if ((memory_grant_i == 1'b1) && (mem2cache_i.response != 'd0)) begin
272        1/1                              next_mshr_entry.state       =   ST_IDLE             ;
273        1/1                              next_mshr_entry.cmd         =   BUS_NONE            ;
274        1/1                              next_mshr_entry.req_addr    =   'b0                 ;
275        1/1                              next_mshr_entry.req_data    =   'b0                 ;
276        1/1                              next_mshr_entry.req_size    =   BYTE                ;
277        1/1                              next_mshr_entry.evict_addr  =   'b0                 ;
278        1/1                              next_mshr_entry.evict_data  =   'b0                 ;
279        1/1                              next_mshr_entry.evict_dirty =   1'b0                ;
280        1/1                              next_mshr_entry.link_idx    =   'd0                 ;
281        1/1                              next_mshr_entry.mem_tag     =   'd0                 ;
282        1/1                              next_mshr_cp_flag           =   1'b1                ;
283        1/1                              next_mshr_cp_data           =   mshr_entry.req_data ;
284                                     end
                        MISSING_ELSE
285                                 end
286                                 default     :   begin
287        1/1                          next_mshr_entry.state       =   ST_IDLE     ;
288        1/1                          next_mshr_entry.cmd         =   BUS_NONE    ;
289        1/1                          next_mshr_entry.req_addr    =   'b0         ;
290        1/1                          next_mshr_entry.req_data    =   'b0         ;
291        1/1                          next_mshr_entry.req_size    =   BYTE        ;
292        1/1                          next_mshr_entry.evict_addr  =   'b0         ;
293        1/1                          next_mshr_entry.evict_data  =   'b0         ;
294        1/1                          next_mshr_entry.evict_dirty =   1'b0        ;
295        1/1                          next_mshr_entry.link_idx    =   'd0         ;
296        1/1                          next_mshr_entry.mem_tag     =   'd0         ;
297        1/1                          next_mshr_cp_flag           =   1'b0        ;
298        1/1                          next_mshr_cp_data           =   'd0         ;
299                                 end
300                             endcase
301                     
302        1/1                  if (next_mshr_entry.state == ST_IDLE) begin
303        1/1                      next_mshr_entry.linked  =   1'b0;
304        1/1                  end else if ((mshr_hit_i == 1'b1) && (mshr_hit_idx_i == mshr_entry_idx_i)) begin
305        1/1                      next_mshr_entry.linked  =   1'b1;
306                             end
                        MISSING_ELSE
307                         end
308                     
309                     // --------------------------------------------------------------------
310                     // MSHR entry output
311                     // --------------------------------------------------------------------
312                         assign  mshr_entry_o    =   mshr_entry  ;
313                     // --------------------------------------------------------------------
314                     // Processor Interface
315                     // --------------------------------------------------------------------
316                         always_comb begin
317        1/1                  mshr_proc_o.response    =   'd0 ;
318        1/1                  mshr_proc_o.data        =   'b0 ;
319        1/1                  mshr_proc_o.tag         =   'd0 ;
320        1/1                  case (mshr_entry.state)
321                                 ST_IDLE     :   begin
322                                     // IF   the processor request is allocated to this entry
323        1/1                          if ((proc2cache_i.command != BUS_NONE) && (dp_sel_i == 1'b1)) begin
324                                         // IF   The Processor Interface is granted to this entry
325                                         // AND  there is a dependency to older in-flight transaction
326                                         // ->   Confirm the request
327        1/1                              if (((mshr_hit_i && (cp_flag_i[mshr_hit_idx_i] == 1'b0))
328                                         || (evict_hit_i && (cp_flag_i[evict_hit_idx_i] == 1'b0)))) begin
329        1/1                                  mshr_proc_o.response    =   mshr_entry_idx_i;
330                                         // IF   The Processor Interface is granted to this entry
331                                         // AND  The cache_mem Interface is granted to this entry
332                                         // ->   Confirm the request 
333        1/1                              end else if (cache_mem_grant_i == 1'b1) begin
334        1/1                                  mshr_proc_o.response    =   mshr_entry_idx_i;
335                                             // IF   it is a load hit
336                                             // ->   Output data and tag
337        1/1                                  if (cache_mem_ctrl_i.req_hit == 1'b1 && proc2cache_i.command == BUS_LOAD) begin
338        0/1     ==>                              mshr_proc_o.tag     =   mshr_entry_idx_i;
339        0/1     ==>                              case (proc2cache_i.size)
340        0/1     ==>                                  BYTE    :   mshr_proc_o.data    =   {56'b0,cache_mem_ctrl_i.req_data_out[proc2cache_i.addr[2:0]+: 8]};
341        0/1     ==>                                  HALF    :   mshr_proc_o.data    =   {48'b0,cache_mem_ctrl_i.req_data_out[proc2cache_i.addr[2:0]+:16]};
342        0/1     ==>                                  WORD    :   mshr_proc_o.data    =   {32'b0,cache_mem_ctrl_i.req_data_out[proc2cache_i.addr[2:0]+:32]};
343        0/1     ==>                                  DOUBLE  :   mshr_proc_o.data    =   cache_mem_ctrl_i.req_data_out;
344        0/1     ==>                                  default :   mshr_proc_o.data    =   cache_mem_ctrl_i.req_data_out;
345                                                 endcase
346                                             end
                        MISSING_ELSE
347                                         end
                        MISSING_ELSE
348                                     end
                        MISSING_ELSE
349                                 end
350                                 ST_OUTPUT   :   begin
351        1/1                          mshr_proc_o.response    =   'd0                 ;
352        1/1                          mshr_proc_o.tag         =   mshr_entry_idx_i    ;
353        1/1                          case (mshr_entry.req_size)
354        1/1                              BYTE    :   mshr_proc_o.data    =   {56'b0,mshr_entry.req_data[mshr_entry.req_addr[2:0]+: 8]};
355        1/1                              HALF    :   mshr_proc_o.data    =   {48'b0,mshr_entry.req_data[mshr_entry.req_addr[2:0]+:16]};
356        1/1                              WORD    :   mshr_proc_o.data    =   {32'b0,mshr_entry.req_data[mshr_entry.req_addr[2:0]+:32]};
357        1/1                              DOUBLE  :   mshr_proc_o.data    =   mshr_entry.req_data;
358        0/1     ==>                      default :   mshr_proc_o.data    =   mshr_entry.req_data;
359                                     endcase
360                                 end
                        MISSING_DEFAULT
361                             endcase
362                         end
363                     
364                     // --------------------------------------------------------------------
365                     // cache_mem Interface
366                     // --------------------------------------------------------------------
367                         always_comb begin
368        1/1                  mshr_cache_mem_o.req_cmd        =   REQ_NONE;
369        1/1                  mshr_cache_mem_o.req_addr       =   'b0     ;
370        1/1                  mshr_cache_mem_o.req_data_in    =   'b0     ;
371        1/1                  case (mshr_entry.state)
372                                 ST_IDLE:    begin
373                                     // IF   the processor request is allocated to this entry
374        1/1                          if (dp_sel_i == 1'b1) begin
375        1/1                              case (proc2cache_i.command)
376                                             BUS_LOAD    :   begin
377        1/1                                      mshr_cache_mem_o.req_cmd        =   REQ_LOAD                        ;
378        1/1                                      mshr_cache_mem_o.req_addr       =   proc2cache_i.addr               ;
379        1/1                                      mshr_cache_mem_o.req_data_in    =   cache_mem_ctrl_i.req_data_out   ;
380                                             end
381                                             BUS_STORE   :   begin
382        1/1                                      mshr_cache_mem_o.req_cmd        =   REQ_STORE                       ;
383        1/1                                      mshr_cache_mem_o.req_addr       =   proc2cache_i.addr               ;
384        1/1                                      mshr_cache_mem_o.req_data_in    =   cache_mem_ctrl_i.req_data_out   ;
385        1/1                                      case (proc2cache_i.size)
386        1/1                                          BYTE    :   mshr_cache_mem_o.req_data_in[proc2cache_i.addr[2:0] +:  8]  =   proc2cache_i.data[ 7:0] ;
387        1/1                                          HALF    :   mshr_cache_mem_o.req_data_in[proc2cache_i.addr[2:0] +: 16]  =   proc2cache_i.data[15:0] ;
388        1/1                                          WORD    :   mshr_cache_mem_o.req_data_in[proc2cache_i.addr[2:0] +: 32]  =   proc2cache_i.data[31:0] ;
389        1/1                                          DOUBLE  :   mshr_cache_mem_o.req_data_in                                =   proc2cache_i.data       ;
                   ==>  MISSING_DEFAULT
390                                                 endcase
391                                             end    
                        MISSING_DEFAULT
392                                         endcase
393                                     end
                        MISSING_ELSE
394                                 end
395                                 ST_UPDATE:  begin
396        1/1                          if (mshr_entry.cmd == BUS_LOAD) begin
397        1/1                              mshr_cache_mem_o.req_cmd    =   REQ_LOAD_MISS       ;
398                                     end else begin
399        1/1                              mshr_cache_mem_o.req_cmd    =   REQ_STORE_MISS      ;
400                                     end
401        1/1                          mshr_cache_mem_o.req_addr       =   mshr_entry.req_addr ;
402        1/1                          mshr_cache_mem_o.req_data_in    =   mshr_entry.req_data ;
403                                 end
                        MISSING_DEFAULT
404                             endcase
405                         end
406                     
407                     // --------------------------------------------------------------------
408                     // Memory Interface
409                     // --------------------------------------------------------------------
410                         always_comb begin
411        1/1                  mshr_memory_o.addr      =   {mshr_entry.req_addr[C_XLEN-1:C_CACHE_OFFSET_WIDTH], {C_CACHE_OFFSET_WIDTH{1'b0}}};
412        1/1                  mshr_memory_o.size      =   DOUBLE              ;
413        1/1                  mshr_memory_o.command   =   BUS_NONE            ;
414        1/1                  mshr_memory_o.data      =   'd0 ;
415        1/1                  case (mshr_entry.state)
416                                 ST_RD_MEM   :   begin
417        1/1                          mshr_memory_o.data      =   'd0 ;
418        1/1                          mshr_memory_o.addr      =   {mshr_entry.req_addr[C_XLEN-1:C_CACHE_OFFSET_WIDTH], {C_CACHE_OFFSET_WIDTH{1'b0}}};
419        1/1                          mshr_memory_o.command   =   BUS_LOAD;
420                                 end
421                                 ST_EVICT    :   begin
422        1/1                          mshr_memory_o.data      =   mshr_entry.evict_data;
423        1/1                          mshr_memory_o.addr      =   {mshr_entry.evict_addr[C_XLEN-1:C_CACHE_OFFSET_WIDTH], {C_CACHE_OFFSET_WIDTH{1'b0}}};
424        1/1                          mshr_memory_o.command   =   BUS_STORE;
425                                 end
                        MISSING_DEFAULT

-------------------------------------------------------------------------------
Toggle Coverage for Instance : cache_tb.dut.cache_ctrl_inst.genblk1[9].mshr_entry_ctrl_inst
                Total Covered Percent 
Totals          72    39      54.17   
Total Bits      4844  3955    81.65   
Total Bits 0->1 2422  1977    81.63   
Total Bits 1->0 2422  1978    81.67   

                                
Ports          48   25   52.08  
Port Bits      3878 3149 81.20  
Port Bits 0->1 1939 1574 81.18  
Port Bits 1->0 1939 1575 81.23  

                                
Signals          24  14  58.33  
Signal Bits      966 806 83.44  
Signal Bits 0->1 483 403 83.44  
Signal Bits 1->0 483 403 83.44  

Port Details
                                     Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i                                Yes    Yes         Yes         INPUT     
rst_i                                No     Yes         No          INPUT     
mshr_entry_idx_i[3:0]                No     No          No          INPUT     
mshr_entry_o.mem_tag[3:0]            Yes    Yes         Yes         OUTPUT    
mshr_entry_o.linked                  No     No          No          OUTPUT    
mshr_entry_o.link_idx[3:0]           No     No          No          OUTPUT    
mshr_entry_o.evict_dirty             Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_data[59:0]        Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_data[60]          No     No          No          OUTPUT    
mshr_entry_o.evict_data[63:61]       Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_addr[2:0]         No     No          No          OUTPUT    
mshr_entry_o.evict_addr[15:3]        Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_addr[31:16]       No     No          No          OUTPUT    
mshr_entry_o.req_size[1:0]           Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_data[44:0]          Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_data[45]            No     No          No          OUTPUT    
mshr_entry_o.req_data[63:46]         Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_addr[0]             No     No          No          OUTPUT    
mshr_entry_o.req_addr[15:1]          Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_addr[31:16]         No     No          No          OUTPUT    
mshr_entry_o.cmd[1:0]                Yes    Yes         Yes         OUTPUT    
mshr_entry_o.state[2:0]              Yes    Yes         Yes         OUTPUT    
proc_grant_i                         Yes    Yes         Yes         INPUT     
proc2cache_i.command[1:0]            Yes    Yes         Yes         INPUT     
proc2cache_i.size[1:0]               Yes    Yes         Yes         INPUT     
proc2cache_i.data[63:0]              Yes    Yes         Yes         INPUT     
proc2cache_i.addr[15:0]              Yes    Yes         Yes         INPUT     
proc2cache_i.addr[31:16]             No     No          No          INPUT     
mshr_proc_o.tag[0]                   Yes    Yes         Yes         OUTPUT    
mshr_proc_o.tag[2:1]                 No     No          No          OUTPUT    
mshr_proc_o.tag[3]                   Yes    Yes         Yes         OUTPUT    
mshr_proc_o.data[63:0]               No     No          No          OUTPUT    
mshr_proc_o.response[0]              Yes    Yes         Yes         OUTPUT    
mshr_proc_o.response[2:1]            No     No          No          OUTPUT    
mshr_proc_o.response[3]              Yes    Yes         Yes         OUTPUT    
cache_mem_grant_i                    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.evict_data[63:0]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.evict_addr[2:0]     No     No          No          INPUT     
cache_mem_ctrl_i.evict_addr[15:3]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.evict_addr[31:16]   No     No          No          INPUT     
cache_mem_ctrl_i.evict_dirty         Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[4:0]   Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[6:5]   No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[8:7]   Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[11:9]  No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[13:12] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[15:14] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[25:16] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[26]    No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[31:27] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[33:32] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[34]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[37:35] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[38]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[41:39] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[42]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[45:43] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[47:46] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[50:48] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[52:51] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[54:53] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[58:55] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[60:59] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[63:61] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_hit             Yes    Yes         Yes         INPUT     
mshr_cache_mem_o.req_data_in[63:0]   Yes    Yes         Yes         OUTPUT    
mshr_cache_mem_o.req_addr[15:0]      Yes    Yes         Yes         OUTPUT    
mshr_cache_mem_o.req_addr[31:16]     No     No          No          OUTPUT    
mshr_cache_mem_o.req_cmd[2:0]        Yes    Yes         Yes         OUTPUT    
memory_grant_i                       Yes    Yes         Yes         INPUT     
mem2cache_i.tag[3:0]                 Yes    Yes         Yes         INPUT     
mem2cache_i.data[63:0]               Yes    Yes         Yes         INPUT     
mem2cache_i.response[3:0]            Yes    Yes         Yes         INPUT     
mshr_memory_o.command[1:0]           Yes    Yes         Yes         OUTPUT    
mshr_memory_o.size[1:0]              No     No          No          OUTPUT    
mshr_memory_o.data[59:0]             Yes    Yes         Yes         OUTPUT    
mshr_memory_o.data[60]               No     No          No          OUTPUT    
mshr_memory_o.data[63:61]            Yes    Yes         Yes         OUTPUT    
mshr_memory_o.addr[2:0]              No     No          No          OUTPUT    
mshr_memory_o.addr[15:3]             Yes    Yes         Yes         OUTPUT    
mshr_memory_o.addr[31:16]            No     No          No          OUTPUT    
mshr_hit_i                           Yes    Yes         Yes         INPUT     
mshr_hit_idx_i[3:0]                  Yes    Yes         Yes         INPUT     
evict_hit_i                          No     No          No          INPUT     
evict_hit_idx_i[3:0]                 No     No          No          INPUT     
dp_sel_i                             Yes    Yes         Yes         INPUT     
mshr_cp_flag_o                       Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[44:0]                 Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[45]                   No     No          No          OUTPUT    
mshr_cp_data_o[63:46]                Yes    Yes         Yes         OUTPUT    
cp_flag_i[0]                         No     No          No          INPUT     
cp_flag_i[15:1]                      Yes    Yes         Yes         INPUT     
cp_data_i[8:1][63:0]                 Yes    Yes         Yes         INPUT     
cp_data_i[9][44:0]                   Yes    Yes         Yes         INPUT     
cp_data_i[9][63:46]                  Yes    Yes         Yes         INPUT     
cp_data_i[10][30:1]                  Yes    Yes         Yes         INPUT     
cp_data_i[10][36:32]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][41:40]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][45]                    Yes    Yes         Yes         INPUT     
cp_data_i[10][49:47]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][52:51]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][56:55]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][60]                    Yes    Yes         Yes         INPUT     
cp_data_i[10][62]                    Yes    Yes         Yes         INPUT     
cp_data_i[11][27:0]                  Yes    Yes         Yes         INPUT     
cp_data_i[11][36:29]                 Yes    Yes         Yes         INPUT     
cp_data_i[11][49:39]                 Yes    Yes         Yes         INPUT     
cp_data_i[11][51]                    Yes    Yes         Yes         INPUT     
cp_data_i[11][59:54]                 Yes    Yes         Yes         INPUT     
cp_data_i[11][63:62]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][4:0]                   Yes    Yes         Yes         INPUT     
cp_data_i[12][27:6]                  Yes    Yes         Yes         INPUT     
cp_data_i[12][31:29]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][35:33]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][39]                    Yes    Yes         Yes         INPUT     
cp_data_i[12][44:43]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][48:46]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][50]                    Yes    Yes         Yes         INPUT     
cp_data_i[12][54]                    Yes    Yes         Yes         INPUT     
cp_data_i[12][58:57]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][61]                    Yes    Yes         Yes         INPUT     
cp_data_i[13][17:0]                  Yes    Yes         Yes         INPUT     
cp_data_i[13][46:19]                 Yes    Yes         Yes         INPUT     
cp_data_i[13][49]                    Yes    Yes         Yes         INPUT     
cp_data_i[13][56:51]                 Yes    Yes         Yes         INPUT     
cp_data_i[13][63:58]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][14:1]                  Yes    Yes         Yes         INPUT     
cp_data_i[14][19:16]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][21]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][24:23]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][27]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][32:30]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][37:35]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][39]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][41]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][43]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][46:45]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][51:49]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][59:53]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][62:61]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][15:0]                  Yes    Yes         Yes         INPUT     
cp_data_i[15][37:17]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][40:39]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][42]                    Yes    Yes         Yes         INPUT     
cp_data_i[15][45:44]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][48:47]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][53:51]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][55]                    Yes    Yes         Yes         INPUT     
cp_data_i[15][63:57]                 Yes    Yes         Yes         INPUT     
Other bits of cp_data_i[15:0][63:0]  No     No          No          INPUT     

Signal Details
                                  Toggle Toggle 1->0 Toggle 0->1 
mshr_entry.mem_tag[3:0]           Yes    Yes         Yes         
mshr_entry.linked                 No     No          No          
mshr_entry.link_idx[3:0]          No     No          No          
mshr_entry.evict_dirty            Yes    Yes         Yes         
mshr_entry.evict_data[59:0]       Yes    Yes         Yes         
mshr_entry.evict_data[60]         No     No          No          
mshr_entry.evict_data[63:61]      Yes    Yes         Yes         
mshr_entry.evict_addr[2:0]        No     No          No          
mshr_entry.evict_addr[15:3]       Yes    Yes         Yes         
mshr_entry.evict_addr[31:16]      No     No          No          
mshr_entry.req_size[1:0]          Yes    Yes         Yes         
mshr_entry.req_data[44:0]         Yes    Yes         Yes         
mshr_entry.req_data[45]           No     No          No          
mshr_entry.req_data[63:46]        Yes    Yes         Yes         
mshr_entry.req_addr[0]            No     No          No          
mshr_entry.req_addr[15:1]         Yes    Yes         Yes         
mshr_entry.req_addr[31:16]        No     No          No          
mshr_entry.cmd[1:0]               Yes    Yes         Yes         
mshr_entry.state[2:0]             Yes    Yes         Yes         
next_mshr_entry.mem_tag[3:0]      Yes    Yes         Yes         
next_mshr_entry.linked            Yes    Yes         Yes         
next_mshr_entry.link_idx[3:0]     Yes    Yes         Yes         
next_mshr_entry.evict_dirty       Yes    Yes         Yes         
next_mshr_entry.evict_data[59:0]  Yes    Yes         Yes         
next_mshr_entry.evict_data[60]    No     No          No          
next_mshr_entry.evict_data[63:61] Yes    Yes         Yes         
next_mshr_entry.evict_addr[2:0]   No     No          No          
next_mshr_entry.evict_addr[15:3]  Yes    Yes         Yes         
next_mshr_entry.evict_addr[31:16] No     No          No          
next_mshr_entry.req_size[1:0]     Yes    Yes         Yes         
next_mshr_entry.req_data[63:0]    Yes    Yes         Yes         
next_mshr_entry.req_addr[15:0]    Yes    Yes         Yes         
next_mshr_entry.req_addr[31:16]   No     No          No          
next_mshr_entry.cmd[1:0]          Yes    Yes         Yes         
next_mshr_entry.state[2:0]        Yes    Yes         Yes         
next_mshr_cp_flag                 Yes    Yes         Yes         
next_mshr_cp_data[44:0]           Yes    Yes         Yes         
next_mshr_cp_data[45]             No     No          No          
next_mshr_cp_data[63:46]          Yes    Yes         Yes         


-------------------------------------------------------------------------------
===============================================================================
Module Instance : cache_tb.dut.cache_ctrl_inst.genblk1[2].mshr_entry_ctrl_inst
===============================================================================

Instance :

SCORE  LINE   TOGGLE 
 84.01  85.71  82.31 


Instance's subtree :

SCORE  LINE   TOGGLE 
 84.01  85.71  82.31 


Module : 

SCORE  LINE   TOGGLE NAME            
 87.59  90.48  84.70 mshr_entry_ctrl 


Parent : 

SCORE  LINE   TOGGLE NAME            
 92.38 100.00  84.76 cache_ctrl_inst 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : cache_tb.dut.cache_ctrl_inst.genblk1[2].mshr_entry_ctrl_inst

             Line No.   Total   Covered  Percent
TOTAL                      210      180    85.71
ALWAYS             75       17       17   100.00
ALWAYS             97      135      113    83.70
ALWAYS            317       25       17    68.00
ALWAYS            368       22       22   100.00
ALWAYS            411       11       11   100.00

74                          always_ff @(posedge clk_i) begin
75         1/1                  if (rst_i) begin
76         1/1                      mshr_entry.state        <=  `SD ST_IDLE     ;
77         1/1                      mshr_entry.cmd          <=  `SD BUS_NONE    ;
78         1/1                      mshr_entry.req_addr     <=  `SD 'b0         ;
79         1/1                      mshr_entry.req_data     <=  `SD 'b0         ;
80         1/1                      mshr_entry.req_size     <=  `SD BYTE        ;
81         1/1                      mshr_entry.evict_addr   <=  `SD 'b0         ;
82         1/1                      mshr_entry.evict_data   <=  `SD 'b0         ;
83         1/1                      mshr_entry.evict_dirty  <=  `SD 1'b0        ;
84         1/1                      mshr_entry.link_idx     <=  `SD 'd0         ;
85         1/1                      mshr_entry.linked       <=  `SD 1'b0        ;
86         1/1                      mshr_entry.mem_tag      <=  `SD 'd0         ;
87         1/1                      mshr_cp_flag_o          <=  `SD 1'b0        ;
88         1/1                      mshr_cp_data_o          <=  `SD 'b0         ;
89                              end else begin
90         1/1                      mshr_entry              <=  `SD next_mshr_entry     ;
91         1/1                      mshr_cp_flag_o          <=  `SD next_mshr_cp_flag   ;
92         1/1                      mshr_cp_data_o          <=  `SD next_mshr_cp_data   ;
93                              end
94                          end
95                      
96                          always_comb begin
97         1/1                  next_mshr_entry.state       =   mshr_entry.state        ;
98         1/1                  next_mshr_entry.cmd         =   mshr_entry.cmd          ;
99         1/1                  next_mshr_entry.req_addr    =   mshr_entry.req_addr     ;
100        1/1                  next_mshr_entry.req_data    =   mshr_entry.req_data     ;
101        1/1                  next_mshr_entry.req_size    =   mshr_entry.req_size     ;
102        1/1                  next_mshr_entry.evict_addr  =   mshr_entry.evict_addr   ;
103        1/1                  next_mshr_entry.evict_data  =   mshr_entry.evict_data   ;
104        1/1                  next_mshr_entry.evict_dirty =   mshr_entry.evict_dirty  ;
105        1/1                  next_mshr_entry.link_idx    =   mshr_entry.link_idx     ;
106        1/1                  next_mshr_entry.linked      =   mshr_entry.linked       ;
107        1/1                  next_mshr_entry.mem_tag     =   mshr_entry.mem_tag      ;
108        1/1                  next_mshr_cp_flag           =   mshr_cp_flag_o          ;
109        1/1                  next_mshr_cp_data           =   mshr_cp_data_o          ;
110        1/1                  case (mshr_entry.state)
111                                 ST_IDLE     :   begin
112                                     // IF   there is a valid transaction on Processor Interface
113                                     // AND  the Processor Interface is granted to this entry
114                                     // AND  the cache_mem Interface is granted to this entry
115                                     // AND  it is a miss
116                                     // AND  the entry is selected to hold the new miss
117        1/1                          if ((proc2cache_i.command != BUS_NONE) && (dp_sel_i == 1'b1)
118                                     && (proc_grant_i == 1'b1)) begin
119                                         // IF   there is an older in-flight transaction to the same addreess
120                                         // ->   Wait for the completion of older miss to the same address
121        1/1                              if (mshr_hit_i && (cp_flag_i[mshr_hit_idx_i] == 1'b0)) begin
122        1/1                                  next_mshr_entry.state       =   ST_WAIT_DEPEND          ;
123        1/1                                  next_mshr_entry.link_idx    =   mshr_hit_idx_i          ;
124        1/1                                  next_mshr_entry.cmd         =   proc2cache_i.command    ;
125        1/1                                  next_mshr_entry.req_addr    =   proc2cache_i.addr       ;
126        1/1                                  next_mshr_entry.req_size    =   proc2cache_i.size       ;
127        1/1                                  if (proc2cache_i.command == BUS_STORE) begin
128        1/1                                      next_mshr_entry.req_data    =   proc2cache_i.data   ;
129                                             end
                        MISSING_ELSE
130                                         // IF   there is an older in-flight transaction that is in the middle of evicting the data block
131                                         // ->   Wait for the completion of write-back to memory
132        1/1                              end else if (evict_hit_i && (cp_flag_i[evict_hit_idx_i] == 1'b0)) begin
133        0/1     ==>                          next_mshr_entry.state       =   ST_WAIT_EVICT           ;
134        0/1     ==>                          next_mshr_entry.link_idx    =   evict_hit_idx_i         ;
135        0/1     ==>                          next_mshr_entry.cmd         =   proc2cache_i.command    ;
136        0/1     ==>                          next_mshr_entry.req_addr    =   proc2cache_i.addr       ;
137        0/1     ==>                          next_mshr_entry.req_size    =   proc2cache_i.size       ;
138        0/1     ==>                          if (proc2cache_i.command == BUS_STORE) begin
139        0/1     ==>                              next_mshr_entry.req_data    =   proc2cache_i.data   ;
140                                             end
                   ==>  MISSING_ELSE
141                                         // IF   it is a miss, and no dependency to older in-flight transactions.
142                                         // ->   Start miss handling
143        1/1                              end else if ((cache_mem_ctrl_i.req_hit == 1'b0) && (cache_mem_grant_i == 1'b1)) begin
144        1/1                                  next_mshr_entry.state       =   ST_RD_MEM               ;
145        1/1                                  next_mshr_entry.link_idx    =   'd0                     ;
146        1/1                                  next_mshr_entry.cmd         =   proc2cache_i.command    ;
147        1/1                                  next_mshr_entry.req_addr    =   proc2cache_i.addr       ;
148        1/1                                  next_mshr_entry.req_size    =   proc2cache_i.size       ;
149        1/1                                  if (proc2cache_i.command == BUS_STORE) begin
150        1/1                                      next_mshr_entry.req_data    =   proc2cache_i.data   ;
151                                             end
                        MISSING_ELSE
152                                         end
                        MISSING_ELSE
153                                     end
                        MISSING_ELSE
154        1/1                          next_mshr_cp_flag   =   1'b0    ;
155        1/1                          next_mshr_cp_data   =   'b0     ;
156                                 end
157                                 ST_WAIT_DEPEND  :   begin
158                                     // IF   the older transaction that the entry is linked to completed
159                                     // ->   Update the cache data
160        0/1     ==>                  if (cp_flag_i[mshr_entry.link_idx] == 1'b1) begin
161        0/1     ==>                      next_mshr_entry.state       =   ST_UPDATE   ;
162        0/1     ==>                      next_mshr_entry.link_idx    =   'd0         ;
163        0/1     ==>                      next_mshr_entry.req_data    =   cp_data_i[mshr_entry.link_idx];
164        0/1     ==>                      if (mshr_entry.cmd == BUS_STORE) begin
165        0/1     ==>                          case (mshr_entry.req_size)
166        0/1     ==>                              BYTE    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +:  8]    =   mshr_entry.req_data[ 7:0]   ;
167        0/1     ==>                              HALF    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +: 16]    =   mshr_entry.req_data[15:0]   ;
168        0/1     ==>                              WORD    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +: 32]    =   mshr_entry.req_data[31:0]   ;
169        0/1     ==>                              DOUBLE  :   next_mshr_entry.req_data                                    =   mshr_entry.req_data         ;
170        0/1     ==>                              default :   next_mshr_entry.req_data                                    =   mshr_entry.req_data         ;
171                                             endcase
172                                         end
                   ==>  MISSING_ELSE
173                                     end
                   ==>  MISSING_ELSE
174                                 end
175                                 ST_WAIT_EVICT   : begin
176                                     // IF   the older transaction that evicts the cache block completed
177                                     // ->   Read from Memory
178        0/1     ==>                  if (cp_flag_i[mshr_entry.link_idx] == 1'b1) begin
179        0/1     ==>                      next_mshr_entry.state       =   ST_RD_MEM   ;
180        0/1     ==>                      next_mshr_entry.link_idx    =   'd0         ;
181                                     end
                   ==>  MISSING_ELSE
182                                 end
183                                 ST_RD_MEM   :   begin
184                                     // IF   the read transaction is confirmed by Memory Interface
185                                     // ->   Wait for the data to return from Memory
186        1/1                          if ((memory_grant_i == 1'b1) && (mem2cache_i.response != 'd0)) begin
187        1/1                              next_mshr_entry.state       =   ST_WAIT_MEM             ;
188        1/1                              next_mshr_entry.mem_tag     =   mem2cache_i.response    ;
189                                     end
                        MISSING_ELSE
190                                 end
191                                 ST_WAIT_MEM :   begin
192                                     // IF   the data is returned from the Memory
193                                     // ->   Update the cache data
194        1/1                          if (mem2cache_i.tag == mshr_entry.mem_tag) begin
195        1/1                              next_mshr_entry.state       =   ST_UPDATE           ;
196        1/1                              next_mshr_entry.req_data    =   mem2cache_i.data    ;
197        1/1                              if (mshr_entry.cmd == BUS_STORE) begin
198        1/1                                  case (mshr_entry.req_size)
199        1/1                                      BYTE    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +:  8]    =   mshr_entry.req_data[ 7:0]   ;
200        1/1                                      HALF    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +: 16]    =   mshr_entry.req_data[15:0]   ;
201        1/1                                      WORD    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +: 32]    =   mshr_entry.req_data[31:0]   ;
202        1/1                                      DOUBLE  :   next_mshr_entry.req_data                                    =   mshr_entry.req_data         ;
203        0/1     ==>                              default :   next_mshr_entry.req_data                                    =   mshr_entry.req_data         ;
204                                             endcase
205                                         end
                        MISSING_ELSE
206                                     end
                        MISSING_ELSE
207                                 end
208                                 ST_UPDATE   :   begin
209                                     // IF   the req interface is granted to this entry
210        1/1                          if (cache_mem_grant_i == 1'b1) begin
211                                         // IF   it is a load miss
212                                         // ->   Output data to processor
213        1/1                              if (mshr_entry.cmd == BUS_LOAD) begin
214        1/1                                  next_mshr_entry.state       =   ST_OUTPUT;
215        1/1                                  next_mshr_entry.evict_addr  =   cache_mem_ctrl_i.evict_addr ;
216        1/1                                  next_mshr_entry.evict_data  =   cache_mem_ctrl_i.evict_data ;
217        1/1                                  next_mshr_entry.evict_dirty =   cache_mem_ctrl_i.evict_dirty;
218                                         // IF   a dirty block is evicted
219                                         // ->   Write back the evicted block
220        1/1                              end else if (cache_mem_ctrl_i.evict_dirty == 1'b1) begin
221        1/1                                  next_mshr_entry.state       =   ST_EVICT;
222        1/1                                  next_mshr_entry.evict_addr  =   cache_mem_ctrl_i.evict_addr ;
223        1/1                                  next_mshr_entry.evict_data  =   cache_mem_ctrl_i.evict_data ;
224        1/1                                  next_mshr_entry.evict_dirty =   cache_mem_ctrl_i.evict_dirty;
225                                         // ELSE
226                                         // ->   Miss Handling Completed
227                                         end else begin
228        1/1                                  next_mshr_entry.state       =   ST_IDLE             ;
229        1/1                                  next_mshr_entry.cmd         =   BUS_NONE            ;
230        1/1                                  next_mshr_entry.req_addr    =   'b0                 ;
231        1/1                                  next_mshr_entry.req_data    =   'b0                 ;
232        1/1                                  next_mshr_entry.req_size    =   BYTE                ;
233        1/1                                  next_mshr_entry.evict_addr  =   'b0                 ;
234        1/1                                  next_mshr_entry.evict_data  =   'b0                 ;
235        1/1                                  next_mshr_entry.evict_dirty =   1'b0                ;
236        1/1                                  next_mshr_entry.link_idx    =   'd0                 ;
237        1/1                                  next_mshr_entry.mem_tag     =   'd0                 ;
238        1/1                                  next_mshr_cp_flag           =   1'b1                ;
239        1/1                                  next_mshr_cp_data           =   mshr_entry.req_data ;
240                                         end
241                                     end
                        MISSING_ELSE
242                                 end
243                                 ST_OUTPUT   :   begin
244                                     // IF   the Processor Interface is granted to this entry
245        1/1                          if (proc_grant_i == 1'b1) begin
246                                         // IF   the evicted block is dirty
247                                         // ->   Write back the evicted block
248        1/1                              if (mshr_entry.evict_dirty == 1'b1) begin
249        1/1                                  next_mshr_entry.state       =   ST_EVICT;
250                                         // ELSE
251                                         // ->   Miss Handling Completed
252                                         end else begin
253        1/1                                  next_mshr_entry.state       =   ST_IDLE             ;
254        1/1                                  next_mshr_entry.cmd         =   BUS_NONE            ;
255        1/1                                  next_mshr_entry.req_addr    =   'b0                 ;
256        1/1                                  next_mshr_entry.req_data    =   'b0                 ;
257        1/1                                  next_mshr_entry.req_size    =   BYTE                ;
258        1/1                                  next_mshr_entry.evict_addr  =   'b0                 ;
259        1/1                                  next_mshr_entry.evict_data  =   'b0                 ;
260        1/1                                  next_mshr_entry.evict_dirty =   1'b0                ;
261        1/1                                  next_mshr_entry.link_idx    =   'd0                 ;
262        1/1                                  next_mshr_entry.mem_tag     =   'd0                 ;
263        1/1                                  next_mshr_cp_flag           =   1'b1                ;
264        1/1                                  next_mshr_cp_data           =   mshr_entry.req_data ;
265                                         end
266                                     end
                        MISSING_ELSE
267                                 end
268                                 ST_EVICT    :   begin
269                                     // IF   the write back transaction to Memory is confirmed
270                                     // ->   Miss Handling Completed
271        1/1                          if ((memory_grant_i == 1'b1) && (mem2cache_i.response != 'd0)) begin
272        1/1                              next_mshr_entry.state       =   ST_IDLE             ;
273        1/1                              next_mshr_entry.cmd         =   BUS_NONE            ;
274        1/1                              next_mshr_entry.req_addr    =   'b0                 ;
275        1/1                              next_mshr_entry.req_data    =   'b0                 ;
276        1/1                              next_mshr_entry.req_size    =   BYTE                ;
277        1/1                              next_mshr_entry.evict_addr  =   'b0                 ;
278        1/1                              next_mshr_entry.evict_data  =   'b0                 ;
279        1/1                              next_mshr_entry.evict_dirty =   1'b0                ;
280        1/1                              next_mshr_entry.link_idx    =   'd0                 ;
281        1/1                              next_mshr_entry.mem_tag     =   'd0                 ;
282        1/1                              next_mshr_cp_flag           =   1'b1                ;
283        1/1                              next_mshr_cp_data           =   mshr_entry.req_data ;
284                                     end
                        MISSING_ELSE
285                                 end
286                                 default     :   begin
287        1/1                          next_mshr_entry.state       =   ST_IDLE     ;
288        1/1                          next_mshr_entry.cmd         =   BUS_NONE    ;
289        1/1                          next_mshr_entry.req_addr    =   'b0         ;
290        1/1                          next_mshr_entry.req_data    =   'b0         ;
291        1/1                          next_mshr_entry.req_size    =   BYTE        ;
292        1/1                          next_mshr_entry.evict_addr  =   'b0         ;
293        1/1                          next_mshr_entry.evict_data  =   'b0         ;
294        1/1                          next_mshr_entry.evict_dirty =   1'b0        ;
295        1/1                          next_mshr_entry.link_idx    =   'd0         ;
296        1/1                          next_mshr_entry.mem_tag     =   'd0         ;
297        1/1                          next_mshr_cp_flag           =   1'b0        ;
298        1/1                          next_mshr_cp_data           =   'd0         ;
299                                 end
300                             endcase
301                     
302        1/1                  if (next_mshr_entry.state == ST_IDLE) begin
303        1/1                      next_mshr_entry.linked  =   1'b0;
304        1/1                  end else if ((mshr_hit_i == 1'b1) && (mshr_hit_idx_i == mshr_entry_idx_i)) begin
305        1/1                      next_mshr_entry.linked  =   1'b1;
306                             end
                        MISSING_ELSE
307                         end
308                     
309                     // --------------------------------------------------------------------
310                     // MSHR entry output
311                     // --------------------------------------------------------------------
312                         assign  mshr_entry_o    =   mshr_entry  ;
313                     // --------------------------------------------------------------------
314                     // Processor Interface
315                     // --------------------------------------------------------------------
316                         always_comb begin
317        1/1                  mshr_proc_o.response    =   'd0 ;
318        1/1                  mshr_proc_o.data        =   'b0 ;
319        1/1                  mshr_proc_o.tag         =   'd0 ;
320        1/1                  case (mshr_entry.state)
321                                 ST_IDLE     :   begin
322                                     // IF   the processor request is allocated to this entry
323        1/1                          if ((proc2cache_i.command != BUS_NONE) && (dp_sel_i == 1'b1)) begin
324                                         // IF   The Processor Interface is granted to this entry
325                                         // AND  there is a dependency to older in-flight transaction
326                                         // ->   Confirm the request
327        1/1                              if (((mshr_hit_i && (cp_flag_i[mshr_hit_idx_i] == 1'b0))
328                                         || (evict_hit_i && (cp_flag_i[evict_hit_idx_i] == 1'b0)))) begin
329        1/1                                  mshr_proc_o.response    =   mshr_entry_idx_i;
330                                         // IF   The Processor Interface is granted to this entry
331                                         // AND  The cache_mem Interface is granted to this entry
332                                         // ->   Confirm the request 
333        1/1                              end else if (cache_mem_grant_i == 1'b1) begin
334        1/1                                  mshr_proc_o.response    =   mshr_entry_idx_i;
335                                             // IF   it is a load hit
336                                             // ->   Output data and tag
337        1/1                                  if (cache_mem_ctrl_i.req_hit == 1'b1 && proc2cache_i.command == BUS_LOAD) begin
338        0/1     ==>                              mshr_proc_o.tag     =   mshr_entry_idx_i;
339        0/1     ==>                              case (proc2cache_i.size)
340        0/1     ==>                                  BYTE    :   mshr_proc_o.data    =   {56'b0,cache_mem_ctrl_i.req_data_out[proc2cache_i.addr[2:0]+: 8]};
341        0/1     ==>                                  HALF    :   mshr_proc_o.data    =   {48'b0,cache_mem_ctrl_i.req_data_out[proc2cache_i.addr[2:0]+:16]};
342        0/1     ==>                                  WORD    :   mshr_proc_o.data    =   {32'b0,cache_mem_ctrl_i.req_data_out[proc2cache_i.addr[2:0]+:32]};
343        0/1     ==>                                  DOUBLE  :   mshr_proc_o.data    =   cache_mem_ctrl_i.req_data_out;
344        0/1     ==>                                  default :   mshr_proc_o.data    =   cache_mem_ctrl_i.req_data_out;
345                                                 endcase
346                                             end
                        MISSING_ELSE
347                                         end
                        MISSING_ELSE
348                                     end
                        MISSING_ELSE
349                                 end
350                                 ST_OUTPUT   :   begin
351        1/1                          mshr_proc_o.response    =   'd0                 ;
352        1/1                          mshr_proc_o.tag         =   mshr_entry_idx_i    ;
353        1/1                          case (mshr_entry.req_size)
354        1/1                              BYTE    :   mshr_proc_o.data    =   {56'b0,mshr_entry.req_data[mshr_entry.req_addr[2:0]+: 8]};
355        1/1                              HALF    :   mshr_proc_o.data    =   {48'b0,mshr_entry.req_data[mshr_entry.req_addr[2:0]+:16]};
356        1/1                              WORD    :   mshr_proc_o.data    =   {32'b0,mshr_entry.req_data[mshr_entry.req_addr[2:0]+:32]};
357        1/1                              DOUBLE  :   mshr_proc_o.data    =   mshr_entry.req_data;
358        0/1     ==>                      default :   mshr_proc_o.data    =   mshr_entry.req_data;
359                                     endcase
360                                 end
                        MISSING_DEFAULT
361                             endcase
362                         end
363                     
364                     // --------------------------------------------------------------------
365                     // cache_mem Interface
366                     // --------------------------------------------------------------------
367                         always_comb begin
368        1/1                  mshr_cache_mem_o.req_cmd        =   REQ_NONE;
369        1/1                  mshr_cache_mem_o.req_addr       =   'b0     ;
370        1/1                  mshr_cache_mem_o.req_data_in    =   'b0     ;
371        1/1                  case (mshr_entry.state)
372                                 ST_IDLE:    begin
373                                     // IF   the processor request is allocated to this entry
374        1/1                          if (dp_sel_i == 1'b1) begin
375        1/1                              case (proc2cache_i.command)
376                                             BUS_LOAD    :   begin
377        1/1                                      mshr_cache_mem_o.req_cmd        =   REQ_LOAD                        ;
378        1/1                                      mshr_cache_mem_o.req_addr       =   proc2cache_i.addr               ;
379        1/1                                      mshr_cache_mem_o.req_data_in    =   cache_mem_ctrl_i.req_data_out   ;
380                                             end
381                                             BUS_STORE   :   begin
382        1/1                                      mshr_cache_mem_o.req_cmd        =   REQ_STORE                       ;
383        1/1                                      mshr_cache_mem_o.req_addr       =   proc2cache_i.addr               ;
384        1/1                                      mshr_cache_mem_o.req_data_in    =   cache_mem_ctrl_i.req_data_out   ;
385        1/1                                      case (proc2cache_i.size)
386        1/1                                          BYTE    :   mshr_cache_mem_o.req_data_in[proc2cache_i.addr[2:0] +:  8]  =   proc2cache_i.data[ 7:0] ;
387        1/1                                          HALF    :   mshr_cache_mem_o.req_data_in[proc2cache_i.addr[2:0] +: 16]  =   proc2cache_i.data[15:0] ;
388        1/1                                          WORD    :   mshr_cache_mem_o.req_data_in[proc2cache_i.addr[2:0] +: 32]  =   proc2cache_i.data[31:0] ;
389        1/1                                          DOUBLE  :   mshr_cache_mem_o.req_data_in                                =   proc2cache_i.data       ;
                   ==>  MISSING_DEFAULT
390                                                 endcase
391                                             end    
                        MISSING_DEFAULT
392                                         endcase
393                                     end
                        MISSING_ELSE
394                                 end
395                                 ST_UPDATE:  begin
396        1/1                          if (mshr_entry.cmd == BUS_LOAD) begin
397        1/1                              mshr_cache_mem_o.req_cmd    =   REQ_LOAD_MISS       ;
398                                     end else begin
399        1/1                              mshr_cache_mem_o.req_cmd    =   REQ_STORE_MISS      ;
400                                     end
401        1/1                          mshr_cache_mem_o.req_addr       =   mshr_entry.req_addr ;
402        1/1                          mshr_cache_mem_o.req_data_in    =   mshr_entry.req_data ;
403                                 end
                        MISSING_DEFAULT
404                             endcase
405                         end
406                     
407                     // --------------------------------------------------------------------
408                     // Memory Interface
409                     // --------------------------------------------------------------------
410                         always_comb begin
411        1/1                  mshr_memory_o.addr      =   {mshr_entry.req_addr[C_XLEN-1:C_CACHE_OFFSET_WIDTH], {C_CACHE_OFFSET_WIDTH{1'b0}}};
412        1/1                  mshr_memory_o.size      =   DOUBLE              ;
413        1/1                  mshr_memory_o.command   =   BUS_NONE            ;
414        1/1                  mshr_memory_o.data      =   'd0 ;
415        1/1                  case (mshr_entry.state)
416                                 ST_RD_MEM   :   begin
417        1/1                          mshr_memory_o.data      =   'd0 ;
418        1/1                          mshr_memory_o.addr      =   {mshr_entry.req_addr[C_XLEN-1:C_CACHE_OFFSET_WIDTH], {C_CACHE_OFFSET_WIDTH{1'b0}}};
419        1/1                          mshr_memory_o.command   =   BUS_LOAD;
420                                 end
421                                 ST_EVICT    :   begin
422        1/1                          mshr_memory_o.data      =   mshr_entry.evict_data;
423        1/1                          mshr_memory_o.addr      =   {mshr_entry.evict_addr[C_XLEN-1:C_CACHE_OFFSET_WIDTH], {C_CACHE_OFFSET_WIDTH{1'b0}}};
424        1/1                          mshr_memory_o.command   =   BUS_STORE;
425                                 end
                        MISSING_DEFAULT

-------------------------------------------------------------------------------
Toggle Coverage for Instance : cache_tb.dut.cache_ctrl_inst.genblk1[2].mshr_entry_ctrl_inst
                Total Covered Percent 
Totals          72    47      65.28   
Total Bits      4844  3987    82.31   
Total Bits 0->1 2422  1993    82.29   
Total Bits 1->0 2422  1994    82.33   

                                
Ports          48   29   60.42  
Port Bits      3878 3171 81.77  
Port Bits 0->1 1939 1585 81.74  
Port Bits 1->0 1939 1586 81.79  

                                
Signals          24  18  75.00  
Signal Bits      966 816 84.47  
Signal Bits 0->1 483 408 84.47  
Signal Bits 1->0 483 408 84.47  

Port Details
                                     Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i                                Yes    Yes         Yes         INPUT     
rst_i                                No     Yes         No          INPUT     
mshr_entry_idx_i[3:0]                No     No          No          INPUT     
mshr_entry_o.mem_tag[3:0]            Yes    Yes         Yes         OUTPUT    
mshr_entry_o.linked                  No     No          No          OUTPUT    
mshr_entry_o.link_idx[3:0]           No     No          No          OUTPUT    
mshr_entry_o.evict_dirty             Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_data[63:0]        Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_addr[2:0]         No     No          No          OUTPUT    
mshr_entry_o.evict_addr[15:3]        Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_addr[31:16]       No     No          No          OUTPUT    
mshr_entry_o.req_size[1:0]           Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_data[63:0]          Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_addr[15:0]          Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_addr[31:16]         No     No          No          OUTPUT    
mshr_entry_o.cmd[1:0]                Yes    Yes         Yes         OUTPUT    
mshr_entry_o.state[2:0]              Yes    Yes         Yes         OUTPUT    
proc_grant_i                         Yes    Yes         Yes         INPUT     
proc2cache_i.command[1:0]            Yes    Yes         Yes         INPUT     
proc2cache_i.size[1:0]               Yes    Yes         Yes         INPUT     
proc2cache_i.data[63:0]              Yes    Yes         Yes         INPUT     
proc2cache_i.addr[15:0]              Yes    Yes         Yes         INPUT     
proc2cache_i.addr[31:16]             No     No          No          INPUT     
mshr_proc_o.tag[0]                   No     No          No          OUTPUT    
mshr_proc_o.tag[1]                   Yes    Yes         Yes         OUTPUT    
mshr_proc_o.tag[3:2]                 No     No          No          OUTPUT    
mshr_proc_o.data[7:0]                Yes    Yes         Yes         OUTPUT    
mshr_proc_o.data[63:8]               No     No          No          OUTPUT    
mshr_proc_o.response[0]              No     No          No          OUTPUT    
mshr_proc_o.response[1]              Yes    Yes         Yes         OUTPUT    
mshr_proc_o.response[3:2]            No     No          No          OUTPUT    
cache_mem_grant_i                    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.evict_data[63:0]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.evict_addr[2:0]     No     No          No          INPUT     
cache_mem_ctrl_i.evict_addr[15:3]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.evict_addr[31:16]   No     No          No          INPUT     
cache_mem_ctrl_i.evict_dirty         Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[4:0]   Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[6:5]   No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[8:7]   Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[11:9]  No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[13:12] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[15:14] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[25:16] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[26]    No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[31:27] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[33:32] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[34]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[37:35] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[38]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[41:39] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[42]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[45:43] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[47:46] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[50:48] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[52:51] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[54:53] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[58:55] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[60:59] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[63:61] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_hit             Yes    Yes         Yes         INPUT     
mshr_cache_mem_o.req_data_in[63:0]   Yes    Yes         Yes         OUTPUT    
mshr_cache_mem_o.req_addr[15:0]      Yes    Yes         Yes         OUTPUT    
mshr_cache_mem_o.req_addr[31:16]     No     No          No          OUTPUT    
mshr_cache_mem_o.req_cmd[2:0]        Yes    Yes         Yes         OUTPUT    
memory_grant_i                       Yes    Yes         Yes         INPUT     
mem2cache_i.tag[3:0]                 Yes    Yes         Yes         INPUT     
mem2cache_i.data[63:0]               Yes    Yes         Yes         INPUT     
mem2cache_i.response[3:0]            Yes    Yes         Yes         INPUT     
mshr_memory_o.command[1:0]           Yes    Yes         Yes         OUTPUT    
mshr_memory_o.size[1:0]              No     No          No          OUTPUT    
mshr_memory_o.data[63:0]             Yes    Yes         Yes         OUTPUT    
mshr_memory_o.addr[2:0]              No     No          No          OUTPUT    
mshr_memory_o.addr[15:3]             Yes    Yes         Yes         OUTPUT    
mshr_memory_o.addr[31:16]            No     No          No          OUTPUT    
mshr_hit_i                           Yes    Yes         Yes         INPUT     
mshr_hit_idx_i[3:0]                  Yes    Yes         Yes         INPUT     
evict_hit_i                          No     No          No          INPUT     
evict_hit_idx_i[3:0]                 No     No          No          INPUT     
dp_sel_i                             Yes    Yes         Yes         INPUT     
mshr_cp_flag_o                       Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[63:0]                 Yes    Yes         Yes         OUTPUT    
cp_flag_i[0]                         No     No          No          INPUT     
cp_flag_i[15:1]                      Yes    Yes         Yes         INPUT     
cp_data_i[8:1][63:0]                 Yes    Yes         Yes         INPUT     
cp_data_i[9][44:0]                   Yes    Yes         Yes         INPUT     
cp_data_i[9][63:46]                  Yes    Yes         Yes         INPUT     
cp_data_i[10][30:1]                  Yes    Yes         Yes         INPUT     
cp_data_i[10][36:32]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][41:40]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][45]                    Yes    Yes         Yes         INPUT     
cp_data_i[10][49:47]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][52:51]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][56:55]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][60]                    Yes    Yes         Yes         INPUT     
cp_data_i[10][62]                    Yes    Yes         Yes         INPUT     
cp_data_i[11][27:0]                  Yes    Yes         Yes         INPUT     
cp_data_i[11][36:29]                 Yes    Yes         Yes         INPUT     
cp_data_i[11][49:39]                 Yes    Yes         Yes         INPUT     
cp_data_i[11][51]                    Yes    Yes         Yes         INPUT     
cp_data_i[11][59:54]                 Yes    Yes         Yes         INPUT     
cp_data_i[11][63:62]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][4:0]                   Yes    Yes         Yes         INPUT     
cp_data_i[12][27:6]                  Yes    Yes         Yes         INPUT     
cp_data_i[12][31:29]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][35:33]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][39]                    Yes    Yes         Yes         INPUT     
cp_data_i[12][44:43]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][48:46]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][50]                    Yes    Yes         Yes         INPUT     
cp_data_i[12][54]                    Yes    Yes         Yes         INPUT     
cp_data_i[12][58:57]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][61]                    Yes    Yes         Yes         INPUT     
cp_data_i[13][17:0]                  Yes    Yes         Yes         INPUT     
cp_data_i[13][46:19]                 Yes    Yes         Yes         INPUT     
cp_data_i[13][49]                    Yes    Yes         Yes         INPUT     
cp_data_i[13][56:51]                 Yes    Yes         Yes         INPUT     
cp_data_i[13][63:58]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][14:1]                  Yes    Yes         Yes         INPUT     
cp_data_i[14][19:16]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][21]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][24:23]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][27]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][32:30]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][37:35]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][39]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][41]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][43]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][46:45]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][51:49]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][59:53]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][62:61]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][15:0]                  Yes    Yes         Yes         INPUT     
cp_data_i[15][37:17]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][40:39]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][42]                    Yes    Yes         Yes         INPUT     
cp_data_i[15][45:44]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][48:47]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][53:51]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][55]                    Yes    Yes         Yes         INPUT     
cp_data_i[15][63:57]                 Yes    Yes         Yes         INPUT     
Other bits of cp_data_i[15:0][63:0]  No     No          No          INPUT     

Signal Details
                                  Toggle Toggle 1->0 Toggle 0->1 
mshr_entry.mem_tag[3:0]           Yes    Yes         Yes         
mshr_entry.linked                 No     No          No          
mshr_entry.link_idx[3:0]          No     No          No          
mshr_entry.evict_dirty            Yes    Yes         Yes         
mshr_entry.evict_data[63:0]       Yes    Yes         Yes         
mshr_entry.evict_addr[2:0]        No     No          No          
mshr_entry.evict_addr[15:3]       Yes    Yes         Yes         
mshr_entry.evict_addr[31:16]      No     No          No          
mshr_entry.req_size[1:0]          Yes    Yes         Yes         
mshr_entry.req_data[63:0]         Yes    Yes         Yes         
mshr_entry.req_addr[15:0]         Yes    Yes         Yes         
mshr_entry.req_addr[31:16]        No     No          No          
mshr_entry.cmd[1:0]               Yes    Yes         Yes         
mshr_entry.state[2:0]             Yes    Yes         Yes         
next_mshr_entry.mem_tag[3:0]      Yes    Yes         Yes         
next_mshr_entry.linked            Yes    Yes         Yes         
next_mshr_entry.link_idx[3:0]     Yes    Yes         Yes         
next_mshr_entry.evict_dirty       Yes    Yes         Yes         
next_mshr_entry.evict_data[63:0]  Yes    Yes         Yes         
next_mshr_entry.evict_addr[2:0]   No     No          No          
next_mshr_entry.evict_addr[15:3]  Yes    Yes         Yes         
next_mshr_entry.evict_addr[31:16] No     No          No          
next_mshr_entry.req_size[1:0]     Yes    Yes         Yes         
next_mshr_entry.req_data[63:0]    Yes    Yes         Yes         
next_mshr_entry.req_addr[15:0]    Yes    Yes         Yes         
next_mshr_entry.req_addr[31:16]   No     No          No          
next_mshr_entry.cmd[1:0]          Yes    Yes         Yes         
next_mshr_entry.state[2:0]        Yes    Yes         Yes         
next_mshr_cp_flag                 Yes    Yes         Yes         
next_mshr_cp_data[63:0]           Yes    Yes         Yes         


-------------------------------------------------------------------------------
===============================================================================
Module Instance : cache_tb.dut.cache_ctrl_inst.genblk1[5].mshr_entry_ctrl_inst
===============================================================================

Instance :

SCORE  LINE   TOGGLE 
 84.03  85.71  82.35 


Instance's subtree :

SCORE  LINE   TOGGLE 
 84.03  85.71  82.35 


Module : 

SCORE  LINE   TOGGLE NAME            
 87.59  90.48  84.70 mshr_entry_ctrl 


Parent : 

SCORE  LINE   TOGGLE NAME            
 92.38 100.00  84.76 cache_ctrl_inst 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : cache_tb.dut.cache_ctrl_inst.genblk1[5].mshr_entry_ctrl_inst

             Line No.   Total   Covered  Percent
TOTAL                      210      180    85.71
ALWAYS             75       17       17   100.00
ALWAYS             97      135      113    83.70
ALWAYS            317       25       17    68.00
ALWAYS            368       22       22   100.00
ALWAYS            411       11       11   100.00

74                          always_ff @(posedge clk_i) begin
75         1/1                  if (rst_i) begin
76         1/1                      mshr_entry.state        <=  `SD ST_IDLE     ;
77         1/1                      mshr_entry.cmd          <=  `SD BUS_NONE    ;
78         1/1                      mshr_entry.req_addr     <=  `SD 'b0         ;
79         1/1                      mshr_entry.req_data     <=  `SD 'b0         ;
80         1/1                      mshr_entry.req_size     <=  `SD BYTE        ;
81         1/1                      mshr_entry.evict_addr   <=  `SD 'b0         ;
82         1/1                      mshr_entry.evict_data   <=  `SD 'b0         ;
83         1/1                      mshr_entry.evict_dirty  <=  `SD 1'b0        ;
84         1/1                      mshr_entry.link_idx     <=  `SD 'd0         ;
85         1/1                      mshr_entry.linked       <=  `SD 1'b0        ;
86         1/1                      mshr_entry.mem_tag      <=  `SD 'd0         ;
87         1/1                      mshr_cp_flag_o          <=  `SD 1'b0        ;
88         1/1                      mshr_cp_data_o          <=  `SD 'b0         ;
89                              end else begin
90         1/1                      mshr_entry              <=  `SD next_mshr_entry     ;
91         1/1                      mshr_cp_flag_o          <=  `SD next_mshr_cp_flag   ;
92         1/1                      mshr_cp_data_o          <=  `SD next_mshr_cp_data   ;
93                              end
94                          end
95                      
96                          always_comb begin
97         1/1                  next_mshr_entry.state       =   mshr_entry.state        ;
98         1/1                  next_mshr_entry.cmd         =   mshr_entry.cmd          ;
99         1/1                  next_mshr_entry.req_addr    =   mshr_entry.req_addr     ;
100        1/1                  next_mshr_entry.req_data    =   mshr_entry.req_data     ;
101        1/1                  next_mshr_entry.req_size    =   mshr_entry.req_size     ;
102        1/1                  next_mshr_entry.evict_addr  =   mshr_entry.evict_addr   ;
103        1/1                  next_mshr_entry.evict_data  =   mshr_entry.evict_data   ;
104        1/1                  next_mshr_entry.evict_dirty =   mshr_entry.evict_dirty  ;
105        1/1                  next_mshr_entry.link_idx    =   mshr_entry.link_idx     ;
106        1/1                  next_mshr_entry.linked      =   mshr_entry.linked       ;
107        1/1                  next_mshr_entry.mem_tag     =   mshr_entry.mem_tag      ;
108        1/1                  next_mshr_cp_flag           =   mshr_cp_flag_o          ;
109        1/1                  next_mshr_cp_data           =   mshr_cp_data_o          ;
110        1/1                  case (mshr_entry.state)
111                                 ST_IDLE     :   begin
112                                     // IF   there is a valid transaction on Processor Interface
113                                     // AND  the Processor Interface is granted to this entry
114                                     // AND  the cache_mem Interface is granted to this entry
115                                     // AND  it is a miss
116                                     // AND  the entry is selected to hold the new miss
117        1/1                          if ((proc2cache_i.command != BUS_NONE) && (dp_sel_i == 1'b1)
118                                     && (proc_grant_i == 1'b1)) begin
119                                         // IF   there is an older in-flight transaction to the same addreess
120                                         // ->   Wait for the completion of older miss to the same address
121        1/1                              if (mshr_hit_i && (cp_flag_i[mshr_hit_idx_i] == 1'b0)) begin
122        1/1                                  next_mshr_entry.state       =   ST_WAIT_DEPEND          ;
123        1/1                                  next_mshr_entry.link_idx    =   mshr_hit_idx_i          ;
124        1/1                                  next_mshr_entry.cmd         =   proc2cache_i.command    ;
125        1/1                                  next_mshr_entry.req_addr    =   proc2cache_i.addr       ;
126        1/1                                  next_mshr_entry.req_size    =   proc2cache_i.size       ;
127        1/1                                  if (proc2cache_i.command == BUS_STORE) begin
128        1/1                                      next_mshr_entry.req_data    =   proc2cache_i.data   ;
129                                             end
                        MISSING_ELSE
130                                         // IF   there is an older in-flight transaction that is in the middle of evicting the data block
131                                         // ->   Wait for the completion of write-back to memory
132        1/1                              end else if (evict_hit_i && (cp_flag_i[evict_hit_idx_i] == 1'b0)) begin
133        0/1     ==>                          next_mshr_entry.state       =   ST_WAIT_EVICT           ;
134        0/1     ==>                          next_mshr_entry.link_idx    =   evict_hit_idx_i         ;
135        0/1     ==>                          next_mshr_entry.cmd         =   proc2cache_i.command    ;
136        0/1     ==>                          next_mshr_entry.req_addr    =   proc2cache_i.addr       ;
137        0/1     ==>                          next_mshr_entry.req_size    =   proc2cache_i.size       ;
138        0/1     ==>                          if (proc2cache_i.command == BUS_STORE) begin
139        0/1     ==>                              next_mshr_entry.req_data    =   proc2cache_i.data   ;
140                                             end
                   ==>  MISSING_ELSE
141                                         // IF   it is a miss, and no dependency to older in-flight transactions.
142                                         // ->   Start miss handling
143        1/1                              end else if ((cache_mem_ctrl_i.req_hit == 1'b0) && (cache_mem_grant_i == 1'b1)) begin
144        1/1                                  next_mshr_entry.state       =   ST_RD_MEM               ;
145        1/1                                  next_mshr_entry.link_idx    =   'd0                     ;
146        1/1                                  next_mshr_entry.cmd         =   proc2cache_i.command    ;
147        1/1                                  next_mshr_entry.req_addr    =   proc2cache_i.addr       ;
148        1/1                                  next_mshr_entry.req_size    =   proc2cache_i.size       ;
149        1/1                                  if (proc2cache_i.command == BUS_STORE) begin
150        1/1                                      next_mshr_entry.req_data    =   proc2cache_i.data   ;
151                                             end
                        MISSING_ELSE
152                                         end
                        MISSING_ELSE
153                                     end
                        MISSING_ELSE
154        1/1                          next_mshr_cp_flag   =   1'b0    ;
155        1/1                          next_mshr_cp_data   =   'b0     ;
156                                 end
157                                 ST_WAIT_DEPEND  :   begin
158                                     // IF   the older transaction that the entry is linked to completed
159                                     // ->   Update the cache data
160        0/1     ==>                  if (cp_flag_i[mshr_entry.link_idx] == 1'b1) begin
161        0/1     ==>                      next_mshr_entry.state       =   ST_UPDATE   ;
162        0/1     ==>                      next_mshr_entry.link_idx    =   'd0         ;
163        0/1     ==>                      next_mshr_entry.req_data    =   cp_data_i[mshr_entry.link_idx];
164        0/1     ==>                      if (mshr_entry.cmd == BUS_STORE) begin
165        0/1     ==>                          case (mshr_entry.req_size)
166        0/1     ==>                              BYTE    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +:  8]    =   mshr_entry.req_data[ 7:0]   ;
167        0/1     ==>                              HALF    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +: 16]    =   mshr_entry.req_data[15:0]   ;
168        0/1     ==>                              WORD    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +: 32]    =   mshr_entry.req_data[31:0]   ;
169        0/1     ==>                              DOUBLE  :   next_mshr_entry.req_data                                    =   mshr_entry.req_data         ;
170        0/1     ==>                              default :   next_mshr_entry.req_data                                    =   mshr_entry.req_data         ;
171                                             endcase
172                                         end
                   ==>  MISSING_ELSE
173                                     end
                   ==>  MISSING_ELSE
174                                 end
175                                 ST_WAIT_EVICT   : begin
176                                     // IF   the older transaction that evicts the cache block completed
177                                     // ->   Read from Memory
178        0/1     ==>                  if (cp_flag_i[mshr_entry.link_idx] == 1'b1) begin
179        0/1     ==>                      next_mshr_entry.state       =   ST_RD_MEM   ;
180        0/1     ==>                      next_mshr_entry.link_idx    =   'd0         ;
181                                     end
                   ==>  MISSING_ELSE
182                                 end
183                                 ST_RD_MEM   :   begin
184                                     // IF   the read transaction is confirmed by Memory Interface
185                                     // ->   Wait for the data to return from Memory
186        1/1                          if ((memory_grant_i == 1'b1) && (mem2cache_i.response != 'd0)) begin
187        1/1                              next_mshr_entry.state       =   ST_WAIT_MEM             ;
188        1/1                              next_mshr_entry.mem_tag     =   mem2cache_i.response    ;
189                                     end
                        MISSING_ELSE
190                                 end
191                                 ST_WAIT_MEM :   begin
192                                     // IF   the data is returned from the Memory
193                                     // ->   Update the cache data
194        1/1                          if (mem2cache_i.tag == mshr_entry.mem_tag) begin
195        1/1                              next_mshr_entry.state       =   ST_UPDATE           ;
196        1/1                              next_mshr_entry.req_data    =   mem2cache_i.data    ;
197        1/1                              if (mshr_entry.cmd == BUS_STORE) begin
198        1/1                                  case (mshr_entry.req_size)
199        1/1                                      BYTE    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +:  8]    =   mshr_entry.req_data[ 7:0]   ;
200        1/1                                      HALF    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +: 16]    =   mshr_entry.req_data[15:0]   ;
201        1/1                                      WORD    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +: 32]    =   mshr_entry.req_data[31:0]   ;
202        1/1                                      DOUBLE  :   next_mshr_entry.req_data                                    =   mshr_entry.req_data         ;
203        0/1     ==>                              default :   next_mshr_entry.req_data                                    =   mshr_entry.req_data         ;
204                                             endcase
205                                         end
                        MISSING_ELSE
206                                     end
                        MISSING_ELSE
207                                 end
208                                 ST_UPDATE   :   begin
209                                     // IF   the req interface is granted to this entry
210        1/1                          if (cache_mem_grant_i == 1'b1) begin
211                                         // IF   it is a load miss
212                                         // ->   Output data to processor
213        1/1                              if (mshr_entry.cmd == BUS_LOAD) begin
214        1/1                                  next_mshr_entry.state       =   ST_OUTPUT;
215        1/1                                  next_mshr_entry.evict_addr  =   cache_mem_ctrl_i.evict_addr ;
216        1/1                                  next_mshr_entry.evict_data  =   cache_mem_ctrl_i.evict_data ;
217        1/1                                  next_mshr_entry.evict_dirty =   cache_mem_ctrl_i.evict_dirty;
218                                         // IF   a dirty block is evicted
219                                         // ->   Write back the evicted block
220        1/1                              end else if (cache_mem_ctrl_i.evict_dirty == 1'b1) begin
221        1/1                                  next_mshr_entry.state       =   ST_EVICT;
222        1/1                                  next_mshr_entry.evict_addr  =   cache_mem_ctrl_i.evict_addr ;
223        1/1                                  next_mshr_entry.evict_data  =   cache_mem_ctrl_i.evict_data ;
224        1/1                                  next_mshr_entry.evict_dirty =   cache_mem_ctrl_i.evict_dirty;
225                                         // ELSE
226                                         // ->   Miss Handling Completed
227                                         end else begin
228        1/1                                  next_mshr_entry.state       =   ST_IDLE             ;
229        1/1                                  next_mshr_entry.cmd         =   BUS_NONE            ;
230        1/1                                  next_mshr_entry.req_addr    =   'b0                 ;
231        1/1                                  next_mshr_entry.req_data    =   'b0                 ;
232        1/1                                  next_mshr_entry.req_size    =   BYTE                ;
233        1/1                                  next_mshr_entry.evict_addr  =   'b0                 ;
234        1/1                                  next_mshr_entry.evict_data  =   'b0                 ;
235        1/1                                  next_mshr_entry.evict_dirty =   1'b0                ;
236        1/1                                  next_mshr_entry.link_idx    =   'd0                 ;
237        1/1                                  next_mshr_entry.mem_tag     =   'd0                 ;
238        1/1                                  next_mshr_cp_flag           =   1'b1                ;
239        1/1                                  next_mshr_cp_data           =   mshr_entry.req_data ;
240                                         end
241                                     end
                        MISSING_ELSE
242                                 end
243                                 ST_OUTPUT   :   begin
244                                     // IF   the Processor Interface is granted to this entry
245        1/1                          if (proc_grant_i == 1'b1) begin
246                                         // IF   the evicted block is dirty
247                                         // ->   Write back the evicted block
248        1/1                              if (mshr_entry.evict_dirty == 1'b1) begin
249        1/1                                  next_mshr_entry.state       =   ST_EVICT;
250                                         // ELSE
251                                         // ->   Miss Handling Completed
252                                         end else begin
253        1/1                                  next_mshr_entry.state       =   ST_IDLE             ;
254        1/1                                  next_mshr_entry.cmd         =   BUS_NONE            ;
255        1/1                                  next_mshr_entry.req_addr    =   'b0                 ;
256        1/1                                  next_mshr_entry.req_data    =   'b0                 ;
257        1/1                                  next_mshr_entry.req_size    =   BYTE                ;
258        1/1                                  next_mshr_entry.evict_addr  =   'b0                 ;
259        1/1                                  next_mshr_entry.evict_data  =   'b0                 ;
260        1/1                                  next_mshr_entry.evict_dirty =   1'b0                ;
261        1/1                                  next_mshr_entry.link_idx    =   'd0                 ;
262        1/1                                  next_mshr_entry.mem_tag     =   'd0                 ;
263        1/1                                  next_mshr_cp_flag           =   1'b1                ;
264        1/1                                  next_mshr_cp_data           =   mshr_entry.req_data ;
265                                         end
266                                     end
                        MISSING_ELSE
267                                 end
268                                 ST_EVICT    :   begin
269                                     // IF   the write back transaction to Memory is confirmed
270                                     // ->   Miss Handling Completed
271        1/1                          if ((memory_grant_i == 1'b1) && (mem2cache_i.response != 'd0)) begin
272        1/1                              next_mshr_entry.state       =   ST_IDLE             ;
273        1/1                              next_mshr_entry.cmd         =   BUS_NONE            ;
274        1/1                              next_mshr_entry.req_addr    =   'b0                 ;
275        1/1                              next_mshr_entry.req_data    =   'b0                 ;
276        1/1                              next_mshr_entry.req_size    =   BYTE                ;
277        1/1                              next_mshr_entry.evict_addr  =   'b0                 ;
278        1/1                              next_mshr_entry.evict_data  =   'b0                 ;
279        1/1                              next_mshr_entry.evict_dirty =   1'b0                ;
280        1/1                              next_mshr_entry.link_idx    =   'd0                 ;
281        1/1                              next_mshr_entry.mem_tag     =   'd0                 ;
282        1/1                              next_mshr_cp_flag           =   1'b1                ;
283        1/1                              next_mshr_cp_data           =   mshr_entry.req_data ;
284                                     end
                        MISSING_ELSE
285                                 end
286                                 default     :   begin
287        1/1                          next_mshr_entry.state       =   ST_IDLE     ;
288        1/1                          next_mshr_entry.cmd         =   BUS_NONE    ;
289        1/1                          next_mshr_entry.req_addr    =   'b0         ;
290        1/1                          next_mshr_entry.req_data    =   'b0         ;
291        1/1                          next_mshr_entry.req_size    =   BYTE        ;
292        1/1                          next_mshr_entry.evict_addr  =   'b0         ;
293        1/1                          next_mshr_entry.evict_data  =   'b0         ;
294        1/1                          next_mshr_entry.evict_dirty =   1'b0        ;
295        1/1                          next_mshr_entry.link_idx    =   'd0         ;
296        1/1                          next_mshr_entry.mem_tag     =   'd0         ;
297        1/1                          next_mshr_cp_flag           =   1'b0        ;
298        1/1                          next_mshr_cp_data           =   'd0         ;
299                                 end
300                             endcase
301                     
302        1/1                  if (next_mshr_entry.state == ST_IDLE) begin
303        1/1                      next_mshr_entry.linked  =   1'b0;
304        1/1                  end else if ((mshr_hit_i == 1'b1) && (mshr_hit_idx_i == mshr_entry_idx_i)) begin
305        1/1                      next_mshr_entry.linked  =   1'b1;
306                             end
                        MISSING_ELSE
307                         end
308                     
309                     // --------------------------------------------------------------------
310                     // MSHR entry output
311                     // --------------------------------------------------------------------
312                         assign  mshr_entry_o    =   mshr_entry  ;
313                     // --------------------------------------------------------------------
314                     // Processor Interface
315                     // --------------------------------------------------------------------
316                         always_comb begin
317        1/1                  mshr_proc_o.response    =   'd0 ;
318        1/1                  mshr_proc_o.data        =   'b0 ;
319        1/1                  mshr_proc_o.tag         =   'd0 ;
320        1/1                  case (mshr_entry.state)
321                                 ST_IDLE     :   begin
322                                     // IF   the processor request is allocated to this entry
323        1/1                          if ((proc2cache_i.command != BUS_NONE) && (dp_sel_i == 1'b1)) begin
324                                         // IF   The Processor Interface is granted to this entry
325                                         // AND  there is a dependency to older in-flight transaction
326                                         // ->   Confirm the request
327        1/1                              if (((mshr_hit_i && (cp_flag_i[mshr_hit_idx_i] == 1'b0))
328                                         || (evict_hit_i && (cp_flag_i[evict_hit_idx_i] == 1'b0)))) begin
329        1/1                                  mshr_proc_o.response    =   mshr_entry_idx_i;
330                                         // IF   The Processor Interface is granted to this entry
331                                         // AND  The cache_mem Interface is granted to this entry
332                                         // ->   Confirm the request 
333        1/1                              end else if (cache_mem_grant_i == 1'b1) begin
334        1/1                                  mshr_proc_o.response    =   mshr_entry_idx_i;
335                                             // IF   it is a load hit
336                                             // ->   Output data and tag
337        1/1                                  if (cache_mem_ctrl_i.req_hit == 1'b1 && proc2cache_i.command == BUS_LOAD) begin
338        0/1     ==>                              mshr_proc_o.tag     =   mshr_entry_idx_i;
339        0/1     ==>                              case (proc2cache_i.size)
340        0/1     ==>                                  BYTE    :   mshr_proc_o.data    =   {56'b0,cache_mem_ctrl_i.req_data_out[proc2cache_i.addr[2:0]+: 8]};
341        0/1     ==>                                  HALF    :   mshr_proc_o.data    =   {48'b0,cache_mem_ctrl_i.req_data_out[proc2cache_i.addr[2:0]+:16]};
342        0/1     ==>                                  WORD    :   mshr_proc_o.data    =   {32'b0,cache_mem_ctrl_i.req_data_out[proc2cache_i.addr[2:0]+:32]};
343        0/1     ==>                                  DOUBLE  :   mshr_proc_o.data    =   cache_mem_ctrl_i.req_data_out;
344        0/1     ==>                                  default :   mshr_proc_o.data    =   cache_mem_ctrl_i.req_data_out;
345                                                 endcase
346                                             end
                        MISSING_ELSE
347                                         end
                        MISSING_ELSE
348                                     end
                        MISSING_ELSE
349                                 end
350                                 ST_OUTPUT   :   begin
351        1/1                          mshr_proc_o.response    =   'd0                 ;
352        1/1                          mshr_proc_o.tag         =   mshr_entry_idx_i    ;
353        1/1                          case (mshr_entry.req_size)
354        1/1                              BYTE    :   mshr_proc_o.data    =   {56'b0,mshr_entry.req_data[mshr_entry.req_addr[2:0]+: 8]};
355        1/1                              HALF    :   mshr_proc_o.data    =   {48'b0,mshr_entry.req_data[mshr_entry.req_addr[2:0]+:16]};
356        1/1                              WORD    :   mshr_proc_o.data    =   {32'b0,mshr_entry.req_data[mshr_entry.req_addr[2:0]+:32]};
357        1/1                              DOUBLE  :   mshr_proc_o.data    =   mshr_entry.req_data;
358        0/1     ==>                      default :   mshr_proc_o.data    =   mshr_entry.req_data;
359                                     endcase
360                                 end
                        MISSING_DEFAULT
361                             endcase
362                         end
363                     
364                     // --------------------------------------------------------------------
365                     // cache_mem Interface
366                     // --------------------------------------------------------------------
367                         always_comb begin
368        1/1                  mshr_cache_mem_o.req_cmd        =   REQ_NONE;
369        1/1                  mshr_cache_mem_o.req_addr       =   'b0     ;
370        1/1                  mshr_cache_mem_o.req_data_in    =   'b0     ;
371        1/1                  case (mshr_entry.state)
372                                 ST_IDLE:    begin
373                                     // IF   the processor request is allocated to this entry
374        1/1                          if (dp_sel_i == 1'b1) begin
375        1/1                              case (proc2cache_i.command)
376                                             BUS_LOAD    :   begin
377        1/1                                      mshr_cache_mem_o.req_cmd        =   REQ_LOAD                        ;
378        1/1                                      mshr_cache_mem_o.req_addr       =   proc2cache_i.addr               ;
379        1/1                                      mshr_cache_mem_o.req_data_in    =   cache_mem_ctrl_i.req_data_out   ;
380                                             end
381                                             BUS_STORE   :   begin
382        1/1                                      mshr_cache_mem_o.req_cmd        =   REQ_STORE                       ;
383        1/1                                      mshr_cache_mem_o.req_addr       =   proc2cache_i.addr               ;
384        1/1                                      mshr_cache_mem_o.req_data_in    =   cache_mem_ctrl_i.req_data_out   ;
385        1/1                                      case (proc2cache_i.size)
386        1/1                                          BYTE    :   mshr_cache_mem_o.req_data_in[proc2cache_i.addr[2:0] +:  8]  =   proc2cache_i.data[ 7:0] ;
387        1/1                                          HALF    :   mshr_cache_mem_o.req_data_in[proc2cache_i.addr[2:0] +: 16]  =   proc2cache_i.data[15:0] ;
388        1/1                                          WORD    :   mshr_cache_mem_o.req_data_in[proc2cache_i.addr[2:0] +: 32]  =   proc2cache_i.data[31:0] ;
389        1/1                                          DOUBLE  :   mshr_cache_mem_o.req_data_in                                =   proc2cache_i.data       ;
                   ==>  MISSING_DEFAULT
390                                                 endcase
391                                             end    
                        MISSING_DEFAULT
392                                         endcase
393                                     end
                        MISSING_ELSE
394                                 end
395                                 ST_UPDATE:  begin
396        1/1                          if (mshr_entry.cmd == BUS_LOAD) begin
397        1/1                              mshr_cache_mem_o.req_cmd    =   REQ_LOAD_MISS       ;
398                                     end else begin
399        1/1                              mshr_cache_mem_o.req_cmd    =   REQ_STORE_MISS      ;
400                                     end
401        1/1                          mshr_cache_mem_o.req_addr       =   mshr_entry.req_addr ;
402        1/1                          mshr_cache_mem_o.req_data_in    =   mshr_entry.req_data ;
403                                 end
                        MISSING_DEFAULT
404                             endcase
405                         end
406                     
407                     // --------------------------------------------------------------------
408                     // Memory Interface
409                     // --------------------------------------------------------------------
410                         always_comb begin
411        1/1                  mshr_memory_o.addr      =   {mshr_entry.req_addr[C_XLEN-1:C_CACHE_OFFSET_WIDTH], {C_CACHE_OFFSET_WIDTH{1'b0}}};
412        1/1                  mshr_memory_o.size      =   DOUBLE              ;
413        1/1                  mshr_memory_o.command   =   BUS_NONE            ;
414        1/1                  mshr_memory_o.data      =   'd0 ;
415        1/1                  case (mshr_entry.state)
416                                 ST_RD_MEM   :   begin
417        1/1                          mshr_memory_o.data      =   'd0 ;
418        1/1                          mshr_memory_o.addr      =   {mshr_entry.req_addr[C_XLEN-1:C_CACHE_OFFSET_WIDTH], {C_CACHE_OFFSET_WIDTH{1'b0}}};
419        1/1                          mshr_memory_o.command   =   BUS_LOAD;
420                                 end
421                                 ST_EVICT    :   begin
422        1/1                          mshr_memory_o.data      =   mshr_entry.evict_data;
423        1/1                          mshr_memory_o.addr      =   {mshr_entry.evict_addr[C_XLEN-1:C_CACHE_OFFSET_WIDTH], {C_CACHE_OFFSET_WIDTH{1'b0}}};
424        1/1                          mshr_memory_o.command   =   BUS_STORE;
425                                 end
                        MISSING_DEFAULT

-------------------------------------------------------------------------------
Toggle Coverage for Instance : cache_tb.dut.cache_ctrl_inst.genblk1[5].mshr_entry_ctrl_inst
                Total Covered Percent 
Totals          72    47      65.28   
Total Bits      4844  3989    82.35   
Total Bits 0->1 2422  1994    82.33   
Total Bits 1->0 2422  1995    82.37   

                                
Ports          48   29   60.42  
Port Bits      3878 3173 81.82  
Port Bits 0->1 1939 1586 81.79  
Port Bits 1->0 1939 1587 81.85  

                                
Signals          24  18  75.00  
Signal Bits      966 816 84.47  
Signal Bits 0->1 483 408 84.47  
Signal Bits 1->0 483 408 84.47  

Port Details
                                     Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i                                Yes    Yes         Yes         INPUT     
rst_i                                No     Yes         No          INPUT     
mshr_entry_idx_i[3:0]                No     No          No          INPUT     
mshr_entry_o.mem_tag[3:0]            Yes    Yes         Yes         OUTPUT    
mshr_entry_o.linked                  No     No          No          OUTPUT    
mshr_entry_o.link_idx[3:0]           No     No          No          OUTPUT    
mshr_entry_o.evict_dirty             Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_data[63:0]        Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_addr[2:0]         No     No          No          OUTPUT    
mshr_entry_o.evict_addr[15:3]        Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_addr[31:16]       No     No          No          OUTPUT    
mshr_entry_o.req_size[1:0]           Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_data[63:0]          Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_addr[15:0]          Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_addr[31:16]         No     No          No          OUTPUT    
mshr_entry_o.cmd[1:0]                Yes    Yes         Yes         OUTPUT    
mshr_entry_o.state[2:0]              Yes    Yes         Yes         OUTPUT    
proc_grant_i                         Yes    Yes         Yes         INPUT     
proc2cache_i.command[1:0]            Yes    Yes         Yes         INPUT     
proc2cache_i.size[1:0]               Yes    Yes         Yes         INPUT     
proc2cache_i.data[63:0]              Yes    Yes         Yes         INPUT     
proc2cache_i.addr[15:0]              Yes    Yes         Yes         INPUT     
proc2cache_i.addr[31:16]             No     No          No          INPUT     
mshr_proc_o.tag[0]                   Yes    Yes         Yes         OUTPUT    
mshr_proc_o.tag[1]                   No     No          No          OUTPUT    
mshr_proc_o.tag[2]                   Yes    Yes         Yes         OUTPUT    
mshr_proc_o.tag[3]                   No     No          No          OUTPUT    
mshr_proc_o.data[1:0]                No     No          No          OUTPUT    
mshr_proc_o.data[3:2]                Yes    Yes         Yes         OUTPUT    
mshr_proc_o.data[4]                  No     No          No          OUTPUT    
mshr_proc_o.data[5]                  Yes    Yes         Yes         OUTPUT    
mshr_proc_o.data[6]                  No     No          No          OUTPUT    
mshr_proc_o.data[7]                  Yes    Yes         Yes         OUTPUT    
mshr_proc_o.data[8]                  No     No          No          OUTPUT    
mshr_proc_o.data[9]                  Yes    Yes         Yes         OUTPUT    
mshr_proc_o.data[11:10]              No     No          No          OUTPUT    
mshr_proc_o.data[12]                 Yes    Yes         Yes         OUTPUT    
mshr_proc_o.data[13]                 No     No          No          OUTPUT    
mshr_proc_o.data[14]                 Yes    Yes         Yes         OUTPUT    
mshr_proc_o.data[63:15]              No     No          No          OUTPUT    
mshr_proc_o.response[0]              Yes    Yes         Yes         OUTPUT    
mshr_proc_o.response[1]              No     No          No          OUTPUT    
mshr_proc_o.response[2]              Yes    Yes         Yes         OUTPUT    
mshr_proc_o.response[3]              No     No          No          OUTPUT    
cache_mem_grant_i                    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.evict_data[63:0]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.evict_addr[2:0]     No     No          No          INPUT     
cache_mem_ctrl_i.evict_addr[15:3]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.evict_addr[31:16]   No     No          No          INPUT     
cache_mem_ctrl_i.evict_dirty         Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[4:0]   Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[6:5]   No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[8:7]   Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[11:9]  No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[13:12] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[15:14] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[25:16] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[26]    No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[31:27] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[33:32] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[34]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[37:35] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[38]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[41:39] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[42]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[45:43] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[47:46] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[50:48] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[52:51] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[54:53] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[58:55] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[60:59] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[63:61] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_hit             Yes    Yes         Yes         INPUT     
mshr_cache_mem_o.req_data_in[63:0]   Yes    Yes         Yes         OUTPUT    
mshr_cache_mem_o.req_addr[15:0]      Yes    Yes         Yes         OUTPUT    
mshr_cache_mem_o.req_addr[31:16]     No     No          No          OUTPUT    
mshr_cache_mem_o.req_cmd[2:0]        Yes    Yes         Yes         OUTPUT    
memory_grant_i                       Yes    Yes         Yes         INPUT     
mem2cache_i.tag[3:0]                 Yes    Yes         Yes         INPUT     
mem2cache_i.data[63:0]               Yes    Yes         Yes         INPUT     
mem2cache_i.response[3:0]            Yes    Yes         Yes         INPUT     
mshr_memory_o.command[1:0]           Yes    Yes         Yes         OUTPUT    
mshr_memory_o.size[1:0]              No     No          No          OUTPUT    
mshr_memory_o.data[63:0]             Yes    Yes         Yes         OUTPUT    
mshr_memory_o.addr[2:0]              No     No          No          OUTPUT    
mshr_memory_o.addr[15:3]             Yes    Yes         Yes         OUTPUT    
mshr_memory_o.addr[31:16]            No     No          No          OUTPUT    
mshr_hit_i                           Yes    Yes         Yes         INPUT     
mshr_hit_idx_i[3:0]                  Yes    Yes         Yes         INPUT     
evict_hit_i                          No     No          No          INPUT     
evict_hit_idx_i[3:0]                 No     No          No          INPUT     
dp_sel_i                             Yes    Yes         Yes         INPUT     
mshr_cp_flag_o                       Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[63:0]                 Yes    Yes         Yes         OUTPUT    
cp_flag_i[0]                         No     No          No          INPUT     
cp_flag_i[15:1]                      Yes    Yes         Yes         INPUT     
cp_data_i[8:1][63:0]                 Yes    Yes         Yes         INPUT     
cp_data_i[9][44:0]                   Yes    Yes         Yes         INPUT     
cp_data_i[9][63:46]                  Yes    Yes         Yes         INPUT     
cp_data_i[10][30:1]                  Yes    Yes         Yes         INPUT     
cp_data_i[10][36:32]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][41:40]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][45]                    Yes    Yes         Yes         INPUT     
cp_data_i[10][49:47]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][52:51]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][56:55]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][60]                    Yes    Yes         Yes         INPUT     
cp_data_i[10][62]                    Yes    Yes         Yes         INPUT     
cp_data_i[11][27:0]                  Yes    Yes         Yes         INPUT     
cp_data_i[11][36:29]                 Yes    Yes         Yes         INPUT     
cp_data_i[11][49:39]                 Yes    Yes         Yes         INPUT     
cp_data_i[11][51]                    Yes    Yes         Yes         INPUT     
cp_data_i[11][59:54]                 Yes    Yes         Yes         INPUT     
cp_data_i[11][63:62]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][4:0]                   Yes    Yes         Yes         INPUT     
cp_data_i[12][27:6]                  Yes    Yes         Yes         INPUT     
cp_data_i[12][31:29]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][35:33]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][39]                    Yes    Yes         Yes         INPUT     
cp_data_i[12][44:43]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][48:46]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][50]                    Yes    Yes         Yes         INPUT     
cp_data_i[12][54]                    Yes    Yes         Yes         INPUT     
cp_data_i[12][58:57]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][61]                    Yes    Yes         Yes         INPUT     
cp_data_i[13][17:0]                  Yes    Yes         Yes         INPUT     
cp_data_i[13][46:19]                 Yes    Yes         Yes         INPUT     
cp_data_i[13][49]                    Yes    Yes         Yes         INPUT     
cp_data_i[13][56:51]                 Yes    Yes         Yes         INPUT     
cp_data_i[13][63:58]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][14:1]                  Yes    Yes         Yes         INPUT     
cp_data_i[14][19:16]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][21]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][24:23]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][27]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][32:30]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][37:35]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][39]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][41]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][43]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][46:45]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][51:49]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][59:53]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][62:61]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][15:0]                  Yes    Yes         Yes         INPUT     
cp_data_i[15][37:17]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][40:39]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][42]                    Yes    Yes         Yes         INPUT     
cp_data_i[15][45:44]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][48:47]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][53:51]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][55]                    Yes    Yes         Yes         INPUT     
cp_data_i[15][63:57]                 Yes    Yes         Yes         INPUT     
Other bits of cp_data_i[15:0][63:0]  No     No          No          INPUT     

Signal Details
                                  Toggle Toggle 1->0 Toggle 0->1 
mshr_entry.mem_tag[3:0]           Yes    Yes         Yes         
mshr_entry.linked                 No     No          No          
mshr_entry.link_idx[3:0]          No     No          No          
mshr_entry.evict_dirty            Yes    Yes         Yes         
mshr_entry.evict_data[63:0]       Yes    Yes         Yes         
mshr_entry.evict_addr[2:0]        No     No          No          
mshr_entry.evict_addr[15:3]       Yes    Yes         Yes         
mshr_entry.evict_addr[31:16]      No     No          No          
mshr_entry.req_size[1:0]          Yes    Yes         Yes         
mshr_entry.req_data[63:0]         Yes    Yes         Yes         
mshr_entry.req_addr[15:0]         Yes    Yes         Yes         
mshr_entry.req_addr[31:16]        No     No          No          
mshr_entry.cmd[1:0]               Yes    Yes         Yes         
mshr_entry.state[2:0]             Yes    Yes         Yes         
next_mshr_entry.mem_tag[3:0]      Yes    Yes         Yes         
next_mshr_entry.linked            Yes    Yes         Yes         
next_mshr_entry.link_idx[3:0]     Yes    Yes         Yes         
next_mshr_entry.evict_dirty       Yes    Yes         Yes         
next_mshr_entry.evict_data[63:0]  Yes    Yes         Yes         
next_mshr_entry.evict_addr[2:0]   No     No          No          
next_mshr_entry.evict_addr[15:3]  Yes    Yes         Yes         
next_mshr_entry.evict_addr[31:16] No     No          No          
next_mshr_entry.req_size[1:0]     Yes    Yes         Yes         
next_mshr_entry.req_data[63:0]    Yes    Yes         Yes         
next_mshr_entry.req_addr[15:0]    Yes    Yes         Yes         
next_mshr_entry.req_addr[31:16]   No     No          No          
next_mshr_entry.cmd[1:0]          Yes    Yes         Yes         
next_mshr_entry.state[2:0]        Yes    Yes         Yes         
next_mshr_cp_flag                 Yes    Yes         Yes         
next_mshr_cp_data[63:0]           Yes    Yes         Yes         


-------------------------------------------------------------------------------
===============================================================================
Module Instance : cache_tb.dut.cache_ctrl_inst.genblk1[4].mshr_entry_ctrl_inst
===============================================================================

Instance :

SCORE  LINE   TOGGLE 
 84.11  85.71  82.51 


Instance's subtree :

SCORE  LINE   TOGGLE 
 84.11  85.71  82.51 


Module : 

SCORE  LINE   TOGGLE NAME            
 87.59  90.48  84.70 mshr_entry_ctrl 


Parent : 

SCORE  LINE   TOGGLE NAME            
 92.38 100.00  84.76 cache_ctrl_inst 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : cache_tb.dut.cache_ctrl_inst.genblk1[4].mshr_entry_ctrl_inst

             Line No.   Total   Covered  Percent
TOTAL                      210      180    85.71
ALWAYS             75       17       17   100.00
ALWAYS             97      135      113    83.70
ALWAYS            317       25       17    68.00
ALWAYS            368       22       22   100.00
ALWAYS            411       11       11   100.00

74                          always_ff @(posedge clk_i) begin
75         1/1                  if (rst_i) begin
76         1/1                      mshr_entry.state        <=  `SD ST_IDLE     ;
77         1/1                      mshr_entry.cmd          <=  `SD BUS_NONE    ;
78         1/1                      mshr_entry.req_addr     <=  `SD 'b0         ;
79         1/1                      mshr_entry.req_data     <=  `SD 'b0         ;
80         1/1                      mshr_entry.req_size     <=  `SD BYTE        ;
81         1/1                      mshr_entry.evict_addr   <=  `SD 'b0         ;
82         1/1                      mshr_entry.evict_data   <=  `SD 'b0         ;
83         1/1                      mshr_entry.evict_dirty  <=  `SD 1'b0        ;
84         1/1                      mshr_entry.link_idx     <=  `SD 'd0         ;
85         1/1                      mshr_entry.linked       <=  `SD 1'b0        ;
86         1/1                      mshr_entry.mem_tag      <=  `SD 'd0         ;
87         1/1                      mshr_cp_flag_o          <=  `SD 1'b0        ;
88         1/1                      mshr_cp_data_o          <=  `SD 'b0         ;
89                              end else begin
90         1/1                      mshr_entry              <=  `SD next_mshr_entry     ;
91         1/1                      mshr_cp_flag_o          <=  `SD next_mshr_cp_flag   ;
92         1/1                      mshr_cp_data_o          <=  `SD next_mshr_cp_data   ;
93                              end
94                          end
95                      
96                          always_comb begin
97         1/1                  next_mshr_entry.state       =   mshr_entry.state        ;
98         1/1                  next_mshr_entry.cmd         =   mshr_entry.cmd          ;
99         1/1                  next_mshr_entry.req_addr    =   mshr_entry.req_addr     ;
100        1/1                  next_mshr_entry.req_data    =   mshr_entry.req_data     ;
101        1/1                  next_mshr_entry.req_size    =   mshr_entry.req_size     ;
102        1/1                  next_mshr_entry.evict_addr  =   mshr_entry.evict_addr   ;
103        1/1                  next_mshr_entry.evict_data  =   mshr_entry.evict_data   ;
104        1/1                  next_mshr_entry.evict_dirty =   mshr_entry.evict_dirty  ;
105        1/1                  next_mshr_entry.link_idx    =   mshr_entry.link_idx     ;
106        1/1                  next_mshr_entry.linked      =   mshr_entry.linked       ;
107        1/1                  next_mshr_entry.mem_tag     =   mshr_entry.mem_tag      ;
108        1/1                  next_mshr_cp_flag           =   mshr_cp_flag_o          ;
109        1/1                  next_mshr_cp_data           =   mshr_cp_data_o          ;
110        1/1                  case (mshr_entry.state)
111                                 ST_IDLE     :   begin
112                                     // IF   there is a valid transaction on Processor Interface
113                                     // AND  the Processor Interface is granted to this entry
114                                     // AND  the cache_mem Interface is granted to this entry
115                                     // AND  it is a miss
116                                     // AND  the entry is selected to hold the new miss
117        1/1                          if ((proc2cache_i.command != BUS_NONE) && (dp_sel_i == 1'b1)
118                                     && (proc_grant_i == 1'b1)) begin
119                                         // IF   there is an older in-flight transaction to the same addreess
120                                         // ->   Wait for the completion of older miss to the same address
121        1/1                              if (mshr_hit_i && (cp_flag_i[mshr_hit_idx_i] == 1'b0)) begin
122        1/1                                  next_mshr_entry.state       =   ST_WAIT_DEPEND          ;
123        1/1                                  next_mshr_entry.link_idx    =   mshr_hit_idx_i          ;
124        1/1                                  next_mshr_entry.cmd         =   proc2cache_i.command    ;
125        1/1                                  next_mshr_entry.req_addr    =   proc2cache_i.addr       ;
126        1/1                                  next_mshr_entry.req_size    =   proc2cache_i.size       ;
127        1/1                                  if (proc2cache_i.command == BUS_STORE) begin
128        1/1                                      next_mshr_entry.req_data    =   proc2cache_i.data   ;
129                                             end
                        MISSING_ELSE
130                                         // IF   there is an older in-flight transaction that is in the middle of evicting the data block
131                                         // ->   Wait for the completion of write-back to memory
132        1/1                              end else if (evict_hit_i && (cp_flag_i[evict_hit_idx_i] == 1'b0)) begin
133        0/1     ==>                          next_mshr_entry.state       =   ST_WAIT_EVICT           ;
134        0/1     ==>                          next_mshr_entry.link_idx    =   evict_hit_idx_i         ;
135        0/1     ==>                          next_mshr_entry.cmd         =   proc2cache_i.command    ;
136        0/1     ==>                          next_mshr_entry.req_addr    =   proc2cache_i.addr       ;
137        0/1     ==>                          next_mshr_entry.req_size    =   proc2cache_i.size       ;
138        0/1     ==>                          if (proc2cache_i.command == BUS_STORE) begin
139        0/1     ==>                              next_mshr_entry.req_data    =   proc2cache_i.data   ;
140                                             end
                   ==>  MISSING_ELSE
141                                         // IF   it is a miss, and no dependency to older in-flight transactions.
142                                         // ->   Start miss handling
143        1/1                              end else if ((cache_mem_ctrl_i.req_hit == 1'b0) && (cache_mem_grant_i == 1'b1)) begin
144        1/1                                  next_mshr_entry.state       =   ST_RD_MEM               ;
145        1/1                                  next_mshr_entry.link_idx    =   'd0                     ;
146        1/1                                  next_mshr_entry.cmd         =   proc2cache_i.command    ;
147        1/1                                  next_mshr_entry.req_addr    =   proc2cache_i.addr       ;
148        1/1                                  next_mshr_entry.req_size    =   proc2cache_i.size       ;
149        1/1                                  if (proc2cache_i.command == BUS_STORE) begin
150        1/1                                      next_mshr_entry.req_data    =   proc2cache_i.data   ;
151                                             end
                        MISSING_ELSE
152                                         end
                        MISSING_ELSE
153                                     end
                        MISSING_ELSE
154        1/1                          next_mshr_cp_flag   =   1'b0    ;
155        1/1                          next_mshr_cp_data   =   'b0     ;
156                                 end
157                                 ST_WAIT_DEPEND  :   begin
158                                     // IF   the older transaction that the entry is linked to completed
159                                     // ->   Update the cache data
160        0/1     ==>                  if (cp_flag_i[mshr_entry.link_idx] == 1'b1) begin
161        0/1     ==>                      next_mshr_entry.state       =   ST_UPDATE   ;
162        0/1     ==>                      next_mshr_entry.link_idx    =   'd0         ;
163        0/1     ==>                      next_mshr_entry.req_data    =   cp_data_i[mshr_entry.link_idx];
164        0/1     ==>                      if (mshr_entry.cmd == BUS_STORE) begin
165        0/1     ==>                          case (mshr_entry.req_size)
166        0/1     ==>                              BYTE    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +:  8]    =   mshr_entry.req_data[ 7:0]   ;
167        0/1     ==>                              HALF    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +: 16]    =   mshr_entry.req_data[15:0]   ;
168        0/1     ==>                              WORD    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +: 32]    =   mshr_entry.req_data[31:0]   ;
169        0/1     ==>                              DOUBLE  :   next_mshr_entry.req_data                                    =   mshr_entry.req_data         ;
170        0/1     ==>                              default :   next_mshr_entry.req_data                                    =   mshr_entry.req_data         ;
171                                             endcase
172                                         end
                   ==>  MISSING_ELSE
173                                     end
                   ==>  MISSING_ELSE
174                                 end
175                                 ST_WAIT_EVICT   : begin
176                                     // IF   the older transaction that evicts the cache block completed
177                                     // ->   Read from Memory
178        0/1     ==>                  if (cp_flag_i[mshr_entry.link_idx] == 1'b1) begin
179        0/1     ==>                      next_mshr_entry.state       =   ST_RD_MEM   ;
180        0/1     ==>                      next_mshr_entry.link_idx    =   'd0         ;
181                                     end
                   ==>  MISSING_ELSE
182                                 end
183                                 ST_RD_MEM   :   begin
184                                     // IF   the read transaction is confirmed by Memory Interface
185                                     // ->   Wait for the data to return from Memory
186        1/1                          if ((memory_grant_i == 1'b1) && (mem2cache_i.response != 'd0)) begin
187        1/1                              next_mshr_entry.state       =   ST_WAIT_MEM             ;
188        1/1                              next_mshr_entry.mem_tag     =   mem2cache_i.response    ;
189                                     end
                        MISSING_ELSE
190                                 end
191                                 ST_WAIT_MEM :   begin
192                                     // IF   the data is returned from the Memory
193                                     // ->   Update the cache data
194        1/1                          if (mem2cache_i.tag == mshr_entry.mem_tag) begin
195        1/1                              next_mshr_entry.state       =   ST_UPDATE           ;
196        1/1                              next_mshr_entry.req_data    =   mem2cache_i.data    ;
197        1/1                              if (mshr_entry.cmd == BUS_STORE) begin
198        1/1                                  case (mshr_entry.req_size)
199        1/1                                      BYTE    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +:  8]    =   mshr_entry.req_data[ 7:0]   ;
200        1/1                                      HALF    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +: 16]    =   mshr_entry.req_data[15:0]   ;
201        1/1                                      WORD    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +: 32]    =   mshr_entry.req_data[31:0]   ;
202        1/1                                      DOUBLE  :   next_mshr_entry.req_data                                    =   mshr_entry.req_data         ;
203        0/1     ==>                              default :   next_mshr_entry.req_data                                    =   mshr_entry.req_data         ;
204                                             endcase
205                                         end
                        MISSING_ELSE
206                                     end
                        MISSING_ELSE
207                                 end
208                                 ST_UPDATE   :   begin
209                                     // IF   the req interface is granted to this entry
210        1/1                          if (cache_mem_grant_i == 1'b1) begin
211                                         // IF   it is a load miss
212                                         // ->   Output data to processor
213        1/1                              if (mshr_entry.cmd == BUS_LOAD) begin
214        1/1                                  next_mshr_entry.state       =   ST_OUTPUT;
215        1/1                                  next_mshr_entry.evict_addr  =   cache_mem_ctrl_i.evict_addr ;
216        1/1                                  next_mshr_entry.evict_data  =   cache_mem_ctrl_i.evict_data ;
217        1/1                                  next_mshr_entry.evict_dirty =   cache_mem_ctrl_i.evict_dirty;
218                                         // IF   a dirty block is evicted
219                                         // ->   Write back the evicted block
220        1/1                              end else if (cache_mem_ctrl_i.evict_dirty == 1'b1) begin
221        1/1                                  next_mshr_entry.state       =   ST_EVICT;
222        1/1                                  next_mshr_entry.evict_addr  =   cache_mem_ctrl_i.evict_addr ;
223        1/1                                  next_mshr_entry.evict_data  =   cache_mem_ctrl_i.evict_data ;
224        1/1                                  next_mshr_entry.evict_dirty =   cache_mem_ctrl_i.evict_dirty;
225                                         // ELSE
226                                         // ->   Miss Handling Completed
227                                         end else begin
228        1/1                                  next_mshr_entry.state       =   ST_IDLE             ;
229        1/1                                  next_mshr_entry.cmd         =   BUS_NONE            ;
230        1/1                                  next_mshr_entry.req_addr    =   'b0                 ;
231        1/1                                  next_mshr_entry.req_data    =   'b0                 ;
232        1/1                                  next_mshr_entry.req_size    =   BYTE                ;
233        1/1                                  next_mshr_entry.evict_addr  =   'b0                 ;
234        1/1                                  next_mshr_entry.evict_data  =   'b0                 ;
235        1/1                                  next_mshr_entry.evict_dirty =   1'b0                ;
236        1/1                                  next_mshr_entry.link_idx    =   'd0                 ;
237        1/1                                  next_mshr_entry.mem_tag     =   'd0                 ;
238        1/1                                  next_mshr_cp_flag           =   1'b1                ;
239        1/1                                  next_mshr_cp_data           =   mshr_entry.req_data ;
240                                         end
241                                     end
                        MISSING_ELSE
242                                 end
243                                 ST_OUTPUT   :   begin
244                                     // IF   the Processor Interface is granted to this entry
245        1/1                          if (proc_grant_i == 1'b1) begin
246                                         // IF   the evicted block is dirty
247                                         // ->   Write back the evicted block
248        1/1                              if (mshr_entry.evict_dirty == 1'b1) begin
249        1/1                                  next_mshr_entry.state       =   ST_EVICT;
250                                         // ELSE
251                                         // ->   Miss Handling Completed
252                                         end else begin
253        1/1                                  next_mshr_entry.state       =   ST_IDLE             ;
254        1/1                                  next_mshr_entry.cmd         =   BUS_NONE            ;
255        1/1                                  next_mshr_entry.req_addr    =   'b0                 ;
256        1/1                                  next_mshr_entry.req_data    =   'b0                 ;
257        1/1                                  next_mshr_entry.req_size    =   BYTE                ;
258        1/1                                  next_mshr_entry.evict_addr  =   'b0                 ;
259        1/1                                  next_mshr_entry.evict_data  =   'b0                 ;
260        1/1                                  next_mshr_entry.evict_dirty =   1'b0                ;
261        1/1                                  next_mshr_entry.link_idx    =   'd0                 ;
262        1/1                                  next_mshr_entry.mem_tag     =   'd0                 ;
263        1/1                                  next_mshr_cp_flag           =   1'b1                ;
264        1/1                                  next_mshr_cp_data           =   mshr_entry.req_data ;
265                                         end
266                                     end
                        MISSING_ELSE
267                                 end
268                                 ST_EVICT    :   begin
269                                     // IF   the write back transaction to Memory is confirmed
270                                     // ->   Miss Handling Completed
271        1/1                          if ((memory_grant_i == 1'b1) && (mem2cache_i.response != 'd0)) begin
272        1/1                              next_mshr_entry.state       =   ST_IDLE             ;
273        1/1                              next_mshr_entry.cmd         =   BUS_NONE            ;
274        1/1                              next_mshr_entry.req_addr    =   'b0                 ;
275        1/1                              next_mshr_entry.req_data    =   'b0                 ;
276        1/1                              next_mshr_entry.req_size    =   BYTE                ;
277        1/1                              next_mshr_entry.evict_addr  =   'b0                 ;
278        1/1                              next_mshr_entry.evict_data  =   'b0                 ;
279        1/1                              next_mshr_entry.evict_dirty =   1'b0                ;
280        1/1                              next_mshr_entry.link_idx    =   'd0                 ;
281        1/1                              next_mshr_entry.mem_tag     =   'd0                 ;
282        1/1                              next_mshr_cp_flag           =   1'b1                ;
283        1/1                              next_mshr_cp_data           =   mshr_entry.req_data ;
284                                     end
                        MISSING_ELSE
285                                 end
286                                 default     :   begin
287        1/1                          next_mshr_entry.state       =   ST_IDLE     ;
288        1/1                          next_mshr_entry.cmd         =   BUS_NONE    ;
289        1/1                          next_mshr_entry.req_addr    =   'b0         ;
290        1/1                          next_mshr_entry.req_data    =   'b0         ;
291        1/1                          next_mshr_entry.req_size    =   BYTE        ;
292        1/1                          next_mshr_entry.evict_addr  =   'b0         ;
293        1/1                          next_mshr_entry.evict_data  =   'b0         ;
294        1/1                          next_mshr_entry.evict_dirty =   1'b0        ;
295        1/1                          next_mshr_entry.link_idx    =   'd0         ;
296        1/1                          next_mshr_entry.mem_tag     =   'd0         ;
297        1/1                          next_mshr_cp_flag           =   1'b0        ;
298        1/1                          next_mshr_cp_data           =   'd0         ;
299                                 end
300                             endcase
301                     
302        1/1                  if (next_mshr_entry.state == ST_IDLE) begin
303        1/1                      next_mshr_entry.linked  =   1'b0;
304        1/1                  end else if ((mshr_hit_i == 1'b1) && (mshr_hit_idx_i == mshr_entry_idx_i)) begin
305        1/1                      next_mshr_entry.linked  =   1'b1;
306                             end
                        MISSING_ELSE
307                         end
308                     
309                     // --------------------------------------------------------------------
310                     // MSHR entry output
311                     // --------------------------------------------------------------------
312                         assign  mshr_entry_o    =   mshr_entry  ;
313                     // --------------------------------------------------------------------
314                     // Processor Interface
315                     // --------------------------------------------------------------------
316                         always_comb begin
317        1/1                  mshr_proc_o.response    =   'd0 ;
318        1/1                  mshr_proc_o.data        =   'b0 ;
319        1/1                  mshr_proc_o.tag         =   'd0 ;
320        1/1                  case (mshr_entry.state)
321                                 ST_IDLE     :   begin
322                                     // IF   the processor request is allocated to this entry
323        1/1                          if ((proc2cache_i.command != BUS_NONE) && (dp_sel_i == 1'b1)) begin
324                                         // IF   The Processor Interface is granted to this entry
325                                         // AND  there is a dependency to older in-flight transaction
326                                         // ->   Confirm the request
327        1/1                              if (((mshr_hit_i && (cp_flag_i[mshr_hit_idx_i] == 1'b0))
328                                         || (evict_hit_i && (cp_flag_i[evict_hit_idx_i] == 1'b0)))) begin
329        1/1                                  mshr_proc_o.response    =   mshr_entry_idx_i;
330                                         // IF   The Processor Interface is granted to this entry
331                                         // AND  The cache_mem Interface is granted to this entry
332                                         // ->   Confirm the request 
333        1/1                              end else if (cache_mem_grant_i == 1'b1) begin
334        1/1                                  mshr_proc_o.response    =   mshr_entry_idx_i;
335                                             // IF   it is a load hit
336                                             // ->   Output data and tag
337        1/1                                  if (cache_mem_ctrl_i.req_hit == 1'b1 && proc2cache_i.command == BUS_LOAD) begin
338        0/1     ==>                              mshr_proc_o.tag     =   mshr_entry_idx_i;
339        0/1     ==>                              case (proc2cache_i.size)
340        0/1     ==>                                  BYTE    :   mshr_proc_o.data    =   {56'b0,cache_mem_ctrl_i.req_data_out[proc2cache_i.addr[2:0]+: 8]};
341        0/1     ==>                                  HALF    :   mshr_proc_o.data    =   {48'b0,cache_mem_ctrl_i.req_data_out[proc2cache_i.addr[2:0]+:16]};
342        0/1     ==>                                  WORD    :   mshr_proc_o.data    =   {32'b0,cache_mem_ctrl_i.req_data_out[proc2cache_i.addr[2:0]+:32]};
343        0/1     ==>                                  DOUBLE  :   mshr_proc_o.data    =   cache_mem_ctrl_i.req_data_out;
344        0/1     ==>                                  default :   mshr_proc_o.data    =   cache_mem_ctrl_i.req_data_out;
345                                                 endcase
346                                             end
                        MISSING_ELSE
347                                         end
                        MISSING_ELSE
348                                     end
                        MISSING_ELSE
349                                 end
350                                 ST_OUTPUT   :   begin
351        1/1                          mshr_proc_o.response    =   'd0                 ;
352        1/1                          mshr_proc_o.tag         =   mshr_entry_idx_i    ;
353        1/1                          case (mshr_entry.req_size)
354        1/1                              BYTE    :   mshr_proc_o.data    =   {56'b0,mshr_entry.req_data[mshr_entry.req_addr[2:0]+: 8]};
355        1/1                              HALF    :   mshr_proc_o.data    =   {48'b0,mshr_entry.req_data[mshr_entry.req_addr[2:0]+:16]};
356        1/1                              WORD    :   mshr_proc_o.data    =   {32'b0,mshr_entry.req_data[mshr_entry.req_addr[2:0]+:32]};
357        1/1                              DOUBLE  :   mshr_proc_o.data    =   mshr_entry.req_data;
358        0/1     ==>                      default :   mshr_proc_o.data    =   mshr_entry.req_data;
359                                     endcase
360                                 end
                        MISSING_DEFAULT
361                             endcase
362                         end
363                     
364                     // --------------------------------------------------------------------
365                     // cache_mem Interface
366                     // --------------------------------------------------------------------
367                         always_comb begin
368        1/1                  mshr_cache_mem_o.req_cmd        =   REQ_NONE;
369        1/1                  mshr_cache_mem_o.req_addr       =   'b0     ;
370        1/1                  mshr_cache_mem_o.req_data_in    =   'b0     ;
371        1/1                  case (mshr_entry.state)
372                                 ST_IDLE:    begin
373                                     // IF   the processor request is allocated to this entry
374        1/1                          if (dp_sel_i == 1'b1) begin
375        1/1                              case (proc2cache_i.command)
376                                             BUS_LOAD    :   begin
377        1/1                                      mshr_cache_mem_o.req_cmd        =   REQ_LOAD                        ;
378        1/1                                      mshr_cache_mem_o.req_addr       =   proc2cache_i.addr               ;
379        1/1                                      mshr_cache_mem_o.req_data_in    =   cache_mem_ctrl_i.req_data_out   ;
380                                             end
381                                             BUS_STORE   :   begin
382        1/1                                      mshr_cache_mem_o.req_cmd        =   REQ_STORE                       ;
383        1/1                                      mshr_cache_mem_o.req_addr       =   proc2cache_i.addr               ;
384        1/1                                      mshr_cache_mem_o.req_data_in    =   cache_mem_ctrl_i.req_data_out   ;
385        1/1                                      case (proc2cache_i.size)
386        1/1                                          BYTE    :   mshr_cache_mem_o.req_data_in[proc2cache_i.addr[2:0] +:  8]  =   proc2cache_i.data[ 7:0] ;
387        1/1                                          HALF    :   mshr_cache_mem_o.req_data_in[proc2cache_i.addr[2:0] +: 16]  =   proc2cache_i.data[15:0] ;
388        1/1                                          WORD    :   mshr_cache_mem_o.req_data_in[proc2cache_i.addr[2:0] +: 32]  =   proc2cache_i.data[31:0] ;
389        1/1                                          DOUBLE  :   mshr_cache_mem_o.req_data_in                                =   proc2cache_i.data       ;
                   ==>  MISSING_DEFAULT
390                                                 endcase
391                                             end    
                        MISSING_DEFAULT
392                                         endcase
393                                     end
                        MISSING_ELSE
394                                 end
395                                 ST_UPDATE:  begin
396        1/1                          if (mshr_entry.cmd == BUS_LOAD) begin
397        1/1                              mshr_cache_mem_o.req_cmd    =   REQ_LOAD_MISS       ;
398                                     end else begin
399        1/1                              mshr_cache_mem_o.req_cmd    =   REQ_STORE_MISS      ;
400                                     end
401        1/1                          mshr_cache_mem_o.req_addr       =   mshr_entry.req_addr ;
402        1/1                          mshr_cache_mem_o.req_data_in    =   mshr_entry.req_data ;
403                                 end
                        MISSING_DEFAULT
404                             endcase
405                         end
406                     
407                     // --------------------------------------------------------------------
408                     // Memory Interface
409                     // --------------------------------------------------------------------
410                         always_comb begin
411        1/1                  mshr_memory_o.addr      =   {mshr_entry.req_addr[C_XLEN-1:C_CACHE_OFFSET_WIDTH], {C_CACHE_OFFSET_WIDTH{1'b0}}};
412        1/1                  mshr_memory_o.size      =   DOUBLE              ;
413        1/1                  mshr_memory_o.command   =   BUS_NONE            ;
414        1/1                  mshr_memory_o.data      =   'd0 ;
415        1/1                  case (mshr_entry.state)
416                                 ST_RD_MEM   :   begin
417        1/1                          mshr_memory_o.data      =   'd0 ;
418        1/1                          mshr_memory_o.addr      =   {mshr_entry.req_addr[C_XLEN-1:C_CACHE_OFFSET_WIDTH], {C_CACHE_OFFSET_WIDTH{1'b0}}};
419        1/1                          mshr_memory_o.command   =   BUS_LOAD;
420                                 end
421                                 ST_EVICT    :   begin
422        1/1                          mshr_memory_o.data      =   mshr_entry.evict_data;
423        1/1                          mshr_memory_o.addr      =   {mshr_entry.evict_addr[C_XLEN-1:C_CACHE_OFFSET_WIDTH], {C_CACHE_OFFSET_WIDTH{1'b0}}};
424        1/1                          mshr_memory_o.command   =   BUS_STORE;
425                                 end
                        MISSING_DEFAULT

-------------------------------------------------------------------------------
Toggle Coverage for Instance : cache_tb.dut.cache_ctrl_inst.genblk1[4].mshr_entry_ctrl_inst
                Total Covered Percent 
Totals          72    47      65.28   
Total Bits      4844  3997    82.51   
Total Bits 0->1 2422  1998    82.49   
Total Bits 1->0 2422  1999    82.54   

                                
Ports          48   29   60.42  
Port Bits      3878 3181 82.03  
Port Bits 0->1 1939 1590 82.00  
Port Bits 1->0 1939 1591 82.05  

                                
Signals          24  18  75.00  
Signal Bits      966 816 84.47  
Signal Bits 0->1 483 408 84.47  
Signal Bits 1->0 483 408 84.47  

Port Details
                                     Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i                                Yes    Yes         Yes         INPUT     
rst_i                                No     Yes         No          INPUT     
mshr_entry_idx_i[3:0]                No     No          No          INPUT     
mshr_entry_o.mem_tag[3:0]            Yes    Yes         Yes         OUTPUT    
mshr_entry_o.linked                  No     No          No          OUTPUT    
mshr_entry_o.link_idx[3:0]           No     No          No          OUTPUT    
mshr_entry_o.evict_dirty             Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_data[63:0]        Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_addr[2:0]         No     No          No          OUTPUT    
mshr_entry_o.evict_addr[15:3]        Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_addr[31:16]       No     No          No          OUTPUT    
mshr_entry_o.req_size[1:0]           Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_data[63:0]          Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_addr[15:0]          Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_addr[31:16]         No     No          No          OUTPUT    
mshr_entry_o.cmd[1:0]                Yes    Yes         Yes         OUTPUT    
mshr_entry_o.state[2:0]              Yes    Yes         Yes         OUTPUT    
proc_grant_i                         Yes    Yes         Yes         INPUT     
proc2cache_i.command[1:0]            Yes    Yes         Yes         INPUT     
proc2cache_i.size[1:0]               Yes    Yes         Yes         INPUT     
proc2cache_i.data[63:0]              Yes    Yes         Yes         INPUT     
proc2cache_i.addr[15:0]              Yes    Yes         Yes         INPUT     
proc2cache_i.addr[31:16]             No     No          No          INPUT     
mshr_proc_o.tag[1:0]                 No     No          No          OUTPUT    
mshr_proc_o.tag[2]                   Yes    Yes         Yes         OUTPUT    
mshr_proc_o.tag[3]                   No     No          No          OUTPUT    
mshr_proc_o.data[0]                  Yes    Yes         Yes         OUTPUT    
mshr_proc_o.data[1]                  No     No          No          OUTPUT    
mshr_proc_o.data[2]                  Yes    Yes         Yes         OUTPUT    
mshr_proc_o.data[3]                  No     No          No          OUTPUT    
mshr_proc_o.data[4]                  Yes    Yes         Yes         OUTPUT    
mshr_proc_o.data[7:5]                No     No          No          OUTPUT    
mshr_proc_o.data[9:8]                Yes    Yes         Yes         OUTPUT    
mshr_proc_o.data[13:10]              No     No          No          OUTPUT    
mshr_proc_o.data[15:14]              Yes    Yes         Yes         OUTPUT    
mshr_proc_o.data[16]                 No     No          No          OUTPUT    
mshr_proc_o.data[18:17]              Yes    Yes         Yes         OUTPUT    
mshr_proc_o.data[21:19]              No     No          No          OUTPUT    
mshr_proc_o.data[22]                 Yes    Yes         Yes         OUTPUT    
mshr_proc_o.data[23]                 No     No          No          OUTPUT    
mshr_proc_o.data[24]                 Yes    Yes         Yes         OUTPUT    
mshr_proc_o.data[27:25]              No     No          No          OUTPUT    
mshr_proc_o.data[29:28]              Yes    Yes         Yes         OUTPUT    
mshr_proc_o.data[63:30]              No     No          No          OUTPUT    
mshr_proc_o.response[1:0]            No     No          No          OUTPUT    
mshr_proc_o.response[2]              Yes    Yes         Yes         OUTPUT    
mshr_proc_o.response[3]              No     No          No          OUTPUT    
cache_mem_grant_i                    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.evict_data[63:0]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.evict_addr[2:0]     No     No          No          INPUT     
cache_mem_ctrl_i.evict_addr[15:3]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.evict_addr[31:16]   No     No          No          INPUT     
cache_mem_ctrl_i.evict_dirty         Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[4:0]   Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[6:5]   No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[8:7]   Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[11:9]  No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[13:12] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[15:14] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[25:16] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[26]    No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[31:27] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[33:32] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[34]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[37:35] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[38]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[41:39] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[42]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[45:43] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[47:46] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[50:48] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[52:51] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[54:53] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[58:55] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[60:59] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[63:61] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_hit             Yes    Yes         Yes         INPUT     
mshr_cache_mem_o.req_data_in[63:0]   Yes    Yes         Yes         OUTPUT    
mshr_cache_mem_o.req_addr[15:0]      Yes    Yes         Yes         OUTPUT    
mshr_cache_mem_o.req_addr[31:16]     No     No          No          OUTPUT    
mshr_cache_mem_o.req_cmd[2:0]        Yes    Yes         Yes         OUTPUT    
memory_grant_i                       Yes    Yes         Yes         INPUT     
mem2cache_i.tag[3:0]                 Yes    Yes         Yes         INPUT     
mem2cache_i.data[63:0]               Yes    Yes         Yes         INPUT     
mem2cache_i.response[3:0]            Yes    Yes         Yes         INPUT     
mshr_memory_o.command[1:0]           Yes    Yes         Yes         OUTPUT    
mshr_memory_o.size[1:0]              No     No          No          OUTPUT    
mshr_memory_o.data[63:0]             Yes    Yes         Yes         OUTPUT    
mshr_memory_o.addr[2:0]              No     No          No          OUTPUT    
mshr_memory_o.addr[15:3]             Yes    Yes         Yes         OUTPUT    
mshr_memory_o.addr[31:16]            No     No          No          OUTPUT    
mshr_hit_i                           Yes    Yes         Yes         INPUT     
mshr_hit_idx_i[3:0]                  Yes    Yes         Yes         INPUT     
evict_hit_i                          No     No          No          INPUT     
evict_hit_idx_i[3:0]                 No     No          No          INPUT     
dp_sel_i                             Yes    Yes         Yes         INPUT     
mshr_cp_flag_o                       Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[63:0]                 Yes    Yes         Yes         OUTPUT    
cp_flag_i[0]                         No     No          No          INPUT     
cp_flag_i[15:1]                      Yes    Yes         Yes         INPUT     
cp_data_i[8:1][63:0]                 Yes    Yes         Yes         INPUT     
cp_data_i[9][44:0]                   Yes    Yes         Yes         INPUT     
cp_data_i[9][63:46]                  Yes    Yes         Yes         INPUT     
cp_data_i[10][30:1]                  Yes    Yes         Yes         INPUT     
cp_data_i[10][36:32]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][41:40]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][45]                    Yes    Yes         Yes         INPUT     
cp_data_i[10][49:47]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][52:51]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][56:55]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][60]                    Yes    Yes         Yes         INPUT     
cp_data_i[10][62]                    Yes    Yes         Yes         INPUT     
cp_data_i[11][27:0]                  Yes    Yes         Yes         INPUT     
cp_data_i[11][36:29]                 Yes    Yes         Yes         INPUT     
cp_data_i[11][49:39]                 Yes    Yes         Yes         INPUT     
cp_data_i[11][51]                    Yes    Yes         Yes         INPUT     
cp_data_i[11][59:54]                 Yes    Yes         Yes         INPUT     
cp_data_i[11][63:62]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][4:0]                   Yes    Yes         Yes         INPUT     
cp_data_i[12][27:6]                  Yes    Yes         Yes         INPUT     
cp_data_i[12][31:29]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][35:33]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][39]                    Yes    Yes         Yes         INPUT     
cp_data_i[12][44:43]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][48:46]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][50]                    Yes    Yes         Yes         INPUT     
cp_data_i[12][54]                    Yes    Yes         Yes         INPUT     
cp_data_i[12][58:57]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][61]                    Yes    Yes         Yes         INPUT     
cp_data_i[13][17:0]                  Yes    Yes         Yes         INPUT     
cp_data_i[13][46:19]                 Yes    Yes         Yes         INPUT     
cp_data_i[13][49]                    Yes    Yes         Yes         INPUT     
cp_data_i[13][56:51]                 Yes    Yes         Yes         INPUT     
cp_data_i[13][63:58]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][14:1]                  Yes    Yes         Yes         INPUT     
cp_data_i[14][19:16]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][21]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][24:23]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][27]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][32:30]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][37:35]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][39]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][41]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][43]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][46:45]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][51:49]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][59:53]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][62:61]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][15:0]                  Yes    Yes         Yes         INPUT     
cp_data_i[15][37:17]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][40:39]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][42]                    Yes    Yes         Yes         INPUT     
cp_data_i[15][45:44]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][48:47]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][53:51]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][55]                    Yes    Yes         Yes         INPUT     
cp_data_i[15][63:57]                 Yes    Yes         Yes         INPUT     
Other bits of cp_data_i[15:0][63:0]  No     No          No          INPUT     

Signal Details
                                  Toggle Toggle 1->0 Toggle 0->1 
mshr_entry.mem_tag[3:0]           Yes    Yes         Yes         
mshr_entry.linked                 No     No          No          
mshr_entry.link_idx[3:0]          No     No          No          
mshr_entry.evict_dirty            Yes    Yes         Yes         
mshr_entry.evict_data[63:0]       Yes    Yes         Yes         
mshr_entry.evict_addr[2:0]        No     No          No          
mshr_entry.evict_addr[15:3]       Yes    Yes         Yes         
mshr_entry.evict_addr[31:16]      No     No          No          
mshr_entry.req_size[1:0]          Yes    Yes         Yes         
mshr_entry.req_data[63:0]         Yes    Yes         Yes         
mshr_entry.req_addr[15:0]         Yes    Yes         Yes         
mshr_entry.req_addr[31:16]        No     No          No          
mshr_entry.cmd[1:0]               Yes    Yes         Yes         
mshr_entry.state[2:0]             Yes    Yes         Yes         
next_mshr_entry.mem_tag[3:0]      Yes    Yes         Yes         
next_mshr_entry.linked            Yes    Yes         Yes         
next_mshr_entry.link_idx[3:0]     Yes    Yes         Yes         
next_mshr_entry.evict_dirty       Yes    Yes         Yes         
next_mshr_entry.evict_data[63:0]  Yes    Yes         Yes         
next_mshr_entry.evict_addr[2:0]   No     No          No          
next_mshr_entry.evict_addr[15:3]  Yes    Yes         Yes         
next_mshr_entry.evict_addr[31:16] No     No          No          
next_mshr_entry.req_size[1:0]     Yes    Yes         Yes         
next_mshr_entry.req_data[63:0]    Yes    Yes         Yes         
next_mshr_entry.req_addr[15:0]    Yes    Yes         Yes         
next_mshr_entry.req_addr[31:16]   No     No          No          
next_mshr_entry.cmd[1:0]          Yes    Yes         Yes         
next_mshr_entry.state[2:0]        Yes    Yes         Yes         
next_mshr_cp_flag                 Yes    Yes         Yes         
next_mshr_cp_data[63:0]           Yes    Yes         Yes         


-------------------------------------------------------------------------------
===============================================================================
Module Instance : cache_tb.dut.cache_ctrl_inst.genblk1[3].mshr_entry_ctrl_inst
===============================================================================

Instance :

SCORE  LINE   TOGGLE 
 84.60  87.14  82.06 


Instance's subtree :

SCORE  LINE   TOGGLE 
 84.60  87.14  82.06 


Module : 

SCORE  LINE   TOGGLE NAME            
 87.59  90.48  84.70 mshr_entry_ctrl 


Parent : 

SCORE  LINE   TOGGLE NAME            
 92.38 100.00  84.76 cache_ctrl_inst 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : cache_tb.dut.cache_ctrl_inst.genblk1[3].mshr_entry_ctrl_inst

             Line No.   Total   Covered  Percent
TOTAL                      210      183    87.14
ALWAYS             75       17       17   100.00
ALWAYS             97      135      113    83.70
ALWAYS            317       25       20    80.00
ALWAYS            368       22       22   100.00
ALWAYS            411       11       11   100.00

74                          always_ff @(posedge clk_i) begin
75         1/1                  if (rst_i) begin
76         1/1                      mshr_entry.state        <=  `SD ST_IDLE     ;
77         1/1                      mshr_entry.cmd          <=  `SD BUS_NONE    ;
78         1/1                      mshr_entry.req_addr     <=  `SD 'b0         ;
79         1/1                      mshr_entry.req_data     <=  `SD 'b0         ;
80         1/1                      mshr_entry.req_size     <=  `SD BYTE        ;
81         1/1                      mshr_entry.evict_addr   <=  `SD 'b0         ;
82         1/1                      mshr_entry.evict_data   <=  `SD 'b0         ;
83         1/1                      mshr_entry.evict_dirty  <=  `SD 1'b0        ;
84         1/1                      mshr_entry.link_idx     <=  `SD 'd0         ;
85         1/1                      mshr_entry.linked       <=  `SD 1'b0        ;
86         1/1                      mshr_entry.mem_tag      <=  `SD 'd0         ;
87         1/1                      mshr_cp_flag_o          <=  `SD 1'b0        ;
88         1/1                      mshr_cp_data_o          <=  `SD 'b0         ;
89                              end else begin
90         1/1                      mshr_entry              <=  `SD next_mshr_entry     ;
91         1/1                      mshr_cp_flag_o          <=  `SD next_mshr_cp_flag   ;
92         1/1                      mshr_cp_data_o          <=  `SD next_mshr_cp_data   ;
93                              end
94                          end
95                      
96                          always_comb begin
97         1/1                  next_mshr_entry.state       =   mshr_entry.state        ;
98         1/1                  next_mshr_entry.cmd         =   mshr_entry.cmd          ;
99         1/1                  next_mshr_entry.req_addr    =   mshr_entry.req_addr     ;
100        1/1                  next_mshr_entry.req_data    =   mshr_entry.req_data     ;
101        1/1                  next_mshr_entry.req_size    =   mshr_entry.req_size     ;
102        1/1                  next_mshr_entry.evict_addr  =   mshr_entry.evict_addr   ;
103        1/1                  next_mshr_entry.evict_data  =   mshr_entry.evict_data   ;
104        1/1                  next_mshr_entry.evict_dirty =   mshr_entry.evict_dirty  ;
105        1/1                  next_mshr_entry.link_idx    =   mshr_entry.link_idx     ;
106        1/1                  next_mshr_entry.linked      =   mshr_entry.linked       ;
107        1/1                  next_mshr_entry.mem_tag     =   mshr_entry.mem_tag      ;
108        1/1                  next_mshr_cp_flag           =   mshr_cp_flag_o          ;
109        1/1                  next_mshr_cp_data           =   mshr_cp_data_o          ;
110        1/1                  case (mshr_entry.state)
111                                 ST_IDLE     :   begin
112                                     // IF   there is a valid transaction on Processor Interface
113                                     // AND  the Processor Interface is granted to this entry
114                                     // AND  the cache_mem Interface is granted to this entry
115                                     // AND  it is a miss
116                                     // AND  the entry is selected to hold the new miss
117        1/1                          if ((proc2cache_i.command != BUS_NONE) && (dp_sel_i == 1'b1)
118                                     && (proc_grant_i == 1'b1)) begin
119                                         // IF   there is an older in-flight transaction to the same addreess
120                                         // ->   Wait for the completion of older miss to the same address
121        1/1                              if (mshr_hit_i && (cp_flag_i[mshr_hit_idx_i] == 1'b0)) begin
122        1/1                                  next_mshr_entry.state       =   ST_WAIT_DEPEND          ;
123        1/1                                  next_mshr_entry.link_idx    =   mshr_hit_idx_i          ;
124        1/1                                  next_mshr_entry.cmd         =   proc2cache_i.command    ;
125        1/1                                  next_mshr_entry.req_addr    =   proc2cache_i.addr       ;
126        1/1                                  next_mshr_entry.req_size    =   proc2cache_i.size       ;
127        1/1                                  if (proc2cache_i.command == BUS_STORE) begin
128        1/1                                      next_mshr_entry.req_data    =   proc2cache_i.data   ;
129                                             end
                        MISSING_ELSE
130                                         // IF   there is an older in-flight transaction that is in the middle of evicting the data block
131                                         // ->   Wait for the completion of write-back to memory
132        1/1                              end else if (evict_hit_i && (cp_flag_i[evict_hit_idx_i] == 1'b0)) begin
133        0/1     ==>                          next_mshr_entry.state       =   ST_WAIT_EVICT           ;
134        0/1     ==>                          next_mshr_entry.link_idx    =   evict_hit_idx_i         ;
135        0/1     ==>                          next_mshr_entry.cmd         =   proc2cache_i.command    ;
136        0/1     ==>                          next_mshr_entry.req_addr    =   proc2cache_i.addr       ;
137        0/1     ==>                          next_mshr_entry.req_size    =   proc2cache_i.size       ;
138        0/1     ==>                          if (proc2cache_i.command == BUS_STORE) begin
139        0/1     ==>                              next_mshr_entry.req_data    =   proc2cache_i.data   ;
140                                             end
                   ==>  MISSING_ELSE
141                                         // IF   it is a miss, and no dependency to older in-flight transactions.
142                                         // ->   Start miss handling
143        1/1                              end else if ((cache_mem_ctrl_i.req_hit == 1'b0) && (cache_mem_grant_i == 1'b1)) begin
144        1/1                                  next_mshr_entry.state       =   ST_RD_MEM               ;
145        1/1                                  next_mshr_entry.link_idx    =   'd0                     ;
146        1/1                                  next_mshr_entry.cmd         =   proc2cache_i.command    ;
147        1/1                                  next_mshr_entry.req_addr    =   proc2cache_i.addr       ;
148        1/1                                  next_mshr_entry.req_size    =   proc2cache_i.size       ;
149        1/1                                  if (proc2cache_i.command == BUS_STORE) begin
150        1/1                                      next_mshr_entry.req_data    =   proc2cache_i.data   ;
151                                             end
                        MISSING_ELSE
152                                         end
                        MISSING_ELSE
153                                     end
                        MISSING_ELSE
154        1/1                          next_mshr_cp_flag   =   1'b0    ;
155        1/1                          next_mshr_cp_data   =   'b0     ;
156                                 end
157                                 ST_WAIT_DEPEND  :   begin
158                                     // IF   the older transaction that the entry is linked to completed
159                                     // ->   Update the cache data
160        0/1     ==>                  if (cp_flag_i[mshr_entry.link_idx] == 1'b1) begin
161        0/1     ==>                      next_mshr_entry.state       =   ST_UPDATE   ;
162        0/1     ==>                      next_mshr_entry.link_idx    =   'd0         ;
163        0/1     ==>                      next_mshr_entry.req_data    =   cp_data_i[mshr_entry.link_idx];
164        0/1     ==>                      if (mshr_entry.cmd == BUS_STORE) begin
165        0/1     ==>                          case (mshr_entry.req_size)
166        0/1     ==>                              BYTE    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +:  8]    =   mshr_entry.req_data[ 7:0]   ;
167        0/1     ==>                              HALF    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +: 16]    =   mshr_entry.req_data[15:0]   ;
168        0/1     ==>                              WORD    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +: 32]    =   mshr_entry.req_data[31:0]   ;
169        0/1     ==>                              DOUBLE  :   next_mshr_entry.req_data                                    =   mshr_entry.req_data         ;
170        0/1     ==>                              default :   next_mshr_entry.req_data                                    =   mshr_entry.req_data         ;
171                                             endcase
172                                         end
                   ==>  MISSING_ELSE
173                                     end
                   ==>  MISSING_ELSE
174                                 end
175                                 ST_WAIT_EVICT   : begin
176                                     // IF   the older transaction that evicts the cache block completed
177                                     // ->   Read from Memory
178        0/1     ==>                  if (cp_flag_i[mshr_entry.link_idx] == 1'b1) begin
179        0/1     ==>                      next_mshr_entry.state       =   ST_RD_MEM   ;
180        0/1     ==>                      next_mshr_entry.link_idx    =   'd0         ;
181                                     end
                   ==>  MISSING_ELSE
182                                 end
183                                 ST_RD_MEM   :   begin
184                                     // IF   the read transaction is confirmed by Memory Interface
185                                     // ->   Wait for the data to return from Memory
186        1/1                          if ((memory_grant_i == 1'b1) && (mem2cache_i.response != 'd0)) begin
187        1/1                              next_mshr_entry.state       =   ST_WAIT_MEM             ;
188        1/1                              next_mshr_entry.mem_tag     =   mem2cache_i.response    ;
189                                     end
                        MISSING_ELSE
190                                 end
191                                 ST_WAIT_MEM :   begin
192                                     // IF   the data is returned from the Memory
193                                     // ->   Update the cache data
194        1/1                          if (mem2cache_i.tag == mshr_entry.mem_tag) begin
195        1/1                              next_mshr_entry.state       =   ST_UPDATE           ;
196        1/1                              next_mshr_entry.req_data    =   mem2cache_i.data    ;
197        1/1                              if (mshr_entry.cmd == BUS_STORE) begin
198        1/1                                  case (mshr_entry.req_size)
199        1/1                                      BYTE    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +:  8]    =   mshr_entry.req_data[ 7:0]   ;
200        1/1                                      HALF    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +: 16]    =   mshr_entry.req_data[15:0]   ;
201        1/1                                      WORD    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +: 32]    =   mshr_entry.req_data[31:0]   ;
202        1/1                                      DOUBLE  :   next_mshr_entry.req_data                                    =   mshr_entry.req_data         ;
203        0/1     ==>                              default :   next_mshr_entry.req_data                                    =   mshr_entry.req_data         ;
204                                             endcase
205                                         end
                        MISSING_ELSE
206                                     end
                        MISSING_ELSE
207                                 end
208                                 ST_UPDATE   :   begin
209                                     // IF   the req interface is granted to this entry
210        1/1                          if (cache_mem_grant_i == 1'b1) begin
211                                         // IF   it is a load miss
212                                         // ->   Output data to processor
213        1/1                              if (mshr_entry.cmd == BUS_LOAD) begin
214        1/1                                  next_mshr_entry.state       =   ST_OUTPUT;
215        1/1                                  next_mshr_entry.evict_addr  =   cache_mem_ctrl_i.evict_addr ;
216        1/1                                  next_mshr_entry.evict_data  =   cache_mem_ctrl_i.evict_data ;
217        1/1                                  next_mshr_entry.evict_dirty =   cache_mem_ctrl_i.evict_dirty;
218                                         // IF   a dirty block is evicted
219                                         // ->   Write back the evicted block
220        1/1                              end else if (cache_mem_ctrl_i.evict_dirty == 1'b1) begin
221        1/1                                  next_mshr_entry.state       =   ST_EVICT;
222        1/1                                  next_mshr_entry.evict_addr  =   cache_mem_ctrl_i.evict_addr ;
223        1/1                                  next_mshr_entry.evict_data  =   cache_mem_ctrl_i.evict_data ;
224        1/1                                  next_mshr_entry.evict_dirty =   cache_mem_ctrl_i.evict_dirty;
225                                         // ELSE
226                                         // ->   Miss Handling Completed
227                                         end else begin
228        1/1                                  next_mshr_entry.state       =   ST_IDLE             ;
229        1/1                                  next_mshr_entry.cmd         =   BUS_NONE            ;
230        1/1                                  next_mshr_entry.req_addr    =   'b0                 ;
231        1/1                                  next_mshr_entry.req_data    =   'b0                 ;
232        1/1                                  next_mshr_entry.req_size    =   BYTE                ;
233        1/1                                  next_mshr_entry.evict_addr  =   'b0                 ;
234        1/1                                  next_mshr_entry.evict_data  =   'b0                 ;
235        1/1                                  next_mshr_entry.evict_dirty =   1'b0                ;
236        1/1                                  next_mshr_entry.link_idx    =   'd0                 ;
237        1/1                                  next_mshr_entry.mem_tag     =   'd0                 ;
238        1/1                                  next_mshr_cp_flag           =   1'b1                ;
239        1/1                                  next_mshr_cp_data           =   mshr_entry.req_data ;
240                                         end
241                                     end
                        MISSING_ELSE
242                                 end
243                                 ST_OUTPUT   :   begin
244                                     // IF   the Processor Interface is granted to this entry
245        1/1                          if (proc_grant_i == 1'b1) begin
246                                         // IF   the evicted block is dirty
247                                         // ->   Write back the evicted block
248        1/1                              if (mshr_entry.evict_dirty == 1'b1) begin
249        1/1                                  next_mshr_entry.state       =   ST_EVICT;
250                                         // ELSE
251                                         // ->   Miss Handling Completed
252                                         end else begin
253        1/1                                  next_mshr_entry.state       =   ST_IDLE             ;
254        1/1                                  next_mshr_entry.cmd         =   BUS_NONE            ;
255        1/1                                  next_mshr_entry.req_addr    =   'b0                 ;
256        1/1                                  next_mshr_entry.req_data    =   'b0                 ;
257        1/1                                  next_mshr_entry.req_size    =   BYTE                ;
258        1/1                                  next_mshr_entry.evict_addr  =   'b0                 ;
259        1/1                                  next_mshr_entry.evict_data  =   'b0                 ;
260        1/1                                  next_mshr_entry.evict_dirty =   1'b0                ;
261        1/1                                  next_mshr_entry.link_idx    =   'd0                 ;
262        1/1                                  next_mshr_entry.mem_tag     =   'd0                 ;
263        1/1                                  next_mshr_cp_flag           =   1'b1                ;
264        1/1                                  next_mshr_cp_data           =   mshr_entry.req_data ;
265                                         end
266                                     end
                        MISSING_ELSE
267                                 end
268                                 ST_EVICT    :   begin
269                                     // IF   the write back transaction to Memory is confirmed
270                                     // ->   Miss Handling Completed
271        1/1                          if ((memory_grant_i == 1'b1) && (mem2cache_i.response != 'd0)) begin
272        1/1                              next_mshr_entry.state       =   ST_IDLE             ;
273        1/1                              next_mshr_entry.cmd         =   BUS_NONE            ;
274        1/1                              next_mshr_entry.req_addr    =   'b0                 ;
275        1/1                              next_mshr_entry.req_data    =   'b0                 ;
276        1/1                              next_mshr_entry.req_size    =   BYTE                ;
277        1/1                              next_mshr_entry.evict_addr  =   'b0                 ;
278        1/1                              next_mshr_entry.evict_data  =   'b0                 ;
279        1/1                              next_mshr_entry.evict_dirty =   1'b0                ;
280        1/1                              next_mshr_entry.link_idx    =   'd0                 ;
281        1/1                              next_mshr_entry.mem_tag     =   'd0                 ;
282        1/1                              next_mshr_cp_flag           =   1'b1                ;
283        1/1                              next_mshr_cp_data           =   mshr_entry.req_data ;
284                                     end
                        MISSING_ELSE
285                                 end
286                                 default     :   begin
287        1/1                          next_mshr_entry.state       =   ST_IDLE     ;
288        1/1                          next_mshr_entry.cmd         =   BUS_NONE    ;
289        1/1                          next_mshr_entry.req_addr    =   'b0         ;
290        1/1                          next_mshr_entry.req_data    =   'b0         ;
291        1/1                          next_mshr_entry.req_size    =   BYTE        ;
292        1/1                          next_mshr_entry.evict_addr  =   'b0         ;
293        1/1                          next_mshr_entry.evict_data  =   'b0         ;
294        1/1                          next_mshr_entry.evict_dirty =   1'b0        ;
295        1/1                          next_mshr_entry.link_idx    =   'd0         ;
296        1/1                          next_mshr_entry.mem_tag     =   'd0         ;
297        1/1                          next_mshr_cp_flag           =   1'b0        ;
298        1/1                          next_mshr_cp_data           =   'd0         ;
299                                 end
300                             endcase
301                     
302        1/1                  if (next_mshr_entry.state == ST_IDLE) begin
303        1/1                      next_mshr_entry.linked  =   1'b0;
304        1/1                  end else if ((mshr_hit_i == 1'b1) && (mshr_hit_idx_i == mshr_entry_idx_i)) begin
305        1/1                      next_mshr_entry.linked  =   1'b1;
306                             end
                        MISSING_ELSE
307                         end
308                     
309                     // --------------------------------------------------------------------
310                     // MSHR entry output
311                     // --------------------------------------------------------------------
312                         assign  mshr_entry_o    =   mshr_entry  ;
313                     // --------------------------------------------------------------------
314                     // Processor Interface
315                     // --------------------------------------------------------------------
316                         always_comb begin
317        1/1                  mshr_proc_o.response    =   'd0 ;
318        1/1                  mshr_proc_o.data        =   'b0 ;
319        1/1                  mshr_proc_o.tag         =   'd0 ;
320        1/1                  case (mshr_entry.state)
321                                 ST_IDLE     :   begin
322                                     // IF   the processor request is allocated to this entry
323        1/1                          if ((proc2cache_i.command != BUS_NONE) && (dp_sel_i == 1'b1)) begin
324                                         // IF   The Processor Interface is granted to this entry
325                                         // AND  there is a dependency to older in-flight transaction
326                                         // ->   Confirm the request
327        1/1                              if (((mshr_hit_i && (cp_flag_i[mshr_hit_idx_i] == 1'b0))
328                                         || (evict_hit_i && (cp_flag_i[evict_hit_idx_i] == 1'b0)))) begin
329        1/1                                  mshr_proc_o.response    =   mshr_entry_idx_i;
330                                         // IF   The Processor Interface is granted to this entry
331                                         // AND  The cache_mem Interface is granted to this entry
332                                         // ->   Confirm the request 
333        1/1                              end else if (cache_mem_grant_i == 1'b1) begin
334        1/1                                  mshr_proc_o.response    =   mshr_entry_idx_i;
335                                             // IF   it is a load hit
336                                             // ->   Output data and tag
337        1/1                                  if (cache_mem_ctrl_i.req_hit == 1'b1 && proc2cache_i.command == BUS_LOAD) begin
338        1/1                                      mshr_proc_o.tag     =   mshr_entry_idx_i;
339        1/1                                      case (proc2cache_i.size)
340        1/1                                          BYTE    :   mshr_proc_o.data    =   {56'b0,cache_mem_ctrl_i.req_data_out[proc2cache_i.addr[2:0]+: 8]};
341        0/1     ==>                                  HALF    :   mshr_proc_o.data    =   {48'b0,cache_mem_ctrl_i.req_data_out[proc2cache_i.addr[2:0]+:16]};
342        0/1     ==>                                  WORD    :   mshr_proc_o.data    =   {32'b0,cache_mem_ctrl_i.req_data_out[proc2cache_i.addr[2:0]+:32]};
343        0/1     ==>                                  DOUBLE  :   mshr_proc_o.data    =   cache_mem_ctrl_i.req_data_out;
344        0/1     ==>                                  default :   mshr_proc_o.data    =   cache_mem_ctrl_i.req_data_out;
345                                                 endcase
346                                             end
                        MISSING_ELSE
347                                         end
                        MISSING_ELSE
348                                     end
                        MISSING_ELSE
349                                 end
350                                 ST_OUTPUT   :   begin
351        1/1                          mshr_proc_o.response    =   'd0                 ;
352        1/1                          mshr_proc_o.tag         =   mshr_entry_idx_i    ;
353        1/1                          case (mshr_entry.req_size)
354        1/1                              BYTE    :   mshr_proc_o.data    =   {56'b0,mshr_entry.req_data[mshr_entry.req_addr[2:0]+: 8]};
355        1/1                              HALF    :   mshr_proc_o.data    =   {48'b0,mshr_entry.req_data[mshr_entry.req_addr[2:0]+:16]};
356        1/1                              WORD    :   mshr_proc_o.data    =   {32'b0,mshr_entry.req_data[mshr_entry.req_addr[2:0]+:32]};
357        1/1                              DOUBLE  :   mshr_proc_o.data    =   mshr_entry.req_data;
358        0/1     ==>                      default :   mshr_proc_o.data    =   mshr_entry.req_data;
359                                     endcase
360                                 end
                        MISSING_DEFAULT
361                             endcase
362                         end
363                     
364                     // --------------------------------------------------------------------
365                     // cache_mem Interface
366                     // --------------------------------------------------------------------
367                         always_comb begin
368        1/1                  mshr_cache_mem_o.req_cmd        =   REQ_NONE;
369        1/1                  mshr_cache_mem_o.req_addr       =   'b0     ;
370        1/1                  mshr_cache_mem_o.req_data_in    =   'b0     ;
371        1/1                  case (mshr_entry.state)
372                                 ST_IDLE:    begin
373                                     // IF   the processor request is allocated to this entry
374        1/1                          if (dp_sel_i == 1'b1) begin
375        1/1                              case (proc2cache_i.command)
376                                             BUS_LOAD    :   begin
377        1/1                                      mshr_cache_mem_o.req_cmd        =   REQ_LOAD                        ;
378        1/1                                      mshr_cache_mem_o.req_addr       =   proc2cache_i.addr               ;
379        1/1                                      mshr_cache_mem_o.req_data_in    =   cache_mem_ctrl_i.req_data_out   ;
380                                             end
381                                             BUS_STORE   :   begin
382        1/1                                      mshr_cache_mem_o.req_cmd        =   REQ_STORE                       ;
383        1/1                                      mshr_cache_mem_o.req_addr       =   proc2cache_i.addr               ;
384        1/1                                      mshr_cache_mem_o.req_data_in    =   cache_mem_ctrl_i.req_data_out   ;
385        1/1                                      case (proc2cache_i.size)
386        1/1                                          BYTE    :   mshr_cache_mem_o.req_data_in[proc2cache_i.addr[2:0] +:  8]  =   proc2cache_i.data[ 7:0] ;
387        1/1                                          HALF    :   mshr_cache_mem_o.req_data_in[proc2cache_i.addr[2:0] +: 16]  =   proc2cache_i.data[15:0] ;
388        1/1                                          WORD    :   mshr_cache_mem_o.req_data_in[proc2cache_i.addr[2:0] +: 32]  =   proc2cache_i.data[31:0] ;
389        1/1                                          DOUBLE  :   mshr_cache_mem_o.req_data_in                                =   proc2cache_i.data       ;
                   ==>  MISSING_DEFAULT
390                                                 endcase
391                                             end    
                        MISSING_DEFAULT
392                                         endcase
393                                     end
                        MISSING_ELSE
394                                 end
395                                 ST_UPDATE:  begin
396        1/1                          if (mshr_entry.cmd == BUS_LOAD) begin
397        1/1                              mshr_cache_mem_o.req_cmd    =   REQ_LOAD_MISS       ;
398                                     end else begin
399        1/1                              mshr_cache_mem_o.req_cmd    =   REQ_STORE_MISS      ;
400                                     end
401        1/1                          mshr_cache_mem_o.req_addr       =   mshr_entry.req_addr ;
402        1/1                          mshr_cache_mem_o.req_data_in    =   mshr_entry.req_data ;
403                                 end
                        MISSING_DEFAULT
404                             endcase
405                         end
406                     
407                     // --------------------------------------------------------------------
408                     // Memory Interface
409                     // --------------------------------------------------------------------
410                         always_comb begin
411        1/1                  mshr_memory_o.addr      =   {mshr_entry.req_addr[C_XLEN-1:C_CACHE_OFFSET_WIDTH], {C_CACHE_OFFSET_WIDTH{1'b0}}};
412        1/1                  mshr_memory_o.size      =   DOUBLE              ;
413        1/1                  mshr_memory_o.command   =   BUS_NONE            ;
414        1/1                  mshr_memory_o.data      =   'd0 ;
415        1/1                  case (mshr_entry.state)
416                                 ST_RD_MEM   :   begin
417        1/1                          mshr_memory_o.data      =   'd0 ;
418        1/1                          mshr_memory_o.addr      =   {mshr_entry.req_addr[C_XLEN-1:C_CACHE_OFFSET_WIDTH], {C_CACHE_OFFSET_WIDTH{1'b0}}};
419        1/1                          mshr_memory_o.command   =   BUS_LOAD;
420                                 end
421                                 ST_EVICT    :   begin
422        1/1                          mshr_memory_o.data      =   mshr_entry.evict_data;
423        1/1                          mshr_memory_o.addr      =   {mshr_entry.evict_addr[C_XLEN-1:C_CACHE_OFFSET_WIDTH], {C_CACHE_OFFSET_WIDTH{1'b0}}};
424        1/1                          mshr_memory_o.command   =   BUS_STORE;
425                                 end
                        MISSING_DEFAULT

-------------------------------------------------------------------------------
Toggle Coverage for Instance : cache_tb.dut.cache_ctrl_inst.genblk1[3].mshr_entry_ctrl_inst
                Total Covered Percent 
Totals          72    47      65.28   
Total Bits      4844  3975    82.06   
Total Bits 0->1 2422  1987    82.04   
Total Bits 1->0 2422  1988    82.08   

                                
Ports          48   29   60.42  
Port Bits      3878 3159 81.46  
Port Bits 0->1 1939 1579 81.43  
Port Bits 1->0 1939 1580 81.49  

                                
Signals          24  18  75.00  
Signal Bits      966 816 84.47  
Signal Bits 0->1 483 408 84.47  
Signal Bits 1->0 483 408 84.47  

Port Details
                                     Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i                                Yes    Yes         Yes         INPUT     
rst_i                                No     Yes         No          INPUT     
mshr_entry_idx_i[3:0]                No     No          No          INPUT     
mshr_entry_o.mem_tag[3:0]            Yes    Yes         Yes         OUTPUT    
mshr_entry_o.linked                  No     No          No          OUTPUT    
mshr_entry_o.link_idx[3:0]           No     No          No          OUTPUT    
mshr_entry_o.evict_dirty             Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_data[63:0]        Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_addr[2:0]         No     No          No          OUTPUT    
mshr_entry_o.evict_addr[15:3]        Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_addr[31:16]       No     No          No          OUTPUT    
mshr_entry_o.req_size[1:0]           Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_data[63:0]          Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_addr[15:0]          Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_addr[31:16]         No     No          No          OUTPUT    
mshr_entry_o.cmd[1:0]                Yes    Yes         Yes         OUTPUT    
mshr_entry_o.state[2:0]              Yes    Yes         Yes         OUTPUT    
proc_grant_i                         Yes    Yes         Yes         INPUT     
proc2cache_i.command[1:0]            Yes    Yes         Yes         INPUT     
proc2cache_i.size[1:0]               Yes    Yes         Yes         INPUT     
proc2cache_i.data[63:0]              Yes    Yes         Yes         INPUT     
proc2cache_i.addr[15:0]              Yes    Yes         Yes         INPUT     
proc2cache_i.addr[31:16]             No     No          No          INPUT     
mshr_proc_o.tag[1:0]                 Yes    Yes         Yes         OUTPUT    
mshr_proc_o.tag[3:2]                 No     No          No          OUTPUT    
mshr_proc_o.data[63:0]               No     No          No          OUTPUT    
mshr_proc_o.response[1:0]            Yes    Yes         Yes         OUTPUT    
mshr_proc_o.response[3:2]            No     No          No          OUTPUT    
cache_mem_grant_i                    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.evict_data[63:0]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.evict_addr[2:0]     No     No          No          INPUT     
cache_mem_ctrl_i.evict_addr[15:3]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.evict_addr[31:16]   No     No          No          INPUT     
cache_mem_ctrl_i.evict_dirty         Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[4:0]   Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[6:5]   No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[8:7]   Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[11:9]  No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[13:12] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[15:14] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[25:16] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[26]    No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[31:27] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[33:32] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[34]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[37:35] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[38]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[41:39] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[42]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[45:43] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[47:46] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[50:48] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[52:51] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[54:53] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[58:55] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[60:59] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[63:61] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_hit             Yes    Yes         Yes         INPUT     
mshr_cache_mem_o.req_data_in[63:0]   Yes    Yes         Yes         OUTPUT    
mshr_cache_mem_o.req_addr[15:0]      Yes    Yes         Yes         OUTPUT    
mshr_cache_mem_o.req_addr[31:16]     No     No          No          OUTPUT    
mshr_cache_mem_o.req_cmd[2:0]        Yes    Yes         Yes         OUTPUT    
memory_grant_i                       Yes    Yes         Yes         INPUT     
mem2cache_i.tag[3:0]                 Yes    Yes         Yes         INPUT     
mem2cache_i.data[63:0]               Yes    Yes         Yes         INPUT     
mem2cache_i.response[3:0]            Yes    Yes         Yes         INPUT     
mshr_memory_o.command[1:0]           Yes    Yes         Yes         OUTPUT    
mshr_memory_o.size[1:0]              No     No          No          OUTPUT    
mshr_memory_o.data[63:0]             Yes    Yes         Yes         OUTPUT    
mshr_memory_o.addr[2:0]              No     No          No          OUTPUT    
mshr_memory_o.addr[15:3]             Yes    Yes         Yes         OUTPUT    
mshr_memory_o.addr[31:16]            No     No          No          OUTPUT    
mshr_hit_i                           Yes    Yes         Yes         INPUT     
mshr_hit_idx_i[3:0]                  Yes    Yes         Yes         INPUT     
evict_hit_i                          No     No          No          INPUT     
evict_hit_idx_i[3:0]                 No     No          No          INPUT     
dp_sel_i                             Yes    Yes         Yes         INPUT     
mshr_cp_flag_o                       Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[63:0]                 Yes    Yes         Yes         OUTPUT    
cp_flag_i[0]                         No     No          No          INPUT     
cp_flag_i[15:1]                      Yes    Yes         Yes         INPUT     
cp_data_i[8:1][63:0]                 Yes    Yes         Yes         INPUT     
cp_data_i[9][44:0]                   Yes    Yes         Yes         INPUT     
cp_data_i[9][63:46]                  Yes    Yes         Yes         INPUT     
cp_data_i[10][30:1]                  Yes    Yes         Yes         INPUT     
cp_data_i[10][36:32]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][41:40]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][45]                    Yes    Yes         Yes         INPUT     
cp_data_i[10][49:47]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][52:51]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][56:55]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][60]                    Yes    Yes         Yes         INPUT     
cp_data_i[10][62]                    Yes    Yes         Yes         INPUT     
cp_data_i[11][27:0]                  Yes    Yes         Yes         INPUT     
cp_data_i[11][36:29]                 Yes    Yes         Yes         INPUT     
cp_data_i[11][49:39]                 Yes    Yes         Yes         INPUT     
cp_data_i[11][51]                    Yes    Yes         Yes         INPUT     
cp_data_i[11][59:54]                 Yes    Yes         Yes         INPUT     
cp_data_i[11][63:62]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][4:0]                   Yes    Yes         Yes         INPUT     
cp_data_i[12][27:6]                  Yes    Yes         Yes         INPUT     
cp_data_i[12][31:29]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][35:33]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][39]                    Yes    Yes         Yes         INPUT     
cp_data_i[12][44:43]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][48:46]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][50]                    Yes    Yes         Yes         INPUT     
cp_data_i[12][54]                    Yes    Yes         Yes         INPUT     
cp_data_i[12][58:57]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][61]                    Yes    Yes         Yes         INPUT     
cp_data_i[13][17:0]                  Yes    Yes         Yes         INPUT     
cp_data_i[13][46:19]                 Yes    Yes         Yes         INPUT     
cp_data_i[13][49]                    Yes    Yes         Yes         INPUT     
cp_data_i[13][56:51]                 Yes    Yes         Yes         INPUT     
cp_data_i[13][63:58]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][14:1]                  Yes    Yes         Yes         INPUT     
cp_data_i[14][19:16]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][21]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][24:23]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][27]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][32:30]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][37:35]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][39]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][41]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][43]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][46:45]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][51:49]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][59:53]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][62:61]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][15:0]                  Yes    Yes         Yes         INPUT     
cp_data_i[15][37:17]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][40:39]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][42]                    Yes    Yes         Yes         INPUT     
cp_data_i[15][45:44]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][48:47]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][53:51]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][55]                    Yes    Yes         Yes         INPUT     
cp_data_i[15][63:57]                 Yes    Yes         Yes         INPUT     
Other bits of cp_data_i[15:0][63:0]  No     No          No          INPUT     

Signal Details
                                  Toggle Toggle 1->0 Toggle 0->1 
mshr_entry.mem_tag[3:0]           Yes    Yes         Yes         
mshr_entry.linked                 No     No          No          
mshr_entry.link_idx[3:0]          No     No          No          
mshr_entry.evict_dirty            Yes    Yes         Yes         
mshr_entry.evict_data[63:0]       Yes    Yes         Yes         
mshr_entry.evict_addr[2:0]        No     No          No          
mshr_entry.evict_addr[15:3]       Yes    Yes         Yes         
mshr_entry.evict_addr[31:16]      No     No          No          
mshr_entry.req_size[1:0]          Yes    Yes         Yes         
mshr_entry.req_data[63:0]         Yes    Yes         Yes         
mshr_entry.req_addr[15:0]         Yes    Yes         Yes         
mshr_entry.req_addr[31:16]        No     No          No          
mshr_entry.cmd[1:0]               Yes    Yes         Yes         
mshr_entry.state[2:0]             Yes    Yes         Yes         
next_mshr_entry.mem_tag[3:0]      Yes    Yes         Yes         
next_mshr_entry.linked            Yes    Yes         Yes         
next_mshr_entry.link_idx[3:0]     Yes    Yes         Yes         
next_mshr_entry.evict_dirty       Yes    Yes         Yes         
next_mshr_entry.evict_data[63:0]  Yes    Yes         Yes         
next_mshr_entry.evict_addr[2:0]   No     No          No          
next_mshr_entry.evict_addr[15:3]  Yes    Yes         Yes         
next_mshr_entry.evict_addr[31:16] No     No          No          
next_mshr_entry.req_size[1:0]     Yes    Yes         Yes         
next_mshr_entry.req_data[63:0]    Yes    Yes         Yes         
next_mshr_entry.req_addr[15:0]    Yes    Yes         Yes         
next_mshr_entry.req_addr[31:16]   No     No          No          
next_mshr_entry.cmd[1:0]          Yes    Yes         Yes         
next_mshr_entry.state[2:0]        Yes    Yes         Yes         
next_mshr_cp_flag                 Yes    Yes         Yes         
next_mshr_cp_data[63:0]           Yes    Yes         Yes         


-------------------------------------------------------------------------------
===============================================================================
Module Instance : cache_tb.dut.cache_ctrl_inst.genblk1[7].mshr_entry_ctrl_inst
===============================================================================

Instance :

SCORE  LINE   TOGGLE 
 84.68  87.14  82.23 


Instance's subtree :

SCORE  LINE   TOGGLE 
 84.68  87.14  82.23 


Module : 

SCORE  LINE   TOGGLE NAME            
 87.59  90.48  84.70 mshr_entry_ctrl 


Parent : 

SCORE  LINE   TOGGLE NAME            
 92.38 100.00  84.76 cache_ctrl_inst 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : cache_tb.dut.cache_ctrl_inst.genblk1[7].mshr_entry_ctrl_inst

             Line No.   Total   Covered  Percent
TOTAL                      210      183    87.14
ALWAYS             75       17       17   100.00
ALWAYS             97      135      113    83.70
ALWAYS            317       25       20    80.00
ALWAYS            368       22       22   100.00
ALWAYS            411       11       11   100.00

74                          always_ff @(posedge clk_i) begin
75         1/1                  if (rst_i) begin
76         1/1                      mshr_entry.state        <=  `SD ST_IDLE     ;
77         1/1                      mshr_entry.cmd          <=  `SD BUS_NONE    ;
78         1/1                      mshr_entry.req_addr     <=  `SD 'b0         ;
79         1/1                      mshr_entry.req_data     <=  `SD 'b0         ;
80         1/1                      mshr_entry.req_size     <=  `SD BYTE        ;
81         1/1                      mshr_entry.evict_addr   <=  `SD 'b0         ;
82         1/1                      mshr_entry.evict_data   <=  `SD 'b0         ;
83         1/1                      mshr_entry.evict_dirty  <=  `SD 1'b0        ;
84         1/1                      mshr_entry.link_idx     <=  `SD 'd0         ;
85         1/1                      mshr_entry.linked       <=  `SD 1'b0        ;
86         1/1                      mshr_entry.mem_tag      <=  `SD 'd0         ;
87         1/1                      mshr_cp_flag_o          <=  `SD 1'b0        ;
88         1/1                      mshr_cp_data_o          <=  `SD 'b0         ;
89                              end else begin
90         1/1                      mshr_entry              <=  `SD next_mshr_entry     ;
91         1/1                      mshr_cp_flag_o          <=  `SD next_mshr_cp_flag   ;
92         1/1                      mshr_cp_data_o          <=  `SD next_mshr_cp_data   ;
93                              end
94                          end
95                      
96                          always_comb begin
97         1/1                  next_mshr_entry.state       =   mshr_entry.state        ;
98         1/1                  next_mshr_entry.cmd         =   mshr_entry.cmd          ;
99         1/1                  next_mshr_entry.req_addr    =   mshr_entry.req_addr     ;
100        1/1                  next_mshr_entry.req_data    =   mshr_entry.req_data     ;
101        1/1                  next_mshr_entry.req_size    =   mshr_entry.req_size     ;
102        1/1                  next_mshr_entry.evict_addr  =   mshr_entry.evict_addr   ;
103        1/1                  next_mshr_entry.evict_data  =   mshr_entry.evict_data   ;
104        1/1                  next_mshr_entry.evict_dirty =   mshr_entry.evict_dirty  ;
105        1/1                  next_mshr_entry.link_idx    =   mshr_entry.link_idx     ;
106        1/1                  next_mshr_entry.linked      =   mshr_entry.linked       ;
107        1/1                  next_mshr_entry.mem_tag     =   mshr_entry.mem_tag      ;
108        1/1                  next_mshr_cp_flag           =   mshr_cp_flag_o          ;
109        1/1                  next_mshr_cp_data           =   mshr_cp_data_o          ;
110        1/1                  case (mshr_entry.state)
111                                 ST_IDLE     :   begin
112                                     // IF   there is a valid transaction on Processor Interface
113                                     // AND  the Processor Interface is granted to this entry
114                                     // AND  the cache_mem Interface is granted to this entry
115                                     // AND  it is a miss
116                                     // AND  the entry is selected to hold the new miss
117        1/1                          if ((proc2cache_i.command != BUS_NONE) && (dp_sel_i == 1'b1)
118                                     && (proc_grant_i == 1'b1)) begin
119                                         // IF   there is an older in-flight transaction to the same addreess
120                                         // ->   Wait for the completion of older miss to the same address
121        1/1                              if (mshr_hit_i && (cp_flag_i[mshr_hit_idx_i] == 1'b0)) begin
122        1/1                                  next_mshr_entry.state       =   ST_WAIT_DEPEND          ;
123        1/1                                  next_mshr_entry.link_idx    =   mshr_hit_idx_i          ;
124        1/1                                  next_mshr_entry.cmd         =   proc2cache_i.command    ;
125        1/1                                  next_mshr_entry.req_addr    =   proc2cache_i.addr       ;
126        1/1                                  next_mshr_entry.req_size    =   proc2cache_i.size       ;
127        1/1                                  if (proc2cache_i.command == BUS_STORE) begin
128        1/1                                      next_mshr_entry.req_data    =   proc2cache_i.data   ;
129                                             end
                        MISSING_ELSE
130                                         // IF   there is an older in-flight transaction that is in the middle of evicting the data block
131                                         // ->   Wait for the completion of write-back to memory
132        1/1                              end else if (evict_hit_i && (cp_flag_i[evict_hit_idx_i] == 1'b0)) begin
133        0/1     ==>                          next_mshr_entry.state       =   ST_WAIT_EVICT           ;
134        0/1     ==>                          next_mshr_entry.link_idx    =   evict_hit_idx_i         ;
135        0/1     ==>                          next_mshr_entry.cmd         =   proc2cache_i.command    ;
136        0/1     ==>                          next_mshr_entry.req_addr    =   proc2cache_i.addr       ;
137        0/1     ==>                          next_mshr_entry.req_size    =   proc2cache_i.size       ;
138        0/1     ==>                          if (proc2cache_i.command == BUS_STORE) begin
139        0/1     ==>                              next_mshr_entry.req_data    =   proc2cache_i.data   ;
140                                             end
                   ==>  MISSING_ELSE
141                                         // IF   it is a miss, and no dependency to older in-flight transactions.
142                                         // ->   Start miss handling
143        1/1                              end else if ((cache_mem_ctrl_i.req_hit == 1'b0) && (cache_mem_grant_i == 1'b1)) begin
144        1/1                                  next_mshr_entry.state       =   ST_RD_MEM               ;
145        1/1                                  next_mshr_entry.link_idx    =   'd0                     ;
146        1/1                                  next_mshr_entry.cmd         =   proc2cache_i.command    ;
147        1/1                                  next_mshr_entry.req_addr    =   proc2cache_i.addr       ;
148        1/1                                  next_mshr_entry.req_size    =   proc2cache_i.size       ;
149        1/1                                  if (proc2cache_i.command == BUS_STORE) begin
150        1/1                                      next_mshr_entry.req_data    =   proc2cache_i.data   ;
151                                             end
                        MISSING_ELSE
152                                         end
                        MISSING_ELSE
153                                     end
                        MISSING_ELSE
154        1/1                          next_mshr_cp_flag   =   1'b0    ;
155        1/1                          next_mshr_cp_data   =   'b0     ;
156                                 end
157                                 ST_WAIT_DEPEND  :   begin
158                                     // IF   the older transaction that the entry is linked to completed
159                                     // ->   Update the cache data
160        0/1     ==>                  if (cp_flag_i[mshr_entry.link_idx] == 1'b1) begin
161        0/1     ==>                      next_mshr_entry.state       =   ST_UPDATE   ;
162        0/1     ==>                      next_mshr_entry.link_idx    =   'd0         ;
163        0/1     ==>                      next_mshr_entry.req_data    =   cp_data_i[mshr_entry.link_idx];
164        0/1     ==>                      if (mshr_entry.cmd == BUS_STORE) begin
165        0/1     ==>                          case (mshr_entry.req_size)
166        0/1     ==>                              BYTE    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +:  8]    =   mshr_entry.req_data[ 7:0]   ;
167        0/1     ==>                              HALF    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +: 16]    =   mshr_entry.req_data[15:0]   ;
168        0/1     ==>                              WORD    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +: 32]    =   mshr_entry.req_data[31:0]   ;
169        0/1     ==>                              DOUBLE  :   next_mshr_entry.req_data                                    =   mshr_entry.req_data         ;
170        0/1     ==>                              default :   next_mshr_entry.req_data                                    =   mshr_entry.req_data         ;
171                                             endcase
172                                         end
                   ==>  MISSING_ELSE
173                                     end
                   ==>  MISSING_ELSE
174                                 end
175                                 ST_WAIT_EVICT   : begin
176                                     // IF   the older transaction that evicts the cache block completed
177                                     // ->   Read from Memory
178        0/1     ==>                  if (cp_flag_i[mshr_entry.link_idx] == 1'b1) begin
179        0/1     ==>                      next_mshr_entry.state       =   ST_RD_MEM   ;
180        0/1     ==>                      next_mshr_entry.link_idx    =   'd0         ;
181                                     end
                   ==>  MISSING_ELSE
182                                 end
183                                 ST_RD_MEM   :   begin
184                                     // IF   the read transaction is confirmed by Memory Interface
185                                     // ->   Wait for the data to return from Memory
186        1/1                          if ((memory_grant_i == 1'b1) && (mem2cache_i.response != 'd0)) begin
187        1/1                              next_mshr_entry.state       =   ST_WAIT_MEM             ;
188        1/1                              next_mshr_entry.mem_tag     =   mem2cache_i.response    ;
189                                     end
                        MISSING_ELSE
190                                 end
191                                 ST_WAIT_MEM :   begin
192                                     // IF   the data is returned from the Memory
193                                     // ->   Update the cache data
194        1/1                          if (mem2cache_i.tag == mshr_entry.mem_tag) begin
195        1/1                              next_mshr_entry.state       =   ST_UPDATE           ;
196        1/1                              next_mshr_entry.req_data    =   mem2cache_i.data    ;
197        1/1                              if (mshr_entry.cmd == BUS_STORE) begin
198        1/1                                  case (mshr_entry.req_size)
199        1/1                                      BYTE    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +:  8]    =   mshr_entry.req_data[ 7:0]   ;
200        1/1                                      HALF    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +: 16]    =   mshr_entry.req_data[15:0]   ;
201        1/1                                      WORD    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +: 32]    =   mshr_entry.req_data[31:0]   ;
202        1/1                                      DOUBLE  :   next_mshr_entry.req_data                                    =   mshr_entry.req_data         ;
203        0/1     ==>                              default :   next_mshr_entry.req_data                                    =   mshr_entry.req_data         ;
204                                             endcase
205                                         end
                        MISSING_ELSE
206                                     end
                        MISSING_ELSE
207                                 end
208                                 ST_UPDATE   :   begin
209                                     // IF   the req interface is granted to this entry
210        1/1                          if (cache_mem_grant_i == 1'b1) begin
211                                         // IF   it is a load miss
212                                         // ->   Output data to processor
213        1/1                              if (mshr_entry.cmd == BUS_LOAD) begin
214        1/1                                  next_mshr_entry.state       =   ST_OUTPUT;
215        1/1                                  next_mshr_entry.evict_addr  =   cache_mem_ctrl_i.evict_addr ;
216        1/1                                  next_mshr_entry.evict_data  =   cache_mem_ctrl_i.evict_data ;
217        1/1                                  next_mshr_entry.evict_dirty =   cache_mem_ctrl_i.evict_dirty;
218                                         // IF   a dirty block is evicted
219                                         // ->   Write back the evicted block
220        1/1                              end else if (cache_mem_ctrl_i.evict_dirty == 1'b1) begin
221        1/1                                  next_mshr_entry.state       =   ST_EVICT;
222        1/1                                  next_mshr_entry.evict_addr  =   cache_mem_ctrl_i.evict_addr ;
223        1/1                                  next_mshr_entry.evict_data  =   cache_mem_ctrl_i.evict_data ;
224        1/1                                  next_mshr_entry.evict_dirty =   cache_mem_ctrl_i.evict_dirty;
225                                         // ELSE
226                                         // ->   Miss Handling Completed
227                                         end else begin
228        1/1                                  next_mshr_entry.state       =   ST_IDLE             ;
229        1/1                                  next_mshr_entry.cmd         =   BUS_NONE            ;
230        1/1                                  next_mshr_entry.req_addr    =   'b0                 ;
231        1/1                                  next_mshr_entry.req_data    =   'b0                 ;
232        1/1                                  next_mshr_entry.req_size    =   BYTE                ;
233        1/1                                  next_mshr_entry.evict_addr  =   'b0                 ;
234        1/1                                  next_mshr_entry.evict_data  =   'b0                 ;
235        1/1                                  next_mshr_entry.evict_dirty =   1'b0                ;
236        1/1                                  next_mshr_entry.link_idx    =   'd0                 ;
237        1/1                                  next_mshr_entry.mem_tag     =   'd0                 ;
238        1/1                                  next_mshr_cp_flag           =   1'b1                ;
239        1/1                                  next_mshr_cp_data           =   mshr_entry.req_data ;
240                                         end
241                                     end
                        MISSING_ELSE
242                                 end
243                                 ST_OUTPUT   :   begin
244                                     // IF   the Processor Interface is granted to this entry
245        1/1                          if (proc_grant_i == 1'b1) begin
246                                         // IF   the evicted block is dirty
247                                         // ->   Write back the evicted block
248        1/1                              if (mshr_entry.evict_dirty == 1'b1) begin
249        1/1                                  next_mshr_entry.state       =   ST_EVICT;
250                                         // ELSE
251                                         // ->   Miss Handling Completed
252                                         end else begin
253        1/1                                  next_mshr_entry.state       =   ST_IDLE             ;
254        1/1                                  next_mshr_entry.cmd         =   BUS_NONE            ;
255        1/1                                  next_mshr_entry.req_addr    =   'b0                 ;
256        1/1                                  next_mshr_entry.req_data    =   'b0                 ;
257        1/1                                  next_mshr_entry.req_size    =   BYTE                ;
258        1/1                                  next_mshr_entry.evict_addr  =   'b0                 ;
259        1/1                                  next_mshr_entry.evict_data  =   'b0                 ;
260        1/1                                  next_mshr_entry.evict_dirty =   1'b0                ;
261        1/1                                  next_mshr_entry.link_idx    =   'd0                 ;
262        1/1                                  next_mshr_entry.mem_tag     =   'd0                 ;
263        1/1                                  next_mshr_cp_flag           =   1'b1                ;
264        1/1                                  next_mshr_cp_data           =   mshr_entry.req_data ;
265                                         end
266                                     end
                        MISSING_ELSE
267                                 end
268                                 ST_EVICT    :   begin
269                                     // IF   the write back transaction to Memory is confirmed
270                                     // ->   Miss Handling Completed
271        1/1                          if ((memory_grant_i == 1'b1) && (mem2cache_i.response != 'd0)) begin
272        1/1                              next_mshr_entry.state       =   ST_IDLE             ;
273        1/1                              next_mshr_entry.cmd         =   BUS_NONE            ;
274        1/1                              next_mshr_entry.req_addr    =   'b0                 ;
275        1/1                              next_mshr_entry.req_data    =   'b0                 ;
276        1/1                              next_mshr_entry.req_size    =   BYTE                ;
277        1/1                              next_mshr_entry.evict_addr  =   'b0                 ;
278        1/1                              next_mshr_entry.evict_data  =   'b0                 ;
279        1/1                              next_mshr_entry.evict_dirty =   1'b0                ;
280        1/1                              next_mshr_entry.link_idx    =   'd0                 ;
281        1/1                              next_mshr_entry.mem_tag     =   'd0                 ;
282        1/1                              next_mshr_cp_flag           =   1'b1                ;
283        1/1                              next_mshr_cp_data           =   mshr_entry.req_data ;
284                                     end
                        MISSING_ELSE
285                                 end
286                                 default     :   begin
287        1/1                          next_mshr_entry.state       =   ST_IDLE     ;
288        1/1                          next_mshr_entry.cmd         =   BUS_NONE    ;
289        1/1                          next_mshr_entry.req_addr    =   'b0         ;
290        1/1                          next_mshr_entry.req_data    =   'b0         ;
291        1/1                          next_mshr_entry.req_size    =   BYTE        ;
292        1/1                          next_mshr_entry.evict_addr  =   'b0         ;
293        1/1                          next_mshr_entry.evict_data  =   'b0         ;
294        1/1                          next_mshr_entry.evict_dirty =   1'b0        ;
295        1/1                          next_mshr_entry.link_idx    =   'd0         ;
296        1/1                          next_mshr_entry.mem_tag     =   'd0         ;
297        1/1                          next_mshr_cp_flag           =   1'b0        ;
298        1/1                          next_mshr_cp_data           =   'd0         ;
299                                 end
300                             endcase
301                     
302        1/1                  if (next_mshr_entry.state == ST_IDLE) begin
303        1/1                      next_mshr_entry.linked  =   1'b0;
304        1/1                  end else if ((mshr_hit_i == 1'b1) && (mshr_hit_idx_i == mshr_entry_idx_i)) begin
305        1/1                      next_mshr_entry.linked  =   1'b1;
306                             end
                        MISSING_ELSE
307                         end
308                     
309                     // --------------------------------------------------------------------
310                     // MSHR entry output
311                     // --------------------------------------------------------------------
312                         assign  mshr_entry_o    =   mshr_entry  ;
313                     // --------------------------------------------------------------------
314                     // Processor Interface
315                     // --------------------------------------------------------------------
316                         always_comb begin
317        1/1                  mshr_proc_o.response    =   'd0 ;
318        1/1                  mshr_proc_o.data        =   'b0 ;
319        1/1                  mshr_proc_o.tag         =   'd0 ;
320        1/1                  case (mshr_entry.state)
321                                 ST_IDLE     :   begin
322                                     // IF   the processor request is allocated to this entry
323        1/1                          if ((proc2cache_i.command != BUS_NONE) && (dp_sel_i == 1'b1)) begin
324                                         // IF   The Processor Interface is granted to this entry
325                                         // AND  there is a dependency to older in-flight transaction
326                                         // ->   Confirm the request
327        1/1                              if (((mshr_hit_i && (cp_flag_i[mshr_hit_idx_i] == 1'b0))
328                                         || (evict_hit_i && (cp_flag_i[evict_hit_idx_i] == 1'b0)))) begin
329        1/1                                  mshr_proc_o.response    =   mshr_entry_idx_i;
330                                         // IF   The Processor Interface is granted to this entry
331                                         // AND  The cache_mem Interface is granted to this entry
332                                         // ->   Confirm the request 
333        1/1                              end else if (cache_mem_grant_i == 1'b1) begin
334        1/1                                  mshr_proc_o.response    =   mshr_entry_idx_i;
335                                             // IF   it is a load hit
336                                             // ->   Output data and tag
337        1/1                                  if (cache_mem_ctrl_i.req_hit == 1'b1 && proc2cache_i.command == BUS_LOAD) begin
338        1/1                                      mshr_proc_o.tag     =   mshr_entry_idx_i;
339        1/1                                      case (proc2cache_i.size)
340        0/1     ==>                                  BYTE    :   mshr_proc_o.data    =   {56'b0,cache_mem_ctrl_i.req_data_out[proc2cache_i.addr[2:0]+: 8]};
341        0/1     ==>                                  HALF    :   mshr_proc_o.data    =   {48'b0,cache_mem_ctrl_i.req_data_out[proc2cache_i.addr[2:0]+:16]};
342        1/1                                          WORD    :   mshr_proc_o.data    =   {32'b0,cache_mem_ctrl_i.req_data_out[proc2cache_i.addr[2:0]+:32]};
343        0/1     ==>                                  DOUBLE  :   mshr_proc_o.data    =   cache_mem_ctrl_i.req_data_out;
344        0/1     ==>                                  default :   mshr_proc_o.data    =   cache_mem_ctrl_i.req_data_out;
345                                                 endcase
346                                             end
                        MISSING_ELSE
347                                         end
                        MISSING_ELSE
348                                     end
                        MISSING_ELSE
349                                 end
350                                 ST_OUTPUT   :   begin
351        1/1                          mshr_proc_o.response    =   'd0                 ;
352        1/1                          mshr_proc_o.tag         =   mshr_entry_idx_i    ;
353        1/1                          case (mshr_entry.req_size)
354        1/1                              BYTE    :   mshr_proc_o.data    =   {56'b0,mshr_entry.req_data[mshr_entry.req_addr[2:0]+: 8]};
355        1/1                              HALF    :   mshr_proc_o.data    =   {48'b0,mshr_entry.req_data[mshr_entry.req_addr[2:0]+:16]};
356        1/1                              WORD    :   mshr_proc_o.data    =   {32'b0,mshr_entry.req_data[mshr_entry.req_addr[2:0]+:32]};
357        1/1                              DOUBLE  :   mshr_proc_o.data    =   mshr_entry.req_data;
358        0/1     ==>                      default :   mshr_proc_o.data    =   mshr_entry.req_data;
359                                     endcase
360                                 end
                        MISSING_DEFAULT
361                             endcase
362                         end
363                     
364                     // --------------------------------------------------------------------
365                     // cache_mem Interface
366                     // --------------------------------------------------------------------
367                         always_comb begin
368        1/1                  mshr_cache_mem_o.req_cmd        =   REQ_NONE;
369        1/1                  mshr_cache_mem_o.req_addr       =   'b0     ;
370        1/1                  mshr_cache_mem_o.req_data_in    =   'b0     ;
371        1/1                  case (mshr_entry.state)
372                                 ST_IDLE:    begin
373                                     // IF   the processor request is allocated to this entry
374        1/1                          if (dp_sel_i == 1'b1) begin
375        1/1                              case (proc2cache_i.command)
376                                             BUS_LOAD    :   begin
377        1/1                                      mshr_cache_mem_o.req_cmd        =   REQ_LOAD                        ;
378        1/1                                      mshr_cache_mem_o.req_addr       =   proc2cache_i.addr               ;
379        1/1                                      mshr_cache_mem_o.req_data_in    =   cache_mem_ctrl_i.req_data_out   ;
380                                             end
381                                             BUS_STORE   :   begin
382        1/1                                      mshr_cache_mem_o.req_cmd        =   REQ_STORE                       ;
383        1/1                                      mshr_cache_mem_o.req_addr       =   proc2cache_i.addr               ;
384        1/1                                      mshr_cache_mem_o.req_data_in    =   cache_mem_ctrl_i.req_data_out   ;
385        1/1                                      case (proc2cache_i.size)
386        1/1                                          BYTE    :   mshr_cache_mem_o.req_data_in[proc2cache_i.addr[2:0] +:  8]  =   proc2cache_i.data[ 7:0] ;
387        1/1                                          HALF    :   mshr_cache_mem_o.req_data_in[proc2cache_i.addr[2:0] +: 16]  =   proc2cache_i.data[15:0] ;
388        1/1                                          WORD    :   mshr_cache_mem_o.req_data_in[proc2cache_i.addr[2:0] +: 32]  =   proc2cache_i.data[31:0] ;
389        1/1                                          DOUBLE  :   mshr_cache_mem_o.req_data_in                                =   proc2cache_i.data       ;
                   ==>  MISSING_DEFAULT
390                                                 endcase
391                                             end    
                        MISSING_DEFAULT
392                                         endcase
393                                     end
                        MISSING_ELSE
394                                 end
395                                 ST_UPDATE:  begin
396        1/1                          if (mshr_entry.cmd == BUS_LOAD) begin
397        1/1                              mshr_cache_mem_o.req_cmd    =   REQ_LOAD_MISS       ;
398                                     end else begin
399        1/1                              mshr_cache_mem_o.req_cmd    =   REQ_STORE_MISS      ;
400                                     end
401        1/1                          mshr_cache_mem_o.req_addr       =   mshr_entry.req_addr ;
402        1/1                          mshr_cache_mem_o.req_data_in    =   mshr_entry.req_data ;
403                                 end
                        MISSING_DEFAULT
404                             endcase
405                         end
406                     
407                     // --------------------------------------------------------------------
408                     // Memory Interface
409                     // --------------------------------------------------------------------
410                         always_comb begin
411        1/1                  mshr_memory_o.addr      =   {mshr_entry.req_addr[C_XLEN-1:C_CACHE_OFFSET_WIDTH], {C_CACHE_OFFSET_WIDTH{1'b0}}};
412        1/1                  mshr_memory_o.size      =   DOUBLE              ;
413        1/1                  mshr_memory_o.command   =   BUS_NONE            ;
414        1/1                  mshr_memory_o.data      =   'd0 ;
415        1/1                  case (mshr_entry.state)
416                                 ST_RD_MEM   :   begin
417        1/1                          mshr_memory_o.data      =   'd0 ;
418        1/1                          mshr_memory_o.addr      =   {mshr_entry.req_addr[C_XLEN-1:C_CACHE_OFFSET_WIDTH], {C_CACHE_OFFSET_WIDTH{1'b0}}};
419        1/1                          mshr_memory_o.command   =   BUS_LOAD;
420                                 end
421                                 ST_EVICT    :   begin
422        1/1                          mshr_memory_o.data      =   mshr_entry.evict_data;
423        1/1                          mshr_memory_o.addr      =   {mshr_entry.evict_addr[C_XLEN-1:C_CACHE_OFFSET_WIDTH], {C_CACHE_OFFSET_WIDTH{1'b0}}};
424        1/1                          mshr_memory_o.command   =   BUS_STORE;
425                                 end
                        MISSING_DEFAULT

-------------------------------------------------------------------------------
Toggle Coverage for Instance : cache_tb.dut.cache_ctrl_inst.genblk1[7].mshr_entry_ctrl_inst
                Total Covered Percent 
Totals          72    49      68.06   
Total Bits      4844  3983    82.23   
Total Bits 0->1 2422  1991    82.20   
Total Bits 1->0 2422  1992    82.25   

                                
Ports          48   30   62.50  
Port Bits      3878 3165 81.61  
Port Bits 0->1 1939 1582 81.59  
Port Bits 1->0 1939 1583 81.64  

                                
Signals          24  19  79.17  
Signal Bits      966 818 84.68  
Signal Bits 0->1 483 409 84.68  
Signal Bits 1->0 483 409 84.68  

Port Details
                                     Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i                                Yes    Yes         Yes         INPUT     
rst_i                                No     Yes         No          INPUT     
mshr_entry_idx_i[3:0]                No     No          No          INPUT     
mshr_entry_o.mem_tag[3:0]            Yes    Yes         Yes         OUTPUT    
mshr_entry_o.linked                  Yes    Yes         Yes         OUTPUT    
mshr_entry_o.link_idx[3:0]           No     No          No          OUTPUT    
mshr_entry_o.evict_dirty             Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_data[63:0]        Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_addr[2:0]         No     No          No          OUTPUT    
mshr_entry_o.evict_addr[15:3]        Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_addr[31:16]       No     No          No          OUTPUT    
mshr_entry_o.req_size[1:0]           Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_data[63:0]          Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_addr[15:0]          Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_addr[31:16]         No     No          No          OUTPUT    
mshr_entry_o.cmd[1:0]                Yes    Yes         Yes         OUTPUT    
mshr_entry_o.state[2:0]              Yes    Yes         Yes         OUTPUT    
proc_grant_i                         Yes    Yes         Yes         INPUT     
proc2cache_i.command[1:0]            Yes    Yes         Yes         INPUT     
proc2cache_i.size[1:0]               Yes    Yes         Yes         INPUT     
proc2cache_i.data[63:0]              Yes    Yes         Yes         INPUT     
proc2cache_i.addr[15:0]              Yes    Yes         Yes         INPUT     
proc2cache_i.addr[31:16]             No     No          No          INPUT     
mshr_proc_o.tag[2:0]                 Yes    Yes         Yes         OUTPUT    
mshr_proc_o.tag[3]                   No     No          No          OUTPUT    
mshr_proc_o.data[63:0]               No     No          No          OUTPUT    
mshr_proc_o.response[2:0]            Yes    Yes         Yes         OUTPUT    
mshr_proc_o.response[3]              No     No          No          OUTPUT    
cache_mem_grant_i                    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.evict_data[63:0]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.evict_addr[2:0]     No     No          No          INPUT     
cache_mem_ctrl_i.evict_addr[15:3]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.evict_addr[31:16]   No     No          No          INPUT     
cache_mem_ctrl_i.evict_dirty         Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[4:0]   Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[6:5]   No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[8:7]   Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[11:9]  No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[13:12] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[15:14] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[25:16] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[26]    No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[31:27] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[33:32] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[34]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[37:35] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[38]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[41:39] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[42]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[45:43] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[47:46] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[50:48] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[52:51] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[54:53] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[58:55] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[60:59] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[63:61] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_hit             Yes    Yes         Yes         INPUT     
mshr_cache_mem_o.req_data_in[63:0]   Yes    Yes         Yes         OUTPUT    
mshr_cache_mem_o.req_addr[15:0]      Yes    Yes         Yes         OUTPUT    
mshr_cache_mem_o.req_addr[31:16]     No     No          No          OUTPUT    
mshr_cache_mem_o.req_cmd[2:0]        Yes    Yes         Yes         OUTPUT    
memory_grant_i                       Yes    Yes         Yes         INPUT     
mem2cache_i.tag[3:0]                 Yes    Yes         Yes         INPUT     
mem2cache_i.data[63:0]               Yes    Yes         Yes         INPUT     
mem2cache_i.response[3:0]            Yes    Yes         Yes         INPUT     
mshr_memory_o.command[1:0]           Yes    Yes         Yes         OUTPUT    
mshr_memory_o.size[1:0]              No     No          No          OUTPUT    
mshr_memory_o.data[63:0]             Yes    Yes         Yes         OUTPUT    
mshr_memory_o.addr[2:0]              No     No          No          OUTPUT    
mshr_memory_o.addr[15:3]             Yes    Yes         Yes         OUTPUT    
mshr_memory_o.addr[31:16]            No     No          No          OUTPUT    
mshr_hit_i                           Yes    Yes         Yes         INPUT     
mshr_hit_idx_i[3:0]                  Yes    Yes         Yes         INPUT     
evict_hit_i                          No     No          No          INPUT     
evict_hit_idx_i[3:0]                 No     No          No          INPUT     
dp_sel_i                             Yes    Yes         Yes         INPUT     
mshr_cp_flag_o                       Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[63:0]                 Yes    Yes         Yes         OUTPUT    
cp_flag_i[0]                         No     No          No          INPUT     
cp_flag_i[15:1]                      Yes    Yes         Yes         INPUT     
cp_data_i[8:1][63:0]                 Yes    Yes         Yes         INPUT     
cp_data_i[9][44:0]                   Yes    Yes         Yes         INPUT     
cp_data_i[9][63:46]                  Yes    Yes         Yes         INPUT     
cp_data_i[10][30:1]                  Yes    Yes         Yes         INPUT     
cp_data_i[10][36:32]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][41:40]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][45]                    Yes    Yes         Yes         INPUT     
cp_data_i[10][49:47]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][52:51]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][56:55]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][60]                    Yes    Yes         Yes         INPUT     
cp_data_i[10][62]                    Yes    Yes         Yes         INPUT     
cp_data_i[11][27:0]                  Yes    Yes         Yes         INPUT     
cp_data_i[11][36:29]                 Yes    Yes         Yes         INPUT     
cp_data_i[11][49:39]                 Yes    Yes         Yes         INPUT     
cp_data_i[11][51]                    Yes    Yes         Yes         INPUT     
cp_data_i[11][59:54]                 Yes    Yes         Yes         INPUT     
cp_data_i[11][63:62]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][4:0]                   Yes    Yes         Yes         INPUT     
cp_data_i[12][27:6]                  Yes    Yes         Yes         INPUT     
cp_data_i[12][31:29]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][35:33]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][39]                    Yes    Yes         Yes         INPUT     
cp_data_i[12][44:43]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][48:46]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][50]                    Yes    Yes         Yes         INPUT     
cp_data_i[12][54]                    Yes    Yes         Yes         INPUT     
cp_data_i[12][58:57]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][61]                    Yes    Yes         Yes         INPUT     
cp_data_i[13][17:0]                  Yes    Yes         Yes         INPUT     
cp_data_i[13][46:19]                 Yes    Yes         Yes         INPUT     
cp_data_i[13][49]                    Yes    Yes         Yes         INPUT     
cp_data_i[13][56:51]                 Yes    Yes         Yes         INPUT     
cp_data_i[13][63:58]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][14:1]                  Yes    Yes         Yes         INPUT     
cp_data_i[14][19:16]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][21]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][24:23]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][27]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][32:30]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][37:35]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][39]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][41]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][43]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][46:45]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][51:49]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][59:53]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][62:61]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][15:0]                  Yes    Yes         Yes         INPUT     
cp_data_i[15][37:17]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][40:39]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][42]                    Yes    Yes         Yes         INPUT     
cp_data_i[15][45:44]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][48:47]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][53:51]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][55]                    Yes    Yes         Yes         INPUT     
cp_data_i[15][63:57]                 Yes    Yes         Yes         INPUT     
Other bits of cp_data_i[15:0][63:0]  No     No          No          INPUT     

Signal Details
                                  Toggle Toggle 1->0 Toggle 0->1 
mshr_entry.mem_tag[3:0]           Yes    Yes         Yes         
mshr_entry.linked                 Yes    Yes         Yes         
mshr_entry.link_idx[3:0]          No     No          No          
mshr_entry.evict_dirty            Yes    Yes         Yes         
mshr_entry.evict_data[63:0]       Yes    Yes         Yes         
mshr_entry.evict_addr[2:0]        No     No          No          
mshr_entry.evict_addr[15:3]       Yes    Yes         Yes         
mshr_entry.evict_addr[31:16]      No     No          No          
mshr_entry.req_size[1:0]          Yes    Yes         Yes         
mshr_entry.req_data[63:0]         Yes    Yes         Yes         
mshr_entry.req_addr[15:0]         Yes    Yes         Yes         
mshr_entry.req_addr[31:16]        No     No          No          
mshr_entry.cmd[1:0]               Yes    Yes         Yes         
mshr_entry.state[2:0]             Yes    Yes         Yes         
next_mshr_entry.mem_tag[3:0]      Yes    Yes         Yes         
next_mshr_entry.linked            Yes    Yes         Yes         
next_mshr_entry.link_idx[3:0]     Yes    Yes         Yes         
next_mshr_entry.evict_dirty       Yes    Yes         Yes         
next_mshr_entry.evict_data[63:0]  Yes    Yes         Yes         
next_mshr_entry.evict_addr[2:0]   No     No          No          
next_mshr_entry.evict_addr[15:3]  Yes    Yes         Yes         
next_mshr_entry.evict_addr[31:16] No     No          No          
next_mshr_entry.req_size[1:0]     Yes    Yes         Yes         
next_mshr_entry.req_data[63:0]    Yes    Yes         Yes         
next_mshr_entry.req_addr[15:0]    Yes    Yes         Yes         
next_mshr_entry.req_addr[31:16]   No     No          No          
next_mshr_entry.cmd[1:0]          Yes    Yes         Yes         
next_mshr_entry.state[2:0]        Yes    Yes         Yes         
next_mshr_cp_flag                 Yes    Yes         Yes         
next_mshr_cp_data[63:0]           Yes    Yes         Yes         


-------------------------------------------------------------------------------
===============================================================================
Module Instance : cache_tb.dut.cache_ctrl_inst.genblk1[6].mshr_entry_ctrl_inst
===============================================================================

Instance :

SCORE  LINE   TOGGLE 
 84.75  85.71  83.79 


Instance's subtree :

SCORE  LINE   TOGGLE 
 84.75  85.71  83.79 


Module : 

SCORE  LINE   TOGGLE NAME            
 87.59  90.48  84.70 mshr_entry_ctrl 


Parent : 

SCORE  LINE   TOGGLE NAME            
 92.38 100.00  84.76 cache_ctrl_inst 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : cache_tb.dut.cache_ctrl_inst.genblk1[6].mshr_entry_ctrl_inst

             Line No.   Total   Covered  Percent
TOTAL                      210      180    85.71
ALWAYS             75       17       17   100.00
ALWAYS             97      135      113    83.70
ALWAYS            317       25       17    68.00
ALWAYS            368       22       22   100.00
ALWAYS            411       11       11   100.00

74                          always_ff @(posedge clk_i) begin
75         1/1                  if (rst_i) begin
76         1/1                      mshr_entry.state        <=  `SD ST_IDLE     ;
77         1/1                      mshr_entry.cmd          <=  `SD BUS_NONE    ;
78         1/1                      mshr_entry.req_addr     <=  `SD 'b0         ;
79         1/1                      mshr_entry.req_data     <=  `SD 'b0         ;
80         1/1                      mshr_entry.req_size     <=  `SD BYTE        ;
81         1/1                      mshr_entry.evict_addr   <=  `SD 'b0         ;
82         1/1                      mshr_entry.evict_data   <=  `SD 'b0         ;
83         1/1                      mshr_entry.evict_dirty  <=  `SD 1'b0        ;
84         1/1                      mshr_entry.link_idx     <=  `SD 'd0         ;
85         1/1                      mshr_entry.linked       <=  `SD 1'b0        ;
86         1/1                      mshr_entry.mem_tag      <=  `SD 'd0         ;
87         1/1                      mshr_cp_flag_o          <=  `SD 1'b0        ;
88         1/1                      mshr_cp_data_o          <=  `SD 'b0         ;
89                              end else begin
90         1/1                      mshr_entry              <=  `SD next_mshr_entry     ;
91         1/1                      mshr_cp_flag_o          <=  `SD next_mshr_cp_flag   ;
92         1/1                      mshr_cp_data_o          <=  `SD next_mshr_cp_data   ;
93                              end
94                          end
95                      
96                          always_comb begin
97         1/1                  next_mshr_entry.state       =   mshr_entry.state        ;
98         1/1                  next_mshr_entry.cmd         =   mshr_entry.cmd          ;
99         1/1                  next_mshr_entry.req_addr    =   mshr_entry.req_addr     ;
100        1/1                  next_mshr_entry.req_data    =   mshr_entry.req_data     ;
101        1/1                  next_mshr_entry.req_size    =   mshr_entry.req_size     ;
102        1/1                  next_mshr_entry.evict_addr  =   mshr_entry.evict_addr   ;
103        1/1                  next_mshr_entry.evict_data  =   mshr_entry.evict_data   ;
104        1/1                  next_mshr_entry.evict_dirty =   mshr_entry.evict_dirty  ;
105        1/1                  next_mshr_entry.link_idx    =   mshr_entry.link_idx     ;
106        1/1                  next_mshr_entry.linked      =   mshr_entry.linked       ;
107        1/1                  next_mshr_entry.mem_tag     =   mshr_entry.mem_tag      ;
108        1/1                  next_mshr_cp_flag           =   mshr_cp_flag_o          ;
109        1/1                  next_mshr_cp_data           =   mshr_cp_data_o          ;
110        1/1                  case (mshr_entry.state)
111                                 ST_IDLE     :   begin
112                                     // IF   there is a valid transaction on Processor Interface
113                                     // AND  the Processor Interface is granted to this entry
114                                     // AND  the cache_mem Interface is granted to this entry
115                                     // AND  it is a miss
116                                     // AND  the entry is selected to hold the new miss
117        1/1                          if ((proc2cache_i.command != BUS_NONE) && (dp_sel_i == 1'b1)
118                                     && (proc_grant_i == 1'b1)) begin
119                                         // IF   there is an older in-flight transaction to the same addreess
120                                         // ->   Wait for the completion of older miss to the same address
121        1/1                              if (mshr_hit_i && (cp_flag_i[mshr_hit_idx_i] == 1'b0)) begin
122        1/1                                  next_mshr_entry.state       =   ST_WAIT_DEPEND          ;
123        1/1                                  next_mshr_entry.link_idx    =   mshr_hit_idx_i          ;
124        1/1                                  next_mshr_entry.cmd         =   proc2cache_i.command    ;
125        1/1                                  next_mshr_entry.req_addr    =   proc2cache_i.addr       ;
126        1/1                                  next_mshr_entry.req_size    =   proc2cache_i.size       ;
127        1/1                                  if (proc2cache_i.command == BUS_STORE) begin
128        1/1                                      next_mshr_entry.req_data    =   proc2cache_i.data   ;
129                                             end
                        MISSING_ELSE
130                                         // IF   there is an older in-flight transaction that is in the middle of evicting the data block
131                                         // ->   Wait for the completion of write-back to memory
132        1/1                              end else if (evict_hit_i && (cp_flag_i[evict_hit_idx_i] == 1'b0)) begin
133        0/1     ==>                          next_mshr_entry.state       =   ST_WAIT_EVICT           ;
134        0/1     ==>                          next_mshr_entry.link_idx    =   evict_hit_idx_i         ;
135        0/1     ==>                          next_mshr_entry.cmd         =   proc2cache_i.command    ;
136        0/1     ==>                          next_mshr_entry.req_addr    =   proc2cache_i.addr       ;
137        0/1     ==>                          next_mshr_entry.req_size    =   proc2cache_i.size       ;
138        0/1     ==>                          if (proc2cache_i.command == BUS_STORE) begin
139        0/1     ==>                              next_mshr_entry.req_data    =   proc2cache_i.data   ;
140                                             end
                   ==>  MISSING_ELSE
141                                         // IF   it is a miss, and no dependency to older in-flight transactions.
142                                         // ->   Start miss handling
143        1/1                              end else if ((cache_mem_ctrl_i.req_hit == 1'b0) && (cache_mem_grant_i == 1'b1)) begin
144        1/1                                  next_mshr_entry.state       =   ST_RD_MEM               ;
145        1/1                                  next_mshr_entry.link_idx    =   'd0                     ;
146        1/1                                  next_mshr_entry.cmd         =   proc2cache_i.command    ;
147        1/1                                  next_mshr_entry.req_addr    =   proc2cache_i.addr       ;
148        1/1                                  next_mshr_entry.req_size    =   proc2cache_i.size       ;
149        1/1                                  if (proc2cache_i.command == BUS_STORE) begin
150        1/1                                      next_mshr_entry.req_data    =   proc2cache_i.data   ;
151                                             end
                        MISSING_ELSE
152                                         end
                        MISSING_ELSE
153                                     end
                        MISSING_ELSE
154        1/1                          next_mshr_cp_flag   =   1'b0    ;
155        1/1                          next_mshr_cp_data   =   'b0     ;
156                                 end
157                                 ST_WAIT_DEPEND  :   begin
158                                     // IF   the older transaction that the entry is linked to completed
159                                     // ->   Update the cache data
160        0/1     ==>                  if (cp_flag_i[mshr_entry.link_idx] == 1'b1) begin
161        0/1     ==>                      next_mshr_entry.state       =   ST_UPDATE   ;
162        0/1     ==>                      next_mshr_entry.link_idx    =   'd0         ;
163        0/1     ==>                      next_mshr_entry.req_data    =   cp_data_i[mshr_entry.link_idx];
164        0/1     ==>                      if (mshr_entry.cmd == BUS_STORE) begin
165        0/1     ==>                          case (mshr_entry.req_size)
166        0/1     ==>                              BYTE    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +:  8]    =   mshr_entry.req_data[ 7:0]   ;
167        0/1     ==>                              HALF    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +: 16]    =   mshr_entry.req_data[15:0]   ;
168        0/1     ==>                              WORD    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +: 32]    =   mshr_entry.req_data[31:0]   ;
169        0/1     ==>                              DOUBLE  :   next_mshr_entry.req_data                                    =   mshr_entry.req_data         ;
170        0/1     ==>                              default :   next_mshr_entry.req_data                                    =   mshr_entry.req_data         ;
171                                             endcase
172                                         end
                   ==>  MISSING_ELSE
173                                     end
                   ==>  MISSING_ELSE
174                                 end
175                                 ST_WAIT_EVICT   : begin
176                                     // IF   the older transaction that evicts the cache block completed
177                                     // ->   Read from Memory
178        0/1     ==>                  if (cp_flag_i[mshr_entry.link_idx] == 1'b1) begin
179        0/1     ==>                      next_mshr_entry.state       =   ST_RD_MEM   ;
180        0/1     ==>                      next_mshr_entry.link_idx    =   'd0         ;
181                                     end
                   ==>  MISSING_ELSE
182                                 end
183                                 ST_RD_MEM   :   begin
184                                     // IF   the read transaction is confirmed by Memory Interface
185                                     // ->   Wait for the data to return from Memory
186        1/1                          if ((memory_grant_i == 1'b1) && (mem2cache_i.response != 'd0)) begin
187        1/1                              next_mshr_entry.state       =   ST_WAIT_MEM             ;
188        1/1                              next_mshr_entry.mem_tag     =   mem2cache_i.response    ;
189                                     end
                        MISSING_ELSE
190                                 end
191                                 ST_WAIT_MEM :   begin
192                                     // IF   the data is returned from the Memory
193                                     // ->   Update the cache data
194        1/1                          if (mem2cache_i.tag == mshr_entry.mem_tag) begin
195        1/1                              next_mshr_entry.state       =   ST_UPDATE           ;
196        1/1                              next_mshr_entry.req_data    =   mem2cache_i.data    ;
197        1/1                              if (mshr_entry.cmd == BUS_STORE) begin
198        1/1                                  case (mshr_entry.req_size)
199        1/1                                      BYTE    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +:  8]    =   mshr_entry.req_data[ 7:0]   ;
200        1/1                                      HALF    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +: 16]    =   mshr_entry.req_data[15:0]   ;
201        1/1                                      WORD    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +: 32]    =   mshr_entry.req_data[31:0]   ;
202        1/1                                      DOUBLE  :   next_mshr_entry.req_data                                    =   mshr_entry.req_data         ;
203        0/1     ==>                              default :   next_mshr_entry.req_data                                    =   mshr_entry.req_data         ;
204                                             endcase
205                                         end
                        MISSING_ELSE
206                                     end
                        MISSING_ELSE
207                                 end
208                                 ST_UPDATE   :   begin
209                                     // IF   the req interface is granted to this entry
210        1/1                          if (cache_mem_grant_i == 1'b1) begin
211                                         // IF   it is a load miss
212                                         // ->   Output data to processor
213        1/1                              if (mshr_entry.cmd == BUS_LOAD) begin
214        1/1                                  next_mshr_entry.state       =   ST_OUTPUT;
215        1/1                                  next_mshr_entry.evict_addr  =   cache_mem_ctrl_i.evict_addr ;
216        1/1                                  next_mshr_entry.evict_data  =   cache_mem_ctrl_i.evict_data ;
217        1/1                                  next_mshr_entry.evict_dirty =   cache_mem_ctrl_i.evict_dirty;
218                                         // IF   a dirty block is evicted
219                                         // ->   Write back the evicted block
220        1/1                              end else if (cache_mem_ctrl_i.evict_dirty == 1'b1) begin
221        1/1                                  next_mshr_entry.state       =   ST_EVICT;
222        1/1                                  next_mshr_entry.evict_addr  =   cache_mem_ctrl_i.evict_addr ;
223        1/1                                  next_mshr_entry.evict_data  =   cache_mem_ctrl_i.evict_data ;
224        1/1                                  next_mshr_entry.evict_dirty =   cache_mem_ctrl_i.evict_dirty;
225                                         // ELSE
226                                         // ->   Miss Handling Completed
227                                         end else begin
228        1/1                                  next_mshr_entry.state       =   ST_IDLE             ;
229        1/1                                  next_mshr_entry.cmd         =   BUS_NONE            ;
230        1/1                                  next_mshr_entry.req_addr    =   'b0                 ;
231        1/1                                  next_mshr_entry.req_data    =   'b0                 ;
232        1/1                                  next_mshr_entry.req_size    =   BYTE                ;
233        1/1                                  next_mshr_entry.evict_addr  =   'b0                 ;
234        1/1                                  next_mshr_entry.evict_data  =   'b0                 ;
235        1/1                                  next_mshr_entry.evict_dirty =   1'b0                ;
236        1/1                                  next_mshr_entry.link_idx    =   'd0                 ;
237        1/1                                  next_mshr_entry.mem_tag     =   'd0                 ;
238        1/1                                  next_mshr_cp_flag           =   1'b1                ;
239        1/1                                  next_mshr_cp_data           =   mshr_entry.req_data ;
240                                         end
241                                     end
                        MISSING_ELSE
242                                 end
243                                 ST_OUTPUT   :   begin
244                                     // IF   the Processor Interface is granted to this entry
245        1/1                          if (proc_grant_i == 1'b1) begin
246                                         // IF   the evicted block is dirty
247                                         // ->   Write back the evicted block
248        1/1                              if (mshr_entry.evict_dirty == 1'b1) begin
249        1/1                                  next_mshr_entry.state       =   ST_EVICT;
250                                         // ELSE
251                                         // ->   Miss Handling Completed
252                                         end else begin
253        1/1                                  next_mshr_entry.state       =   ST_IDLE             ;
254        1/1                                  next_mshr_entry.cmd         =   BUS_NONE            ;
255        1/1                                  next_mshr_entry.req_addr    =   'b0                 ;
256        1/1                                  next_mshr_entry.req_data    =   'b0                 ;
257        1/1                                  next_mshr_entry.req_size    =   BYTE                ;
258        1/1                                  next_mshr_entry.evict_addr  =   'b0                 ;
259        1/1                                  next_mshr_entry.evict_data  =   'b0                 ;
260        1/1                                  next_mshr_entry.evict_dirty =   1'b0                ;
261        1/1                                  next_mshr_entry.link_idx    =   'd0                 ;
262        1/1                                  next_mshr_entry.mem_tag     =   'd0                 ;
263        1/1                                  next_mshr_cp_flag           =   1'b1                ;
264        1/1                                  next_mshr_cp_data           =   mshr_entry.req_data ;
265                                         end
266                                     end
                        MISSING_ELSE
267                                 end
268                                 ST_EVICT    :   begin
269                                     // IF   the write back transaction to Memory is confirmed
270                                     // ->   Miss Handling Completed
271        1/1                          if ((memory_grant_i == 1'b1) && (mem2cache_i.response != 'd0)) begin
272        1/1                              next_mshr_entry.state       =   ST_IDLE             ;
273        1/1                              next_mshr_entry.cmd         =   BUS_NONE            ;
274        1/1                              next_mshr_entry.req_addr    =   'b0                 ;
275        1/1                              next_mshr_entry.req_data    =   'b0                 ;
276        1/1                              next_mshr_entry.req_size    =   BYTE                ;
277        1/1                              next_mshr_entry.evict_addr  =   'b0                 ;
278        1/1                              next_mshr_entry.evict_data  =   'b0                 ;
279        1/1                              next_mshr_entry.evict_dirty =   1'b0                ;
280        1/1                              next_mshr_entry.link_idx    =   'd0                 ;
281        1/1                              next_mshr_entry.mem_tag     =   'd0                 ;
282        1/1                              next_mshr_cp_flag           =   1'b1                ;
283        1/1                              next_mshr_cp_data           =   mshr_entry.req_data ;
284                                     end
                        MISSING_ELSE
285                                 end
286                                 default     :   begin
287        1/1                          next_mshr_entry.state       =   ST_IDLE     ;
288        1/1                          next_mshr_entry.cmd         =   BUS_NONE    ;
289        1/1                          next_mshr_entry.req_addr    =   'b0         ;
290        1/1                          next_mshr_entry.req_data    =   'b0         ;
291        1/1                          next_mshr_entry.req_size    =   BYTE        ;
292        1/1                          next_mshr_entry.evict_addr  =   'b0         ;
293        1/1                          next_mshr_entry.evict_data  =   'b0         ;
294        1/1                          next_mshr_entry.evict_dirty =   1'b0        ;
295        1/1                          next_mshr_entry.link_idx    =   'd0         ;
296        1/1                          next_mshr_entry.mem_tag     =   'd0         ;
297        1/1                          next_mshr_cp_flag           =   1'b0        ;
298        1/1                          next_mshr_cp_data           =   'd0         ;
299                                 end
300                             endcase
301                     
302        1/1                  if (next_mshr_entry.state == ST_IDLE) begin
303        1/1                      next_mshr_entry.linked  =   1'b0;
304        1/1                  end else if ((mshr_hit_i == 1'b1) && (mshr_hit_idx_i == mshr_entry_idx_i)) begin
305        1/1                      next_mshr_entry.linked  =   1'b1;
306                             end
                        MISSING_ELSE
307                         end
308                     
309                     // --------------------------------------------------------------------
310                     // MSHR entry output
311                     // --------------------------------------------------------------------
312                         assign  mshr_entry_o    =   mshr_entry  ;
313                     // --------------------------------------------------------------------
314                     // Processor Interface
315                     // --------------------------------------------------------------------
316                         always_comb begin
317        1/1                  mshr_proc_o.response    =   'd0 ;
318        1/1                  mshr_proc_o.data        =   'b0 ;
319        1/1                  mshr_proc_o.tag         =   'd0 ;
320        1/1                  case (mshr_entry.state)
321                                 ST_IDLE     :   begin
322                                     // IF   the processor request is allocated to this entry
323        1/1                          if ((proc2cache_i.command != BUS_NONE) && (dp_sel_i == 1'b1)) begin
324                                         // IF   The Processor Interface is granted to this entry
325                                         // AND  there is a dependency to older in-flight transaction
326                                         // ->   Confirm the request
327        1/1                              if (((mshr_hit_i && (cp_flag_i[mshr_hit_idx_i] == 1'b0))
328                                         || (evict_hit_i && (cp_flag_i[evict_hit_idx_i] == 1'b0)))) begin
329        1/1                                  mshr_proc_o.response    =   mshr_entry_idx_i;
330                                         // IF   The Processor Interface is granted to this entry
331                                         // AND  The cache_mem Interface is granted to this entry
332                                         // ->   Confirm the request 
333        1/1                              end else if (cache_mem_grant_i == 1'b1) begin
334        1/1                                  mshr_proc_o.response    =   mshr_entry_idx_i;
335                                             // IF   it is a load hit
336                                             // ->   Output data and tag
337        1/1                                  if (cache_mem_ctrl_i.req_hit == 1'b1 && proc2cache_i.command == BUS_LOAD) begin
338        0/1     ==>                              mshr_proc_o.tag     =   mshr_entry_idx_i;
339        0/1     ==>                              case (proc2cache_i.size)
340        0/1     ==>                                  BYTE    :   mshr_proc_o.data    =   {56'b0,cache_mem_ctrl_i.req_data_out[proc2cache_i.addr[2:0]+: 8]};
341        0/1     ==>                                  HALF    :   mshr_proc_o.data    =   {48'b0,cache_mem_ctrl_i.req_data_out[proc2cache_i.addr[2:0]+:16]};
342        0/1     ==>                                  WORD    :   mshr_proc_o.data    =   {32'b0,cache_mem_ctrl_i.req_data_out[proc2cache_i.addr[2:0]+:32]};
343        0/1     ==>                                  DOUBLE  :   mshr_proc_o.data    =   cache_mem_ctrl_i.req_data_out;
344        0/1     ==>                                  default :   mshr_proc_o.data    =   cache_mem_ctrl_i.req_data_out;
345                                                 endcase
346                                             end
                        MISSING_ELSE
347                                         end
                        MISSING_ELSE
348                                     end
                        MISSING_ELSE
349                                 end
350                                 ST_OUTPUT   :   begin
351        1/1                          mshr_proc_o.response    =   'd0                 ;
352        1/1                          mshr_proc_o.tag         =   mshr_entry_idx_i    ;
353        1/1                          case (mshr_entry.req_size)
354        1/1                              BYTE    :   mshr_proc_o.data    =   {56'b0,mshr_entry.req_data[mshr_entry.req_addr[2:0]+: 8]};
355        1/1                              HALF    :   mshr_proc_o.data    =   {48'b0,mshr_entry.req_data[mshr_entry.req_addr[2:0]+:16]};
356        1/1                              WORD    :   mshr_proc_o.data    =   {32'b0,mshr_entry.req_data[mshr_entry.req_addr[2:0]+:32]};
357        1/1                              DOUBLE  :   mshr_proc_o.data    =   mshr_entry.req_data;
358        0/1     ==>                      default :   mshr_proc_o.data    =   mshr_entry.req_data;
359                                     endcase
360                                 end
                        MISSING_DEFAULT
361                             endcase
362                         end
363                     
364                     // --------------------------------------------------------------------
365                     // cache_mem Interface
366                     // --------------------------------------------------------------------
367                         always_comb begin
368        1/1                  mshr_cache_mem_o.req_cmd        =   REQ_NONE;
369        1/1                  mshr_cache_mem_o.req_addr       =   'b0     ;
370        1/1                  mshr_cache_mem_o.req_data_in    =   'b0     ;
371        1/1                  case (mshr_entry.state)
372                                 ST_IDLE:    begin
373                                     // IF   the processor request is allocated to this entry
374        1/1                          if (dp_sel_i == 1'b1) begin
375        1/1                              case (proc2cache_i.command)
376                                             BUS_LOAD    :   begin
377        1/1                                      mshr_cache_mem_o.req_cmd        =   REQ_LOAD                        ;
378        1/1                                      mshr_cache_mem_o.req_addr       =   proc2cache_i.addr               ;
379        1/1                                      mshr_cache_mem_o.req_data_in    =   cache_mem_ctrl_i.req_data_out   ;
380                                             end
381                                             BUS_STORE   :   begin
382        1/1                                      mshr_cache_mem_o.req_cmd        =   REQ_STORE                       ;
383        1/1                                      mshr_cache_mem_o.req_addr       =   proc2cache_i.addr               ;
384        1/1                                      mshr_cache_mem_o.req_data_in    =   cache_mem_ctrl_i.req_data_out   ;
385        1/1                                      case (proc2cache_i.size)
386        1/1                                          BYTE    :   mshr_cache_mem_o.req_data_in[proc2cache_i.addr[2:0] +:  8]  =   proc2cache_i.data[ 7:0] ;
387        1/1                                          HALF    :   mshr_cache_mem_o.req_data_in[proc2cache_i.addr[2:0] +: 16]  =   proc2cache_i.data[15:0] ;
388        1/1                                          WORD    :   mshr_cache_mem_o.req_data_in[proc2cache_i.addr[2:0] +: 32]  =   proc2cache_i.data[31:0] ;
389        1/1                                          DOUBLE  :   mshr_cache_mem_o.req_data_in                                =   proc2cache_i.data       ;
                   ==>  MISSING_DEFAULT
390                                                 endcase
391                                             end    
                        MISSING_DEFAULT
392                                         endcase
393                                     end
                        MISSING_ELSE
394                                 end
395                                 ST_UPDATE:  begin
396        1/1                          if (mshr_entry.cmd == BUS_LOAD) begin
397        1/1                              mshr_cache_mem_o.req_cmd    =   REQ_LOAD_MISS       ;
398                                     end else begin
399        1/1                              mshr_cache_mem_o.req_cmd    =   REQ_STORE_MISS      ;
400                                     end
401        1/1                          mshr_cache_mem_o.req_addr       =   mshr_entry.req_addr ;
402        1/1                          mshr_cache_mem_o.req_data_in    =   mshr_entry.req_data ;
403                                 end
                        MISSING_DEFAULT
404                             endcase
405                         end
406                     
407                     // --------------------------------------------------------------------
408                     // Memory Interface
409                     // --------------------------------------------------------------------
410                         always_comb begin
411        1/1                  mshr_memory_o.addr      =   {mshr_entry.req_addr[C_XLEN-1:C_CACHE_OFFSET_WIDTH], {C_CACHE_OFFSET_WIDTH{1'b0}}};
412        1/1                  mshr_memory_o.size      =   DOUBLE              ;
413        1/1                  mshr_memory_o.command   =   BUS_NONE            ;
414        1/1                  mshr_memory_o.data      =   'd0 ;
415        1/1                  case (mshr_entry.state)
416                                 ST_RD_MEM   :   begin
417        1/1                          mshr_memory_o.data      =   'd0 ;
418        1/1                          mshr_memory_o.addr      =   {mshr_entry.req_addr[C_XLEN-1:C_CACHE_OFFSET_WIDTH], {C_CACHE_OFFSET_WIDTH{1'b0}}};
419        1/1                          mshr_memory_o.command   =   BUS_LOAD;
420                                 end
421                                 ST_EVICT    :   begin
422        1/1                          mshr_memory_o.data      =   mshr_entry.evict_data;
423        1/1                          mshr_memory_o.addr      =   {mshr_entry.evict_addr[C_XLEN-1:C_CACHE_OFFSET_WIDTH], {C_CACHE_OFFSET_WIDTH{1'b0}}};
424        1/1                          mshr_memory_o.command   =   BUS_STORE;
425                                 end
                        MISSING_DEFAULT

-------------------------------------------------------------------------------
Toggle Coverage for Instance : cache_tb.dut.cache_ctrl_inst.genblk1[6].mshr_entry_ctrl_inst
                Total Covered Percent 
Totals          72    46      63.89   
Total Bits      4844  4059    83.79   
Total Bits 0->1 2422  2029    83.77   
Total Bits 1->0 2422  2030    83.82   

                                
Ports          48   29   60.42  
Port Bits      3878 3245 83.68  
Port Bits 0->1 1939 1622 83.65  
Port Bits 1->0 1939 1623 83.70  

                                
Signals          24  17  70.83  
Signal Bits      966 814 84.27  
Signal Bits 0->1 483 407 84.27  
Signal Bits 1->0 483 407 84.27  

Port Details
                                     Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i                                Yes    Yes         Yes         INPUT     
rst_i                                No     Yes         No          INPUT     
mshr_entry_idx_i[3:0]                No     No          No          INPUT     
mshr_entry_o.mem_tag[3:0]            Yes    Yes         Yes         OUTPUT    
mshr_entry_o.linked                  No     No          No          OUTPUT    
mshr_entry_o.link_idx[3:0]           No     No          No          OUTPUT    
mshr_entry_o.evict_dirty             Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_data[63:0]        Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_addr[2:0]         No     No          No          OUTPUT    
mshr_entry_o.evict_addr[15:3]        Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_addr[31:16]       No     No          No          OUTPUT    
mshr_entry_o.req_size[1:0]           Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_data[63:0]          Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_addr[15:0]          Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_addr[31:16]         No     No          No          OUTPUT    
mshr_entry_o.cmd[1:0]                Yes    Yes         Yes         OUTPUT    
mshr_entry_o.state[2:0]              Yes    Yes         Yes         OUTPUT    
proc_grant_i                         Yes    Yes         Yes         INPUT     
proc2cache_i.command[1:0]            Yes    Yes         Yes         INPUT     
proc2cache_i.size[1:0]               Yes    Yes         Yes         INPUT     
proc2cache_i.data[63:0]              Yes    Yes         Yes         INPUT     
proc2cache_i.addr[15:0]              Yes    Yes         Yes         INPUT     
proc2cache_i.addr[31:16]             No     No          No          INPUT     
mshr_proc_o.tag[0]                   No     No          No          OUTPUT    
mshr_proc_o.tag[2:1]                 Yes    Yes         Yes         OUTPUT    
mshr_proc_o.tag[3]                   No     No          No          OUTPUT    
mshr_proc_o.data[0]                  No     No          No          OUTPUT    
mshr_proc_o.data[3:1]                Yes    Yes         Yes         OUTPUT    
mshr_proc_o.data[4]                  No     No          No          OUTPUT    
mshr_proc_o.data[5]                  Yes    Yes         Yes         OUTPUT    
mshr_proc_o.data[6]                  No     No          No          OUTPUT    
mshr_proc_o.data[8:7]                Yes    Yes         Yes         OUTPUT    
mshr_proc_o.data[9]                  No     No          No          OUTPUT    
mshr_proc_o.data[16:10]              Yes    Yes         Yes         OUTPUT    
mshr_proc_o.data[17]                 No     No          No          OUTPUT    
mshr_proc_o.data[18]                 Yes    Yes         Yes         OUTPUT    
mshr_proc_o.data[19]                 No     No          No          OUTPUT    
mshr_proc_o.data[21:20]              Yes    Yes         Yes         OUTPUT    
mshr_proc_o.data[22]                 No     No          No          OUTPUT    
mshr_proc_o.data[24:23]              Yes    Yes         Yes         OUTPUT    
mshr_proc_o.data[26:25]              No     No          No          OUTPUT    
mshr_proc_o.data[27]                 Yes    Yes         Yes         OUTPUT    
mshr_proc_o.data[28]                 No     No          No          OUTPUT    
mshr_proc_o.data[29]                 Yes    Yes         Yes         OUTPUT    
mshr_proc_o.data[30]                 No     No          No          OUTPUT    
mshr_proc_o.data[33:31]              Yes    Yes         Yes         OUTPUT    
mshr_proc_o.data[34]                 No     No          No          OUTPUT    
mshr_proc_o.data[41:35]              Yes    Yes         Yes         OUTPUT    
mshr_proc_o.data[43:42]              No     No          No          OUTPUT    
mshr_proc_o.data[44]                 Yes    Yes         Yes         OUTPUT    
mshr_proc_o.data[46:45]              No     No          No          OUTPUT    
mshr_proc_o.data[49:47]              Yes    Yes         Yes         OUTPUT    
mshr_proc_o.data[51:50]              No     No          No          OUTPUT    
mshr_proc_o.data[54:52]              Yes    Yes         Yes         OUTPUT    
mshr_proc_o.data[55]                 No     No          No          OUTPUT    
mshr_proc_o.data[58:56]              Yes    Yes         Yes         OUTPUT    
mshr_proc_o.data[59]                 No     No          No          OUTPUT    
mshr_proc_o.data[62:60]              Yes    Yes         Yes         OUTPUT    
mshr_proc_o.data[63]                 No     No          No          OUTPUT    
mshr_proc_o.response[0]              No     No          No          OUTPUT    
mshr_proc_o.response[2:1]            Yes    Yes         Yes         OUTPUT    
mshr_proc_o.response[3]              No     No          No          OUTPUT    
cache_mem_grant_i                    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.evict_data[63:0]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.evict_addr[2:0]     No     No          No          INPUT     
cache_mem_ctrl_i.evict_addr[15:3]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.evict_addr[31:16]   No     No          No          INPUT     
cache_mem_ctrl_i.evict_dirty         Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[4:0]   Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[6:5]   No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[8:7]   Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[11:9]  No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[13:12] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[15:14] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[25:16] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[26]    No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[31:27] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[33:32] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[34]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[37:35] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[38]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[41:39] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[42]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[45:43] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[47:46] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[50:48] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[52:51] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[54:53] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[58:55] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[60:59] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[63:61] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_hit             Yes    Yes         Yes         INPUT     
mshr_cache_mem_o.req_data_in[63:0]   Yes    Yes         Yes         OUTPUT    
mshr_cache_mem_o.req_addr[15:0]      Yes    Yes         Yes         OUTPUT    
mshr_cache_mem_o.req_addr[31:16]     No     No          No          OUTPUT    
mshr_cache_mem_o.req_cmd[2:0]        Yes    Yes         Yes         OUTPUT    
memory_grant_i                       Yes    Yes         Yes         INPUT     
mem2cache_i.tag[3:0]                 Yes    Yes         Yes         INPUT     
mem2cache_i.data[63:0]               Yes    Yes         Yes         INPUT     
mem2cache_i.response[3:0]            Yes    Yes         Yes         INPUT     
mshr_memory_o.command[1:0]           Yes    Yes         Yes         OUTPUT    
mshr_memory_o.size[1:0]              No     No          No          OUTPUT    
mshr_memory_o.data[63:0]             Yes    Yes         Yes         OUTPUT    
mshr_memory_o.addr[2:0]              No     No          No          OUTPUT    
mshr_memory_o.addr[15:3]             Yes    Yes         Yes         OUTPUT    
mshr_memory_o.addr[31:16]            No     No          No          OUTPUT    
mshr_hit_i                           Yes    Yes         Yes         INPUT     
mshr_hit_idx_i[3:0]                  Yes    Yes         Yes         INPUT     
evict_hit_i                          No     No          No          INPUT     
evict_hit_idx_i[3:0]                 No     No          No          INPUT     
dp_sel_i                             Yes    Yes         Yes         INPUT     
mshr_cp_flag_o                       Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[63:0]                 Yes    Yes         Yes         OUTPUT    
cp_flag_i[0]                         No     No          No          INPUT     
cp_flag_i[15:1]                      Yes    Yes         Yes         INPUT     
cp_data_i[8:1][63:0]                 Yes    Yes         Yes         INPUT     
cp_data_i[9][44:0]                   Yes    Yes         Yes         INPUT     
cp_data_i[9][63:46]                  Yes    Yes         Yes         INPUT     
cp_data_i[10][30:1]                  Yes    Yes         Yes         INPUT     
cp_data_i[10][36:32]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][41:40]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][45]                    Yes    Yes         Yes         INPUT     
cp_data_i[10][49:47]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][52:51]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][56:55]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][60]                    Yes    Yes         Yes         INPUT     
cp_data_i[10][62]                    Yes    Yes         Yes         INPUT     
cp_data_i[11][27:0]                  Yes    Yes         Yes         INPUT     
cp_data_i[11][36:29]                 Yes    Yes         Yes         INPUT     
cp_data_i[11][49:39]                 Yes    Yes         Yes         INPUT     
cp_data_i[11][51]                    Yes    Yes         Yes         INPUT     
cp_data_i[11][59:54]                 Yes    Yes         Yes         INPUT     
cp_data_i[11][63:62]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][4:0]                   Yes    Yes         Yes         INPUT     
cp_data_i[12][27:6]                  Yes    Yes         Yes         INPUT     
cp_data_i[12][31:29]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][35:33]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][39]                    Yes    Yes         Yes         INPUT     
cp_data_i[12][44:43]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][48:46]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][50]                    Yes    Yes         Yes         INPUT     
cp_data_i[12][54]                    Yes    Yes         Yes         INPUT     
cp_data_i[12][58:57]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][61]                    Yes    Yes         Yes         INPUT     
cp_data_i[13][17:0]                  Yes    Yes         Yes         INPUT     
cp_data_i[13][46:19]                 Yes    Yes         Yes         INPUT     
cp_data_i[13][49]                    Yes    Yes         Yes         INPUT     
cp_data_i[13][56:51]                 Yes    Yes         Yes         INPUT     
cp_data_i[13][63:58]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][14:1]                  Yes    Yes         Yes         INPUT     
cp_data_i[14][19:16]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][21]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][24:23]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][27]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][32:30]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][37:35]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][39]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][41]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][43]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][46:45]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][51:49]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][59:53]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][62:61]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][15:0]                  Yes    Yes         Yes         INPUT     
cp_data_i[15][37:17]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][40:39]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][42]                    Yes    Yes         Yes         INPUT     
cp_data_i[15][45:44]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][48:47]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][53:51]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][55]                    Yes    Yes         Yes         INPUT     
cp_data_i[15][63:57]                 Yes    Yes         Yes         INPUT     
Other bits of cp_data_i[15:0][63:0]  No     No          No          INPUT     

Signal Details
                                  Toggle Toggle 1->0 Toggle 0->1 
mshr_entry.mem_tag[3:0]           Yes    Yes         Yes         
mshr_entry.linked                 No     No          No          
mshr_entry.link_idx[3:0]          No     No          No          
mshr_entry.evict_dirty            Yes    Yes         Yes         
mshr_entry.evict_data[63:0]       Yes    Yes         Yes         
mshr_entry.evict_addr[2:0]        No     No          No          
mshr_entry.evict_addr[15:3]       Yes    Yes         Yes         
mshr_entry.evict_addr[31:16]      No     No          No          
mshr_entry.req_size[1:0]          Yes    Yes         Yes         
mshr_entry.req_data[63:0]         Yes    Yes         Yes         
mshr_entry.req_addr[15:0]         Yes    Yes         Yes         
mshr_entry.req_addr[31:16]        No     No          No          
mshr_entry.cmd[1:0]               Yes    Yes         Yes         
mshr_entry.state[2:0]             Yes    Yes         Yes         
next_mshr_entry.mem_tag[3:0]      Yes    Yes         Yes         
next_mshr_entry.linked            Yes    Yes         Yes         
next_mshr_entry.link_idx[2:0]     Yes    Yes         Yes         
next_mshr_entry.link_idx[3]       No     No          No          
next_mshr_entry.evict_dirty       Yes    Yes         Yes         
next_mshr_entry.evict_data[63:0]  Yes    Yes         Yes         
next_mshr_entry.evict_addr[2:0]   No     No          No          
next_mshr_entry.evict_addr[15:3]  Yes    Yes         Yes         
next_mshr_entry.evict_addr[31:16] No     No          No          
next_mshr_entry.req_size[1:0]     Yes    Yes         Yes         
next_mshr_entry.req_data[63:0]    Yes    Yes         Yes         
next_mshr_entry.req_addr[15:0]    Yes    Yes         Yes         
next_mshr_entry.req_addr[31:16]   No     No          No          
next_mshr_entry.cmd[1:0]          Yes    Yes         Yes         
next_mshr_entry.state[2:0]        Yes    Yes         Yes         
next_mshr_cp_flag                 Yes    Yes         Yes         
next_mshr_cp_data[63:0]           Yes    Yes         Yes         


-------------------------------------------------------------------------------
===============================================================================
Module Instance : cache_tb.dut.cache_ctrl_inst.genblk1[1].mshr_entry_ctrl_inst
===============================================================================

Instance :

SCORE  LINE   TOGGLE 
 86.35  89.52  83.18 


Instance's subtree :

SCORE  LINE   TOGGLE 
 86.35  89.52  83.18 


Module : 

SCORE  LINE   TOGGLE NAME            
 87.59  90.48  84.70 mshr_entry_ctrl 


Parent : 

SCORE  LINE   TOGGLE NAME            
 92.38 100.00  84.76 cache_ctrl_inst 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : cache_tb.dut.cache_ctrl_inst.genblk1[1].mshr_entry_ctrl_inst

             Line No.   Total   Covered  Percent
TOTAL                      210      188    89.52
ALWAYS             75       17       17   100.00
ALWAYS             97      135      118    87.41
ALWAYS            317       25       20    80.00
ALWAYS            368       22       22   100.00
ALWAYS            411       11       11   100.00

74                          always_ff @(posedge clk_i) begin
75         1/1                  if (rst_i) begin
76         1/1                      mshr_entry.state        <=  `SD ST_IDLE     ;
77         1/1                      mshr_entry.cmd          <=  `SD BUS_NONE    ;
78         1/1                      mshr_entry.req_addr     <=  `SD 'b0         ;
79         1/1                      mshr_entry.req_data     <=  `SD 'b0         ;
80         1/1                      mshr_entry.req_size     <=  `SD BYTE        ;
81         1/1                      mshr_entry.evict_addr   <=  `SD 'b0         ;
82         1/1                      mshr_entry.evict_data   <=  `SD 'b0         ;
83         1/1                      mshr_entry.evict_dirty  <=  `SD 1'b0        ;
84         1/1                      mshr_entry.link_idx     <=  `SD 'd0         ;
85         1/1                      mshr_entry.linked       <=  `SD 1'b0        ;
86         1/1                      mshr_entry.mem_tag      <=  `SD 'd0         ;
87         1/1                      mshr_cp_flag_o          <=  `SD 1'b0        ;
88         1/1                      mshr_cp_data_o          <=  `SD 'b0         ;
89                              end else begin
90         1/1                      mshr_entry              <=  `SD next_mshr_entry     ;
91         1/1                      mshr_cp_flag_o          <=  `SD next_mshr_cp_flag   ;
92         1/1                      mshr_cp_data_o          <=  `SD next_mshr_cp_data   ;
93                              end
94                          end
95                      
96                          always_comb begin
97         1/1                  next_mshr_entry.state       =   mshr_entry.state        ;
98         1/1                  next_mshr_entry.cmd         =   mshr_entry.cmd          ;
99         1/1                  next_mshr_entry.req_addr    =   mshr_entry.req_addr     ;
100        1/1                  next_mshr_entry.req_data    =   mshr_entry.req_data     ;
101        1/1                  next_mshr_entry.req_size    =   mshr_entry.req_size     ;
102        1/1                  next_mshr_entry.evict_addr  =   mshr_entry.evict_addr   ;
103        1/1                  next_mshr_entry.evict_data  =   mshr_entry.evict_data   ;
104        1/1                  next_mshr_entry.evict_dirty =   mshr_entry.evict_dirty  ;
105        1/1                  next_mshr_entry.link_idx    =   mshr_entry.link_idx     ;
106        1/1                  next_mshr_entry.linked      =   mshr_entry.linked       ;
107        1/1                  next_mshr_entry.mem_tag     =   mshr_entry.mem_tag      ;
108        1/1                  next_mshr_cp_flag           =   mshr_cp_flag_o          ;
109        1/1                  next_mshr_cp_data           =   mshr_cp_data_o          ;
110        1/1                  case (mshr_entry.state)
111                                 ST_IDLE     :   begin
112                                     // IF   there is a valid transaction on Processor Interface
113                                     // AND  the Processor Interface is granted to this entry
114                                     // AND  the cache_mem Interface is granted to this entry
115                                     // AND  it is a miss
116                                     // AND  the entry is selected to hold the new miss
117        1/1                          if ((proc2cache_i.command != BUS_NONE) && (dp_sel_i == 1'b1)
118                                     && (proc_grant_i == 1'b1)) begin
119                                         // IF   there is an older in-flight transaction to the same addreess
120                                         // ->   Wait for the completion of older miss to the same address
121        1/1                              if (mshr_hit_i && (cp_flag_i[mshr_hit_idx_i] == 1'b0)) begin
122        1/1                                  next_mshr_entry.state       =   ST_WAIT_DEPEND          ;
123        1/1                                  next_mshr_entry.link_idx    =   mshr_hit_idx_i          ;
124        1/1                                  next_mshr_entry.cmd         =   proc2cache_i.command    ;
125        1/1                                  next_mshr_entry.req_addr    =   proc2cache_i.addr       ;
126        1/1                                  next_mshr_entry.req_size    =   proc2cache_i.size       ;
127        1/1                                  if (proc2cache_i.command == BUS_STORE) begin
128        1/1                                      next_mshr_entry.req_data    =   proc2cache_i.data   ;
129                                             end
                        MISSING_ELSE
130                                         // IF   there is an older in-flight transaction that is in the middle of evicting the data block
131                                         // ->   Wait for the completion of write-back to memory
132        1/1                              end else if (evict_hit_i && (cp_flag_i[evict_hit_idx_i] == 1'b0)) begin
133        0/1     ==>                          next_mshr_entry.state       =   ST_WAIT_EVICT           ;
134        0/1     ==>                          next_mshr_entry.link_idx    =   evict_hit_idx_i         ;
135        0/1     ==>                          next_mshr_entry.cmd         =   proc2cache_i.command    ;
136        0/1     ==>                          next_mshr_entry.req_addr    =   proc2cache_i.addr       ;
137        0/1     ==>                          next_mshr_entry.req_size    =   proc2cache_i.size       ;
138        0/1     ==>                          if (proc2cache_i.command == BUS_STORE) begin
139        0/1     ==>                              next_mshr_entry.req_data    =   proc2cache_i.data   ;
140                                             end
                   ==>  MISSING_ELSE
141                                         // IF   it is a miss, and no dependency to older in-flight transactions.
142                                         // ->   Start miss handling
143        1/1                              end else if ((cache_mem_ctrl_i.req_hit == 1'b0) && (cache_mem_grant_i == 1'b1)) begin
144        1/1                                  next_mshr_entry.state       =   ST_RD_MEM               ;
145        1/1                                  next_mshr_entry.link_idx    =   'd0                     ;
146        1/1                                  next_mshr_entry.cmd         =   proc2cache_i.command    ;
147        1/1                                  next_mshr_entry.req_addr    =   proc2cache_i.addr       ;
148        1/1                                  next_mshr_entry.req_size    =   proc2cache_i.size       ;
149        1/1                                  if (proc2cache_i.command == BUS_STORE) begin
150        1/1                                      next_mshr_entry.req_data    =   proc2cache_i.data   ;
151                                             end
                        MISSING_ELSE
152                                         end
                        MISSING_ELSE
153                                     end
                        MISSING_ELSE
154        1/1                          next_mshr_cp_flag   =   1'b0    ;
155        1/1                          next_mshr_cp_data   =   'b0     ;
156                                 end
157                                 ST_WAIT_DEPEND  :   begin
158                                     // IF   the older transaction that the entry is linked to completed
159                                     // ->   Update the cache data
160        1/1                          if (cp_flag_i[mshr_entry.link_idx] == 1'b1) begin
161        1/1                              next_mshr_entry.state       =   ST_UPDATE   ;
162        1/1                              next_mshr_entry.link_idx    =   'd0         ;
163        1/1                              next_mshr_entry.req_data    =   cp_data_i[mshr_entry.link_idx];
164        1/1                              if (mshr_entry.cmd == BUS_STORE) begin
165        0/1     ==>                          case (mshr_entry.req_size)
166        0/1     ==>                              BYTE    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +:  8]    =   mshr_entry.req_data[ 7:0]   ;
167        0/1     ==>                              HALF    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +: 16]    =   mshr_entry.req_data[15:0]   ;
168        0/1     ==>                              WORD    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +: 32]    =   mshr_entry.req_data[31:0]   ;
169        0/1     ==>                              DOUBLE  :   next_mshr_entry.req_data                                    =   mshr_entry.req_data         ;
170        0/1     ==>                              default :   next_mshr_entry.req_data                                    =   mshr_entry.req_data         ;
171                                             endcase
172                                         end
                        MISSING_ELSE
173                                     end
                        MISSING_ELSE
174                                 end
175                                 ST_WAIT_EVICT   : begin
176                                     // IF   the older transaction that evicts the cache block completed
177                                     // ->   Read from Memory
178        0/1     ==>                  if (cp_flag_i[mshr_entry.link_idx] == 1'b1) begin
179        0/1     ==>                      next_mshr_entry.state       =   ST_RD_MEM   ;
180        0/1     ==>                      next_mshr_entry.link_idx    =   'd0         ;
181                                     end
                   ==>  MISSING_ELSE
182                                 end
183                                 ST_RD_MEM   :   begin
184                                     // IF   the read transaction is confirmed by Memory Interface
185                                     // ->   Wait for the data to return from Memory
186        1/1                          if ((memory_grant_i == 1'b1) && (mem2cache_i.response != 'd0)) begin
187        1/1                              next_mshr_entry.state       =   ST_WAIT_MEM             ;
188        1/1                              next_mshr_entry.mem_tag     =   mem2cache_i.response    ;
189                                     end
                        MISSING_ELSE
190                                 end
191                                 ST_WAIT_MEM :   begin
192                                     // IF   the data is returned from the Memory
193                                     // ->   Update the cache data
194        1/1                          if (mem2cache_i.tag == mshr_entry.mem_tag) begin
195        1/1                              next_mshr_entry.state       =   ST_UPDATE           ;
196        1/1                              next_mshr_entry.req_data    =   mem2cache_i.data    ;
197        1/1                              if (mshr_entry.cmd == BUS_STORE) begin
198        1/1                                  case (mshr_entry.req_size)
199        1/1                                      BYTE    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +:  8]    =   mshr_entry.req_data[ 7:0]   ;
200        1/1                                      HALF    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +: 16]    =   mshr_entry.req_data[15:0]   ;
201        1/1                                      WORD    :   next_mshr_entry.req_data[mshr_entry.req_addr[2:0] +: 32]    =   mshr_entry.req_data[31:0]   ;
202        1/1                                      DOUBLE  :   next_mshr_entry.req_data                                    =   mshr_entry.req_data         ;
203        0/1     ==>                              default :   next_mshr_entry.req_data                                    =   mshr_entry.req_data         ;
204                                             endcase
205                                         end
                        MISSING_ELSE
206                                     end
                        MISSING_ELSE
207                                 end
208                                 ST_UPDATE   :   begin
209                                     // IF   the req interface is granted to this entry
210        1/1                          if (cache_mem_grant_i == 1'b1) begin
211                                         // IF   it is a load miss
212                                         // ->   Output data to processor
213        1/1                              if (mshr_entry.cmd == BUS_LOAD) begin
214        1/1                                  next_mshr_entry.state       =   ST_OUTPUT;
215        1/1                                  next_mshr_entry.evict_addr  =   cache_mem_ctrl_i.evict_addr ;
216        1/1                                  next_mshr_entry.evict_data  =   cache_mem_ctrl_i.evict_data ;
217        1/1                                  next_mshr_entry.evict_dirty =   cache_mem_ctrl_i.evict_dirty;
218                                         // IF   a dirty block is evicted
219                                         // ->   Write back the evicted block
220        1/1                              end else if (cache_mem_ctrl_i.evict_dirty == 1'b1) begin
221        1/1                                  next_mshr_entry.state       =   ST_EVICT;
222        1/1                                  next_mshr_entry.evict_addr  =   cache_mem_ctrl_i.evict_addr ;
223        1/1                                  next_mshr_entry.evict_data  =   cache_mem_ctrl_i.evict_data ;
224        1/1                                  next_mshr_entry.evict_dirty =   cache_mem_ctrl_i.evict_dirty;
225                                         // ELSE
226                                         // ->   Miss Handling Completed
227                                         end else begin
228        1/1                                  next_mshr_entry.state       =   ST_IDLE             ;
229        1/1                                  next_mshr_entry.cmd         =   BUS_NONE            ;
230        1/1                                  next_mshr_entry.req_addr    =   'b0                 ;
231        1/1                                  next_mshr_entry.req_data    =   'b0                 ;
232        1/1                                  next_mshr_entry.req_size    =   BYTE                ;
233        1/1                                  next_mshr_entry.evict_addr  =   'b0                 ;
234        1/1                                  next_mshr_entry.evict_data  =   'b0                 ;
235        1/1                                  next_mshr_entry.evict_dirty =   1'b0                ;
236        1/1                                  next_mshr_entry.link_idx    =   'd0                 ;
237        1/1                                  next_mshr_entry.mem_tag     =   'd0                 ;
238        1/1                                  next_mshr_cp_flag           =   1'b1                ;
239        1/1                                  next_mshr_cp_data           =   mshr_entry.req_data ;
240                                         end
241                                     end
                        MISSING_ELSE
242                                 end
243                                 ST_OUTPUT   :   begin
244                                     // IF   the Processor Interface is granted to this entry
245        1/1                          if (proc_grant_i == 1'b1) begin
246                                         // IF   the evicted block is dirty
247                                         // ->   Write back the evicted block
248        1/1                              if (mshr_entry.evict_dirty == 1'b1) begin
249        1/1                                  next_mshr_entry.state       =   ST_EVICT;
250                                         // ELSE
251                                         // ->   Miss Handling Completed
252                                         end else begin
253        1/1                                  next_mshr_entry.state       =   ST_IDLE             ;
254        1/1                                  next_mshr_entry.cmd         =   BUS_NONE            ;
255        1/1                                  next_mshr_entry.req_addr    =   'b0                 ;
256        1/1                                  next_mshr_entry.req_data    =   'b0                 ;
257        1/1                                  next_mshr_entry.req_size    =   BYTE                ;
258        1/1                                  next_mshr_entry.evict_addr  =   'b0                 ;
259        1/1                                  next_mshr_entry.evict_data  =   'b0                 ;
260        1/1                                  next_mshr_entry.evict_dirty =   1'b0                ;
261        1/1                                  next_mshr_entry.link_idx    =   'd0                 ;
262        1/1                                  next_mshr_entry.mem_tag     =   'd0                 ;
263        1/1                                  next_mshr_cp_flag           =   1'b1                ;
264        1/1                                  next_mshr_cp_data           =   mshr_entry.req_data ;
265                                         end
266                                     end
                        MISSING_ELSE
267                                 end
268                                 ST_EVICT    :   begin
269                                     // IF   the write back transaction to Memory is confirmed
270                                     // ->   Miss Handling Completed
271        1/1                          if ((memory_grant_i == 1'b1) && (mem2cache_i.response != 'd0)) begin
272        1/1                              next_mshr_entry.state       =   ST_IDLE             ;
273        1/1                              next_mshr_entry.cmd         =   BUS_NONE            ;
274        1/1                              next_mshr_entry.req_addr    =   'b0                 ;
275        1/1                              next_mshr_entry.req_data    =   'b0                 ;
276        1/1                              next_mshr_entry.req_size    =   BYTE                ;
277        1/1                              next_mshr_entry.evict_addr  =   'b0                 ;
278        1/1                              next_mshr_entry.evict_data  =   'b0                 ;
279        1/1                              next_mshr_entry.evict_dirty =   1'b0                ;
280        1/1                              next_mshr_entry.link_idx    =   'd0                 ;
281        1/1                              next_mshr_entry.mem_tag     =   'd0                 ;
282        1/1                              next_mshr_cp_flag           =   1'b1                ;
283        1/1                              next_mshr_cp_data           =   mshr_entry.req_data ;
284                                     end
                        MISSING_ELSE
285                                 end
286                                 default     :   begin
287        1/1                          next_mshr_entry.state       =   ST_IDLE     ;
288        1/1                          next_mshr_entry.cmd         =   BUS_NONE    ;
289        1/1                          next_mshr_entry.req_addr    =   'b0         ;
290        1/1                          next_mshr_entry.req_data    =   'b0         ;
291        1/1                          next_mshr_entry.req_size    =   BYTE        ;
292        1/1                          next_mshr_entry.evict_addr  =   'b0         ;
293        1/1                          next_mshr_entry.evict_data  =   'b0         ;
294        1/1                          next_mshr_entry.evict_dirty =   1'b0        ;
295        1/1                          next_mshr_entry.link_idx    =   'd0         ;
296        1/1                          next_mshr_entry.mem_tag     =   'd0         ;
297        1/1                          next_mshr_cp_flag           =   1'b0        ;
298        1/1                          next_mshr_cp_data           =   'd0         ;
299                                 end
300                             endcase
301                     
302        1/1                  if (next_mshr_entry.state == ST_IDLE) begin
303        1/1                      next_mshr_entry.linked  =   1'b0;
304        1/1                  end else if ((mshr_hit_i == 1'b1) && (mshr_hit_idx_i == mshr_entry_idx_i)) begin
305        1/1                      next_mshr_entry.linked  =   1'b1;
306                             end
                        MISSING_ELSE
307                         end
308                     
309                     // --------------------------------------------------------------------
310                     // MSHR entry output
311                     // --------------------------------------------------------------------
312                         assign  mshr_entry_o    =   mshr_entry  ;
313                     // --------------------------------------------------------------------
314                     // Processor Interface
315                     // --------------------------------------------------------------------
316                         always_comb begin
317        1/1                  mshr_proc_o.response    =   'd0 ;
318        1/1                  mshr_proc_o.data        =   'b0 ;
319        1/1                  mshr_proc_o.tag         =   'd0 ;
320        1/1                  case (mshr_entry.state)
321                                 ST_IDLE     :   begin
322                                     // IF   the processor request is allocated to this entry
323        1/1                          if ((proc2cache_i.command != BUS_NONE) && (dp_sel_i == 1'b1)) begin
324                                         // IF   The Processor Interface is granted to this entry
325                                         // AND  there is a dependency to older in-flight transaction
326                                         // ->   Confirm the request
327        1/1                              if (((mshr_hit_i && (cp_flag_i[mshr_hit_idx_i] == 1'b0))
328                                         || (evict_hit_i && (cp_flag_i[evict_hit_idx_i] == 1'b0)))) begin
329        1/1                                  mshr_proc_o.response    =   mshr_entry_idx_i;
330                                         // IF   The Processor Interface is granted to this entry
331                                         // AND  The cache_mem Interface is granted to this entry
332                                         // ->   Confirm the request 
333        1/1                              end else if (cache_mem_grant_i == 1'b1) begin
334        1/1                                  mshr_proc_o.response    =   mshr_entry_idx_i;
335                                             // IF   it is a load hit
336                                             // ->   Output data and tag
337        1/1                                  if (cache_mem_ctrl_i.req_hit == 1'b1 && proc2cache_i.command == BUS_LOAD) begin
338        1/1                                      mshr_proc_o.tag     =   mshr_entry_idx_i;
339        1/1                                      case (proc2cache_i.size)
340        0/1     ==>                                  BYTE    :   mshr_proc_o.data    =   {56'b0,cache_mem_ctrl_i.req_data_out[proc2cache_i.addr[2:0]+: 8]};
341        1/1                                          HALF    :   mshr_proc_o.data    =   {48'b0,cache_mem_ctrl_i.req_data_out[proc2cache_i.addr[2:0]+:16]};
342        0/1     ==>                                  WORD    :   mshr_proc_o.data    =   {32'b0,cache_mem_ctrl_i.req_data_out[proc2cache_i.addr[2:0]+:32]};
343        0/1     ==>                                  DOUBLE  :   mshr_proc_o.data    =   cache_mem_ctrl_i.req_data_out;
344        0/1     ==>                                  default :   mshr_proc_o.data    =   cache_mem_ctrl_i.req_data_out;
345                                                 endcase
346                                             end
                        MISSING_ELSE
347                                         end
                        MISSING_ELSE
348                                     end
                        MISSING_ELSE
349                                 end
350                                 ST_OUTPUT   :   begin
351        1/1                          mshr_proc_o.response    =   'd0                 ;
352        1/1                          mshr_proc_o.tag         =   mshr_entry_idx_i    ;
353        1/1                          case (mshr_entry.req_size)
354        1/1                              BYTE    :   mshr_proc_o.data    =   {56'b0,mshr_entry.req_data[mshr_entry.req_addr[2:0]+: 8]};
355        1/1                              HALF    :   mshr_proc_o.data    =   {48'b0,mshr_entry.req_data[mshr_entry.req_addr[2:0]+:16]};
356        1/1                              WORD    :   mshr_proc_o.data    =   {32'b0,mshr_entry.req_data[mshr_entry.req_addr[2:0]+:32]};
357        1/1                              DOUBLE  :   mshr_proc_o.data    =   mshr_entry.req_data;
358        0/1     ==>                      default :   mshr_proc_o.data    =   mshr_entry.req_data;
359                                     endcase
360                                 end
                        MISSING_DEFAULT
361                             endcase
362                         end
363                     
364                     // --------------------------------------------------------------------
365                     // cache_mem Interface
366                     // --------------------------------------------------------------------
367                         always_comb begin
368        1/1                  mshr_cache_mem_o.req_cmd        =   REQ_NONE;
369        1/1                  mshr_cache_mem_o.req_addr       =   'b0     ;
370        1/1                  mshr_cache_mem_o.req_data_in    =   'b0     ;
371        1/1                  case (mshr_entry.state)
372                                 ST_IDLE:    begin
373                                     // IF   the processor request is allocated to this entry
374        1/1                          if (dp_sel_i == 1'b1) begin
375        1/1                              case (proc2cache_i.command)
376                                             BUS_LOAD    :   begin
377        1/1                                      mshr_cache_mem_o.req_cmd        =   REQ_LOAD                        ;
378        1/1                                      mshr_cache_mem_o.req_addr       =   proc2cache_i.addr               ;
379        1/1                                      mshr_cache_mem_o.req_data_in    =   cache_mem_ctrl_i.req_data_out   ;
380                                             end
381                                             BUS_STORE   :   begin
382        1/1                                      mshr_cache_mem_o.req_cmd        =   REQ_STORE                       ;
383        1/1                                      mshr_cache_mem_o.req_addr       =   proc2cache_i.addr               ;
384        1/1                                      mshr_cache_mem_o.req_data_in    =   cache_mem_ctrl_i.req_data_out   ;
385        1/1                                      case (proc2cache_i.size)
386        1/1                                          BYTE    :   mshr_cache_mem_o.req_data_in[proc2cache_i.addr[2:0] +:  8]  =   proc2cache_i.data[ 7:0] ;
387        1/1                                          HALF    :   mshr_cache_mem_o.req_data_in[proc2cache_i.addr[2:0] +: 16]  =   proc2cache_i.data[15:0] ;
388        1/1                                          WORD    :   mshr_cache_mem_o.req_data_in[proc2cache_i.addr[2:0] +: 32]  =   proc2cache_i.data[31:0] ;
389        1/1                                          DOUBLE  :   mshr_cache_mem_o.req_data_in                                =   proc2cache_i.data       ;
                   ==>  MISSING_DEFAULT
390                                                 endcase
391                                             end    
                        MISSING_DEFAULT
392                                         endcase
393                                     end
                        MISSING_ELSE
394                                 end
395                                 ST_UPDATE:  begin
396        1/1                          if (mshr_entry.cmd == BUS_LOAD) begin
397        1/1                              mshr_cache_mem_o.req_cmd    =   REQ_LOAD_MISS       ;
398                                     end else begin
399        1/1                              mshr_cache_mem_o.req_cmd    =   REQ_STORE_MISS      ;
400                                     end
401        1/1                          mshr_cache_mem_o.req_addr       =   mshr_entry.req_addr ;
402        1/1                          mshr_cache_mem_o.req_data_in    =   mshr_entry.req_data ;
403                                 end
                        MISSING_DEFAULT
404                             endcase
405                         end
406                     
407                     // --------------------------------------------------------------------
408                     // Memory Interface
409                     // --------------------------------------------------------------------
410                         always_comb begin
411        1/1                  mshr_memory_o.addr      =   {mshr_entry.req_addr[C_XLEN-1:C_CACHE_OFFSET_WIDTH], {C_CACHE_OFFSET_WIDTH{1'b0}}};
412        1/1                  mshr_memory_o.size      =   DOUBLE              ;
413        1/1                  mshr_memory_o.command   =   BUS_NONE            ;
414        1/1                  mshr_memory_o.data      =   'd0 ;
415        1/1                  case (mshr_entry.state)
416                                 ST_RD_MEM   :   begin
417        1/1                          mshr_memory_o.data      =   'd0 ;
418        1/1                          mshr_memory_o.addr      =   {mshr_entry.req_addr[C_XLEN-1:C_CACHE_OFFSET_WIDTH], {C_CACHE_OFFSET_WIDTH{1'b0}}};
419        1/1                          mshr_memory_o.command   =   BUS_LOAD;
420                                 end
421                                 ST_EVICT    :   begin
422        1/1                          mshr_memory_o.data      =   mshr_entry.evict_data;
423        1/1                          mshr_memory_o.addr      =   {mshr_entry.evict_addr[C_XLEN-1:C_CACHE_OFFSET_WIDTH], {C_CACHE_OFFSET_WIDTH{1'b0}}};
424        1/1                          mshr_memory_o.command   =   BUS_STORE;
425                                 end
                        MISSING_DEFAULT

-------------------------------------------------------------------------------
Toggle Coverage for Instance : cache_tb.dut.cache_ctrl_inst.genblk1[1].mshr_entry_ctrl_inst
                Total Covered Percent 
Totals          72    47      65.28   
Total Bits      4844  4029    83.18   
Total Bits 0->1 2422  2014    83.15   
Total Bits 1->0 2422  2015    83.20   

                                
Ports          48   29   60.42  
Port Bits      3878 3207 82.70  
Port Bits 0->1 1939 1603 82.67  
Port Bits 1->0 1939 1604 82.72  

                                
Signals          24  18  75.00  
Signal Bits      966 822 85.09  
Signal Bits 0->1 483 411 85.09  
Signal Bits 1->0 483 411 85.09  

Port Details
                                     Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i                                Yes    Yes         Yes         INPUT     
rst_i                                No     Yes         No          INPUT     
mshr_entry_idx_i[3:0]                No     No          No          INPUT     
mshr_entry_o.mem_tag[3:0]            Yes    Yes         Yes         OUTPUT    
mshr_entry_o.linked                  No     No          No          OUTPUT    
mshr_entry_o.link_idx[2:0]           Yes    Yes         Yes         OUTPUT    
mshr_entry_o.link_idx[3]             No     No          No          OUTPUT    
mshr_entry_o.evict_dirty             Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_data[63:0]        Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_addr[2:0]         No     No          No          OUTPUT    
mshr_entry_o.evict_addr[15:3]        Yes    Yes         Yes         OUTPUT    
mshr_entry_o.evict_addr[31:16]       No     No          No          OUTPUT    
mshr_entry_o.req_size[1:0]           Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_data[63:0]          Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_addr[15:0]          Yes    Yes         Yes         OUTPUT    
mshr_entry_o.req_addr[31:16]         No     No          No          OUTPUT    
mshr_entry_o.cmd[1:0]                Yes    Yes         Yes         OUTPUT    
mshr_entry_o.state[2:0]              Yes    Yes         Yes         OUTPUT    
proc_grant_i                         Yes    Yes         Yes         INPUT     
proc2cache_i.command[1:0]            Yes    Yes         Yes         INPUT     
proc2cache_i.size[1:0]               Yes    Yes         Yes         INPUT     
proc2cache_i.data[63:0]              Yes    Yes         Yes         INPUT     
proc2cache_i.addr[15:0]              Yes    Yes         Yes         INPUT     
proc2cache_i.addr[31:16]             No     No          No          INPUT     
mshr_proc_o.tag[0]                   Yes    Yes         Yes         OUTPUT    
mshr_proc_o.tag[3:1]                 No     No          No          OUTPUT    
mshr_proc_o.data[4:0]                Yes    Yes         Yes         OUTPUT    
mshr_proc_o.data[5]                  No     No          No          OUTPUT    
mshr_proc_o.data[9:6]                Yes    Yes         Yes         OUTPUT    
mshr_proc_o.data[10]                 No     No          No          OUTPUT    
mshr_proc_o.data[18:11]              Yes    Yes         Yes         OUTPUT    
mshr_proc_o.data[19]                 No     No          No          OUTPUT    
mshr_proc_o.data[23:20]              Yes    Yes         Yes         OUTPUT    
mshr_proc_o.data[25:24]              No     No          No          OUTPUT    
mshr_proc_o.data[26]                 Yes    Yes         Yes         OUTPUT    
mshr_proc_o.data[29:27]              No     No          No          OUTPUT    
mshr_proc_o.data[30]                 Yes    Yes         Yes         OUTPUT    
mshr_proc_o.data[63:31]              No     No          No          OUTPUT    
mshr_proc_o.response[0]              Yes    Yes         Yes         OUTPUT    
mshr_proc_o.response[3:1]            No     No          No          OUTPUT    
cache_mem_grant_i                    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.evict_data[63:0]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.evict_addr[2:0]     No     No          No          INPUT     
cache_mem_ctrl_i.evict_addr[15:3]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.evict_addr[31:16]   No     No          No          INPUT     
cache_mem_ctrl_i.evict_dirty         Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[4:0]   Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[6:5]   No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[8:7]   Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[11:9]  No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[13:12] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[15:14] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[25:16] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[26]    No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[31:27] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[33:32] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[34]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[37:35] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[38]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[41:39] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[42]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[45:43] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[47:46] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[50:48] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[52:51] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[54:53] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[58:55] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[60:59] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[63:61] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_hit             Yes    Yes         Yes         INPUT     
mshr_cache_mem_o.req_data_in[63:0]   Yes    Yes         Yes         OUTPUT    
mshr_cache_mem_o.req_addr[15:0]      Yes    Yes         Yes         OUTPUT    
mshr_cache_mem_o.req_addr[31:16]     No     No          No          OUTPUT    
mshr_cache_mem_o.req_cmd[2:0]        Yes    Yes         Yes         OUTPUT    
memory_grant_i                       Yes    Yes         Yes         INPUT     
mem2cache_i.tag[3:0]                 Yes    Yes         Yes         INPUT     
mem2cache_i.data[63:0]               Yes    Yes         Yes         INPUT     
mem2cache_i.response[3:0]            Yes    Yes         Yes         INPUT     
mshr_memory_o.command[1:0]           Yes    Yes         Yes         OUTPUT    
mshr_memory_o.size[1:0]              No     No          No          OUTPUT    
mshr_memory_o.data[63:0]             Yes    Yes         Yes         OUTPUT    
mshr_memory_o.addr[2:0]              No     No          No          OUTPUT    
mshr_memory_o.addr[15:3]             Yes    Yes         Yes         OUTPUT    
mshr_memory_o.addr[31:16]            No     No          No          OUTPUT    
mshr_hit_i                           Yes    Yes         Yes         INPUT     
mshr_hit_idx_i[3:0]                  Yes    Yes         Yes         INPUT     
evict_hit_i                          No     No          No          INPUT     
evict_hit_idx_i[3:0]                 No     No          No          INPUT     
dp_sel_i                             Yes    Yes         Yes         INPUT     
mshr_cp_flag_o                       Yes    Yes         Yes         OUTPUT    
mshr_cp_data_o[63:0]                 Yes    Yes         Yes         OUTPUT    
cp_flag_i[0]                         No     No          No          INPUT     
cp_flag_i[15:1]                      Yes    Yes         Yes         INPUT     
cp_data_i[8:1][63:0]                 Yes    Yes         Yes         INPUT     
cp_data_i[9][44:0]                   Yes    Yes         Yes         INPUT     
cp_data_i[9][63:46]                  Yes    Yes         Yes         INPUT     
cp_data_i[10][30:1]                  Yes    Yes         Yes         INPUT     
cp_data_i[10][36:32]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][41:40]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][45]                    Yes    Yes         Yes         INPUT     
cp_data_i[10][49:47]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][52:51]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][56:55]                 Yes    Yes         Yes         INPUT     
cp_data_i[10][60]                    Yes    Yes         Yes         INPUT     
cp_data_i[10][62]                    Yes    Yes         Yes         INPUT     
cp_data_i[11][27:0]                  Yes    Yes         Yes         INPUT     
cp_data_i[11][36:29]                 Yes    Yes         Yes         INPUT     
cp_data_i[11][49:39]                 Yes    Yes         Yes         INPUT     
cp_data_i[11][51]                    Yes    Yes         Yes         INPUT     
cp_data_i[11][59:54]                 Yes    Yes         Yes         INPUT     
cp_data_i[11][63:62]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][4:0]                   Yes    Yes         Yes         INPUT     
cp_data_i[12][27:6]                  Yes    Yes         Yes         INPUT     
cp_data_i[12][31:29]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][35:33]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][39]                    Yes    Yes         Yes         INPUT     
cp_data_i[12][44:43]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][48:46]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][50]                    Yes    Yes         Yes         INPUT     
cp_data_i[12][54]                    Yes    Yes         Yes         INPUT     
cp_data_i[12][58:57]                 Yes    Yes         Yes         INPUT     
cp_data_i[12][61]                    Yes    Yes         Yes         INPUT     
cp_data_i[13][17:0]                  Yes    Yes         Yes         INPUT     
cp_data_i[13][46:19]                 Yes    Yes         Yes         INPUT     
cp_data_i[13][49]                    Yes    Yes         Yes         INPUT     
cp_data_i[13][56:51]                 Yes    Yes         Yes         INPUT     
cp_data_i[13][63:58]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][14:1]                  Yes    Yes         Yes         INPUT     
cp_data_i[14][19:16]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][21]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][24:23]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][27]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][32:30]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][37:35]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][39]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][41]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][43]                    Yes    Yes         Yes         INPUT     
cp_data_i[14][46:45]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][51:49]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][59:53]                 Yes    Yes         Yes         INPUT     
cp_data_i[14][62:61]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][15:0]                  Yes    Yes         Yes         INPUT     
cp_data_i[15][37:17]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][40:39]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][42]                    Yes    Yes         Yes         INPUT     
cp_data_i[15][45:44]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][48:47]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][53:51]                 Yes    Yes         Yes         INPUT     
cp_data_i[15][55]                    Yes    Yes         Yes         INPUT     
cp_data_i[15][63:57]                 Yes    Yes         Yes         INPUT     
Other bits of cp_data_i[15:0][63:0]  No     No          No          INPUT     

Signal Details
                                  Toggle Toggle 1->0 Toggle 0->1 
mshr_entry.mem_tag[3:0]           Yes    Yes         Yes         
mshr_entry.linked                 No     No          No          
mshr_entry.link_idx[2:0]          Yes    Yes         Yes         
mshr_entry.link_idx[3]            No     No          No          
mshr_entry.evict_dirty            Yes    Yes         Yes         
mshr_entry.evict_data[63:0]       Yes    Yes         Yes         
mshr_entry.evict_addr[2:0]        No     No          No          
mshr_entry.evict_addr[15:3]       Yes    Yes         Yes         
mshr_entry.evict_addr[31:16]      No     No          No          
mshr_entry.req_size[1:0]          Yes    Yes         Yes         
mshr_entry.req_data[63:0]         Yes    Yes         Yes         
mshr_entry.req_addr[15:0]         Yes    Yes         Yes         
mshr_entry.req_addr[31:16]        No     No          No          
mshr_entry.cmd[1:0]               Yes    Yes         Yes         
mshr_entry.state[2:0]             Yes    Yes         Yes         
next_mshr_entry.mem_tag[3:0]      Yes    Yes         Yes         
next_mshr_entry.linked            Yes    Yes         Yes         
next_mshr_entry.link_idx[3:0]     Yes    Yes         Yes         
next_mshr_entry.evict_dirty       Yes    Yes         Yes         
next_mshr_entry.evict_data[63:0]  Yes    Yes         Yes         
next_mshr_entry.evict_addr[2:0]   No     No          No          
next_mshr_entry.evict_addr[15:3]  Yes    Yes         Yes         
next_mshr_entry.evict_addr[31:16] No     No          No          
next_mshr_entry.req_size[1:0]     Yes    Yes         Yes         
next_mshr_entry.req_data[63:0]    Yes    Yes         Yes         
next_mshr_entry.req_addr[15:0]    Yes    Yes         Yes         
next_mshr_entry.req_addr[31:16]   No     No          No          
next_mshr_entry.cmd[1:0]          Yes    Yes         Yes         
next_mshr_entry.state[2:0]        Yes    Yes         Yes         
next_mshr_cp_flag                 Yes    Yes         Yes         
next_mshr_cp_data[63:0]           Yes    Yes         Yes         


===============================================================================
Module : cache_mem
===============================================================================
SCORE  LINE   TOGGLE 
 91.91 100.00  83.82 

Source File(s) : 

/afs/umich.edu/user/z/t/ztguan/group6w22/verilog/cache_mem.sv

Module self-instances :

SCORE  LINE   TOGGLE NAME                        
 91.91 100.00  83.82 cache_tb.dut.cache_mem_inst 



-------------------------------------------------------------------------------
Line Coverage for Module : cache_mem

             Line No.   Total   Covered  Percent
TOTAL                       75       75   100.00
ALWAYS            102        7        7   100.00
ALWAYS            118       62       62   100.00
ALWAYS            252        3        3   100.00
ALWAYS            266        3        3   100.00

101                         always_comb begin
102        1/1                  empty_way_valid =   1'b0    ;
103        1/1                  empty_way_idx   =   'd0     ;
104        1/1                  for (int unsigned set_idx = 0; set_idx < C_CACHE_SET_NUM; set_idx++) begin
105        1/1                      for (int unsigned way_idx = 0; way_idx < C_CACHE_SASS; way_idx++) begin
106        1/1                          if (cache_array[set_idx][way_idx].valid == 1'b0) begin
107        1/1                              empty_way_valid[set_idx]    =   1'b1    ;
108        1/1                              empty_way_idx[set_idx]      =   way_idx ;
109                                     end
                        MISSING_ELSE
110                                 end
111                             end
112                         end
113                     
114                     // --------------------------------------------------------------------
115                     // Request Interface logic
116                     // --------------------------------------------------------------------
117                         always_comb begin 
118        1/1                  next_cache_array    =   cache_array ;
119        1/1                  cache_mem_ctrl_o    =   'd0         ;
120        1/1                  access              =   'b0         ;
121        1/1                  case(cache_ctrl_mem_i.req_cmd)
122                                 // IF   cach_ctrl requests a load
123                                 REQ_LOAD: begin
124                                     // IF   the tag of the cache block in mapped set matches the requested tag
125                                     // ->   a load hit is confirmed, output the block data and update LRU bits
126        1/1                          for (int way_idx = 0; way_idx < C_CACHE_SASS; way_idx++) begin 
127        1/1                              if (cache_array[mem_idx][way_idx].valid ==  1'b1 
128                                         && cache_array[mem_idx][way_idx].tag == mem_tag) begin 
129        1/1                                  cache_mem_ctrl_o.req_hit        =   1'b1                                ;
130        1/1                                  cache_mem_ctrl_o.req_data_out   =   cache_array[mem_idx][way_idx].data  ;
131        1/1                                  access[mem_idx][way_idx]        =   1'b1                                ; 
132                                         end
                        MISSING_ELSE
133                                     end
134                                 end
135                                 // IF   cach_ctrl request a store, check for hit and update LRU/dirty bits, request interface output data in the data array.
136                                 REQ_STORE: begin
137                                     // IF   the tag of the cache block in mapped set matches the requested tag
138                                     // ->   a store hit is confirmed, output the current block data, update LRU bits, 
139                                     //      write the new data and asserts the dirty bit.
140        1/1                          for (int way_idx = 0; way_idx < C_CACHE_SASS; way_idx++) begin 
141        1/1                              if (cache_array[mem_idx][way_idx].valid ==  1'b1 
142                                         && cache_array[mem_idx][way_idx].tag == mem_tag) begin 
143        1/1                                  cache_mem_ctrl_o.req_hit                    =   1'b1                                ;
144        1/1                                  cache_mem_ctrl_o.req_data_out               =   cache_array[mem_idx][way_idx].data  ;
145        1/1                                  next_cache_array[mem_idx][way_idx].data     =   cache_ctrl_mem_i.req_data_in        ;
146        1/1                                  next_cache_array[mem_idx][way_idx].dirty    =   1'b1                                ;
147        1/1                                  access[mem_idx][way_idx]                    =   1'b1                                ;
148                                         end
                        MISSING_ELSE
149                                     end
150                                 end
151                                 // IF   cach_ctrl requests a miss handling for load miss
152                                 REQ_LOAD_MISS: begin
153                                     // IF   the tag of the cache block in mapped set matches the requested tag
154                                     //      (meaning there is a previous miss handling that place the block in cache)
155                                     // ->   output the data in the hit block, update the LRU bits
156        1/1                          for (int way_idx = 0; way_idx < C_CACHE_SASS; way_idx++) begin 
157        1/1                              if (cache_array[mem_idx][way_idx].valid ==  1'b1 
158                                         && cache_array[mem_idx][way_idx].tag == mem_tag) begin 
159        1/1                                  cache_mem_ctrl_o.req_hit        =   1'b1                                ;
160        1/1                                  cache_mem_ctrl_o.req_data_out   =   cache_array[mem_idx][way_idx].data  ;
161        1/1                                  access[mem_idx][way_idx]        =   1'b1                                ;
162                                         end
                        MISSING_ELSE
163                                     end
164                     
165                                     // IF   the block is still a miss
166                                     //      Meaning there is no previous miss handling to this address
167        1/1                          if (cache_mem_ctrl_o.req_hit == 1'b0) begin
168                                         // IF   there is a empty way in the mapped set
169                                         // ->   Write the data into the way
170        1/1                              if (empty_way_valid[mem_idx] == 1'b1) begin
171        1/1                                  next_cache_array[mem_idx][empty_way_idx[mem_idx]].valid =   1'b1;
172        1/1                                  next_cache_array[mem_idx][empty_way_idx[mem_idx]].data  =   cache_ctrl_mem_i.req_data_in;
173        1/1                                  next_cache_array[mem_idx][empty_way_idx[mem_idx]].tag   =   mem_tag;
174        1/1                                  next_cache_array[mem_idx][empty_way_idx[mem_idx]].dirty =   1'b1;
175        1/1                                  access[mem_idx][empty_way_idx[mem_idx]]                 =   1'b1;
176                                         // ELSE there is no empty way in the mapped set
177                                         end else begin
178        1/1                                  for (int way_idx = 0; way_idx < C_CACHE_SASS; way_idx++) begin 
179                                                 // Pick the Least-Recently-Used way to evict
180        1/1                                      if (cache_array[mem_idx][way_idx].lru == 1'b1) begin
181                                                     // Output its current data to the cache_ctrl
182        1/1                                          cache_mem_ctrl_o.evict_dirty                =   1'b1;
183        1/1                                          cache_mem_ctrl_o.evict_data                 =   cache_array[mem_idx][way_idx].data;
184        1/1                                          cache_mem_ctrl_o.evict_addr                 =   {cache_array[mem_idx][way_idx].tag, mem_idx, {C_CACHE_OFFSET_WIDTH{1'b0}}};
185                                                     // Write the new data from cache_ctrl into the way
186        1/1                                          next_cache_array[mem_idx][way_idx].valid    =   1'b1;
187        1/1                                          next_cache_array[mem_idx][way_idx].data     =   cache_ctrl_mem_i.req_data_in;
188        1/1                                          next_cache_array[mem_idx][way_idx].tag      =   mem_tag;
189        1/1                                          next_cache_array[mem_idx][way_idx].dirty    =   1'b0;
190                                                 end
                        MISSING_ELSE
191                                             end
192                                         end
193                                     end
                        MISSING_ELSE
194                                 end
195                                 // IF   cach_ctrl requests a miss handling for store miss
196                                 REQ_STORE_MISS: begin     
197                                     // IF   the tag of the cache block in mapped set matches the requested tag
198                                     //      (meaning there is a previous miss handling that place the block in cache)
199                                     // ->   output the data in the hit block, update the LRU bits
200        1/1                          for (int way_idx = 0; way_idx < C_CACHE_SASS; way_idx++) begin 
201        1/1                              if (cache_array[mem_idx][way_idx].valid ==  1'b1 
202                                         && cache_array[mem_idx][way_idx].tag == mem_tag) begin  
203        1/1                                  cache_mem_ctrl_o.req_hit                =   1'b1                                ;
204        1/1                                  cache_mem_ctrl_o.req_data_out           =   cache_array[mem_idx][way_idx].data  ;
205        1/1                                  next_cache_array[mem_idx][way_idx].data =   cache_ctrl_mem_i.req_data_in        ;
206        1/1                                  access[mem_idx][way_idx]                =   1'b1                                ;
207                                         end
                        MISSING_ELSE
208                                     end
209                     
210                                     // IF   the block is still a miss
211                                     //      Meaning there is no previous miss handling to this address
212        1/1                          if (cache_mem_ctrl_o.req_hit == 1'b0) begin
213                                         // IF   there is a empty way in the mapped set
214                                         // ->   Write the data into the way
215        1/1                              if (empty_way_valid[mem_idx] == 1'b1) begin
216        1/1                                  next_cache_array[mem_idx][empty_way_idx[mem_idx]].valid =   1'b1;
217        1/1                                  next_cache_array[mem_idx][empty_way_idx[mem_idx]].data  =   cache_ctrl_mem_i.req_data_in;
218        1/1                                  next_cache_array[mem_idx][empty_way_idx[mem_idx]].tag   =   mem_tag;
219        1/1                                  next_cache_array[mem_idx][empty_way_idx[mem_idx]].dirty =   1'b1;
220        1/1                                  access[mem_idx][empty_way_idx[mem_idx]]                 =   1'b1;
221                                         // ELSE there is no empty way in the mapped set
222                                         end else begin
223        1/1                                  for (int way_idx = 0; way_idx < C_CACHE_SASS; way_idx++) begin 
224                                                 // Pick the Least-Recently-Used way to evict
225        1/1                                      if (cache_array[mem_idx][way_idx].lru == 1'b1) begin
226                                                     // Output its current data to the cache_ctrl
227        1/1                                          cache_mem_ctrl_o.evict_dirty                =   1'b1;
228        1/1                                          cache_mem_ctrl_o.evict_data                 =   cache_array[mem_idx][way_idx].data;
229        1/1                                          cache_mem_ctrl_o.evict_addr                 =   {cache_array[mem_idx][way_idx].tag, mem_idx, {C_CACHE_OFFSET_WIDTH{1'b0}}};
230                                                     // Write the new data from cache_ctrl into the way
231        1/1                                          next_cache_array[mem_idx][way_idx].valid    =   1'b1;
232        1/1                                          next_cache_array[mem_idx][way_idx].data     =   cache_ctrl_mem_i.req_data_in;
233        1/1                                          next_cache_array[mem_idx][way_idx].tag      =   mem_tag;
234        1/1                                          next_cache_array[mem_idx][way_idx].dirty    =   1'b0;
235                                                 end
                        MISSING_ELSE
236                                             end
237                                         end
238                                     end
                        MISSING_ELSE
239                                 end
                        MISSING_DEFAULT
240                             endcase
241                     
242                             // Next LRU bits
243        1/1                  for (int unsigned set_idx = 0; set_idx < C_CACHE_SET_NUM; set_idx++) begin
244        1/1                      for (int unsigned way_idx = 0; way_idx < C_CACHE_SASS; way_idx++) begin
245        1/1                          next_cache_array[set_idx][way_idx].lru  =   next_lru[set_idx][way_idx];
246                                 end
247                             end
248                         end
249                     
250                         // Update the cache memory
251                         always_ff @(posedge clk_i) begin    // initialize the data array and control array.  
252        1/1                  if (rst_i) begin 
253        1/1                      cache_array <= `SD 'b0;
254                             end else begin 
255        1/1                      cache_array <= `SD next_cache_array;
256                             end 
257                         end
258                     
259                     // --------------------------------------------------------------------
260                     // Use history updates
261                     // --------------------------------------------------------------------
262                         always_ff @(posedge clk_i) begin
263                             // Reset
264                             // The timelapse from the most recent use
265                             // 0 < 1 < ... < (C_CACHE_SASS-1) (LRU)
266        1/1                  if (rst_i) begin 
267        1/1                      use_history <=  `SD 'b0;
268                             // Update use history
269                             end else begin 
270        1/1                      use_history <=  `SD next_use_history;

-------------------------------------------------------------------------------
Toggle Coverage for Module : cache_mem
                Total Covered Percent 
Totals          19    14      73.68   
Total Bits      958   803     83.82   
Total Bits 0->1 479   401     83.72   
Total Bits 1->0 479   402     83.92   

                              
Ports          10  6   60.00  
Port Bits      526 403 76.62  
Port Bits 0->1 263 201 76.43  
Port Bits 1->0 263 202 76.81  

                                
Signals          9   8   88.89  
Signal Bits      432 400 92.59  
Signal Bits 0->1 216 200 92.59  
Signal Bits 1->0 216 200 92.59  

Port Details
                                     Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i                                Yes    Yes         Yes         INPUT     
rst_i                                No     Yes         No          INPUT     
cache_ctrl_mem_i.req_data_in[63:0]   Yes    Yes         Yes         INPUT     
cache_ctrl_mem_i.req_addr[15:0]      Yes    Yes         Yes         INPUT     
cache_ctrl_mem_i.req_addr[31:16]     No     No          No          INPUT     
cache_ctrl_mem_i.req_cmd[2:0]        Yes    Yes         Yes         INPUT     
cache_mem_ctrl_o.evict_data[63:0]    Yes    Yes         Yes         OUTPUT    
cache_mem_ctrl_o.evict_addr[2:0]     No     No          No          OUTPUT    
cache_mem_ctrl_o.evict_addr[15:3]    Yes    Yes         Yes         OUTPUT    
cache_mem_ctrl_o.evict_addr[31:16]   No     No          No          OUTPUT    
cache_mem_ctrl_o.evict_dirty         Yes    Yes         Yes         OUTPUT    
cache_mem_ctrl_o.req_data_out[4:0]   Yes    Yes         Yes         OUTPUT    
cache_mem_ctrl_o.req_data_out[6:5]   No     No          No          OUTPUT    
cache_mem_ctrl_o.req_data_out[8:7]   Yes    Yes         Yes         OUTPUT    
cache_mem_ctrl_o.req_data_out[11:9]  No     No          No          OUTPUT    
cache_mem_ctrl_o.req_data_out[13:12] Yes    Yes         Yes         OUTPUT    
cache_mem_ctrl_o.req_data_out[15:14] No     No          No          OUTPUT    
cache_mem_ctrl_o.req_data_out[25:16] Yes    Yes         Yes         OUTPUT    
cache_mem_ctrl_o.req_data_out[26]    No     No          No          OUTPUT    
cache_mem_ctrl_o.req_data_out[31:27] Yes    Yes         Yes         OUTPUT    
cache_mem_ctrl_o.req_data_out[33:32] No     No          No          OUTPUT    
cache_mem_ctrl_o.req_data_out[34]    Yes    Yes         Yes         OUTPUT    
cache_mem_ctrl_o.req_data_out[37:35] No     No          No          OUTPUT    
cache_mem_ctrl_o.req_data_out[38]    Yes    Yes         Yes         OUTPUT    
cache_mem_ctrl_o.req_data_out[41:39] No     No          No          OUTPUT    
cache_mem_ctrl_o.req_data_out[42]    Yes    Yes         Yes         OUTPUT    
cache_mem_ctrl_o.req_data_out[45:43] No     No          No          OUTPUT    
cache_mem_ctrl_o.req_data_out[47:46] Yes    Yes         Yes         OUTPUT    
cache_mem_ctrl_o.req_data_out[50:48] No     No          No          OUTPUT    
cache_mem_ctrl_o.req_data_out[52:51] Yes    Yes         Yes         OUTPUT    
cache_mem_ctrl_o.req_data_out[54:53] No     No          No          OUTPUT    
cache_mem_ctrl_o.req_data_out[58:55] Yes    Yes         Yes         OUTPUT    
cache_mem_ctrl_o.req_data_out[60:59] No     No          No          OUTPUT    
cache_mem_ctrl_o.req_data_out[63:61] Yes    Yes         Yes         OUTPUT    
cache_mem_ctrl_o.req_hit             Yes    Yes         Yes         OUTPUT    

Signal Details
                           Toggle Toggle 1->0 Toggle 0->1 
mem_blk_offset[2:0]        Yes    Yes         Yes         
mem_idx[2:0]               Yes    Yes         Yes         
mem_tag[9:0]               Yes    Yes         Yes         
mem_tag[25:10]             No     No          No          
use_history[7:0][5:0]      Yes    Yes         Yes         
next_use_history[7:0][5:0] Yes    Yes         Yes         
next_lru[7:0][3:0]         Yes    Yes         Yes         
access[7:0][3:0]           Yes    Yes         Yes         
empty_way_valid[7:0]       Yes    Yes         Yes         
empty_way_idx[7:0][1:0]    Yes    Yes         Yes         


-------------------------------------------------------------------------------
===============================================================================
Module Instance : cache_tb.dut.cache_mem_inst
===============================================================================

Instance :

SCORE  LINE   TOGGLE 
 91.91 100.00  83.82 


Instance's subtree :

SCORE  LINE   TOGGLE 
 93.94 100.00  87.87 


Module : 

SCORE  LINE   TOGGLE NAME      
 91.91 100.00  83.82 cache_mem 


Parent : 

SCORE  LINE   TOGGLE NAME 
 81.99 --      81.99 dut  


Subtrees :

SCORE  LINE   TOGGLE NAME                       
100.00 100.00 100.00 genblk1[0].LRU_update_inst 
100.00 100.00 100.00 genblk1[1].LRU_update_inst 
100.00 100.00 100.00 genblk1[2].LRU_update_inst 
100.00 100.00 100.00 genblk1[3].LRU_update_inst 
100.00 100.00 100.00 genblk1[4].LRU_update_inst 
100.00 100.00 100.00 genblk1[5].LRU_update_inst 
100.00 100.00 100.00 genblk1[6].LRU_update_inst 
100.00 100.00 100.00 genblk1[7].LRU_update_inst 



-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : cache_ctrl
===============================================================================
SCORE  LINE   TOGGLE 
 92.38 100.00  84.76 

Source File(s) : 

/afs/umich.edu/user/z/t/ztguan/group6w22/verilog/cache_ctrl.sv

Module self-instances :

SCORE  LINE   TOGGLE NAME                         
 92.38 100.00  84.76 cache_tb.dut.cache_ctrl_inst 



-------------------------------------------------------------------------------
Line Coverage for Module : cache_ctrl

             Line No.   Total   Covered  Percent
TOTAL                        6        6   100.00
ALWAYS            200        6        6   100.00

199                         always_comb begin
200        1/1                  mshr_array[0]       =   'd0 ;
201        1/1                  mshr_memory[0]      =   'd0 ;
202        1/1                  mshr_proc[0]        =   'd0 ;
203        1/1                  mshr_cache_mem[0]   =   'd0 ;
204        1/1                  cp_data[0]          =   'b0 ;
205        1/1                  cp_flag[0]          =   1'b0;

-------------------------------------------------------------------------------
Toggle Coverage for Module : cache_ctrl
                Total Covered Percent 
Totals          35    19      54.29   
Total Bits      3444  2919    84.76   
Total Bits 0->1 1722  1459    84.73   
Total Bits 1->0 1722  1460    84.79   

                               
Ports          25   17  68.00  
Port Bits      1216 997 81.99  
Port Bits 0->1 608  498 81.91  
Port Bits 1->0 608  499 82.07  

                                  
Signals          10   2    20.00  
Signal Bits      2228 1922 86.27  
Signal Bits 0->1 1114 961  86.27  
Signal Bits 1->0 1114 961  86.27  

Port Details
                                     Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i                                Yes    Yes         Yes         INPUT     
rst_i                                No     Yes         No          INPUT     
proc2cache_i.command[1:0]            Yes    Yes         Yes         INPUT     
proc2cache_i.size[1:0]               Yes    Yes         Yes         INPUT     
proc2cache_i.data[63:0]              Yes    Yes         Yes         INPUT     
proc2cache_i.addr[15:0]              Yes    Yes         Yes         INPUT     
proc2cache_i.addr[31:16]             No     No          No          INPUT     
cache2proc_o.tag[3:0]                Yes    Yes         Yes         OUTPUT    
cache2proc_o.data[18:0]              Yes    Yes         Yes         OUTPUT    
cache2proc_o.data[19]                No     No          No          OUTPUT    
cache2proc_o.data[24:20]             Yes    Yes         Yes         OUTPUT    
cache2proc_o.data[25]                No     No          No          OUTPUT    
cache2proc_o.data[33:26]             Yes    Yes         Yes         OUTPUT    
cache2proc_o.data[34]                No     No          No          OUTPUT    
cache2proc_o.data[41:35]             Yes    Yes         Yes         OUTPUT    
cache2proc_o.data[43:42]             No     No          No          OUTPUT    
cache2proc_o.data[44]                Yes    Yes         Yes         OUTPUT    
cache2proc_o.data[46:45]             No     No          No          OUTPUT    
cache2proc_o.data[49:47]             Yes    Yes         Yes         OUTPUT    
cache2proc_o.data[51:50]             No     No          No          OUTPUT    
cache2proc_o.data[54:52]             Yes    Yes         Yes         OUTPUT    
cache2proc_o.data[55]                No     No          No          OUTPUT    
cache2proc_o.data[58:56]             Yes    Yes         Yes         OUTPUT    
cache2proc_o.data[59]                No     No          No          OUTPUT    
cache2proc_o.data[62:60]             Yes    Yes         Yes         OUTPUT    
cache2proc_o.data[63]                No     No          No          OUTPUT    
cache2proc_o.response[3:0]           Yes    Yes         Yes         OUTPUT    
memory_enable_i                      No     No          No          INPUT     
cache2mem_o.command[1:0]             Yes    Yes         Yes         OUTPUT    
cache2mem_o.size[1:0]                Yes    Yes         Yes         OUTPUT    
cache2mem_o.data[63:0]               Yes    Yes         Yes         OUTPUT    
cache2mem_o.addr[2:0]                No     No          No          OUTPUT    
cache2mem_o.addr[15:3]               Yes    Yes         Yes         OUTPUT    
cache2mem_o.addr[31:16]              No     No          No          OUTPUT    
mem2cache_i.tag[3:0]                 Yes    Yes         Yes         INPUT     
mem2cache_i.data[63:0]               Yes    Yes         Yes         INPUT     
mem2cache_i.response[3:0]            Yes    Yes         Yes         INPUT     
cache_ctrl_mem_o.req_data_in[63:0]   Yes    Yes         Yes         OUTPUT    
cache_ctrl_mem_o.req_addr[15:0]      Yes    Yes         Yes         OUTPUT    
cache_ctrl_mem_o.req_addr[31:16]     No     No          No          OUTPUT    
cache_ctrl_mem_o.req_cmd[2:0]        Yes    Yes         Yes         OUTPUT    
cache_mem_ctrl_i.evict_data[63:0]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.evict_addr[2:0]     No     No          No          INPUT     
cache_mem_ctrl_i.evict_addr[15:3]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.evict_addr[31:16]   No     No          No          INPUT     
cache_mem_ctrl_i.evict_dirty         Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[4:0]   Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[6:5]   No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[8:7]   Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[11:9]  No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[13:12] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[15:14] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[25:16] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[26]    No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[31:27] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[33:32] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[34]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[37:35] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[38]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[41:39] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[42]    Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[45:43] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[47:46] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[50:48] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[52:51] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[54:53] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[58:55] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_data_out[60:59] No     No          No          INPUT     
cache_mem_ctrl_i.req_data_out[63:61] Yes    Yes         Yes         INPUT     
cache_mem_ctrl_i.req_hit             Yes    Yes         Yes         INPUT     

Signal Details
                                  Toggle Toggle 1->0 Toggle 0->1 
dp_sel[0]                         No     No          No          
dp_sel[15:1]                      Yes    Yes         Yes         
cp_flag[0]                        No     No          No          
cp_flag[15:1]                     Yes    Yes         Yes         
cp_data[8:1][63:0]                Yes    Yes         Yes         
cp_data[9][44:0]                  Yes    Yes         Yes         
cp_data[9][63:46]                 Yes    Yes         Yes         
cp_data[10][30:1]                 Yes    Yes         Yes         
cp_data[10][36:32]                Yes    Yes         Yes         
cp_data[10][41:40]                Yes    Yes         Yes         
cp_data[10][45]                   Yes    Yes         Yes         
cp_data[10][49:47]                Yes    Yes         Yes         
cp_data[10][52:51]                Yes    Yes         Yes         
cp_data[10][56:55]                Yes    Yes         Yes         
cp_data[10][60]                   Yes    Yes         Yes         
cp_data[10][62]                   Yes    Yes         Yes         
cp_data[11][27:0]                 Yes    Yes         Yes         
cp_data[11][36:29]                Yes    Yes         Yes         
cp_data[11][49:39]                Yes    Yes         Yes         
cp_data[11][51]                   Yes    Yes         Yes         
cp_data[11][59:54]                Yes    Yes         Yes         
cp_data[11][63:62]                Yes    Yes         Yes         
cp_data[12][4:0]                  Yes    Yes         Yes         
cp_data[12][27:6]                 Yes    Yes         Yes         
cp_data[12][31:29]                Yes    Yes         Yes         
cp_data[12][35:33]                Yes    Yes         Yes         
cp_data[12][39]                   Yes    Yes         Yes         
cp_data[12][44:43]                Yes    Yes         Yes         
cp_data[12][48:46]                Yes    Yes         Yes         
cp_data[12][50]                   Yes    Yes         Yes         
cp_data[12][54]                   Yes    Yes         Yes         
cp_data[12][58:57]                Yes    Yes         Yes         
cp_data[12][61]                   Yes    Yes         Yes         
cp_data[13][17:0]                 Yes    Yes         Yes         
cp_data[13][46:19]                Yes    Yes         Yes         
cp_data[13][49]                   Yes    Yes         Yes         
cp_data[13][56:51]                Yes    Yes         Yes         
cp_data[13][63:58]                Yes    Yes         Yes         
cp_data[14][14:1]                 Yes    Yes         Yes         
cp_data[14][19:16]                Yes    Yes         Yes         
cp_data[14][21]                   Yes    Yes         Yes         
cp_data[14][24:23]                Yes    Yes         Yes         
cp_data[14][27]                   Yes    Yes         Yes         
cp_data[14][32:30]                Yes    Yes         Yes         
cp_data[14][37:35]                Yes    Yes         Yes         
cp_data[14][39]                   Yes    Yes         Yes         
cp_data[14][41]                   Yes    Yes         Yes         
cp_data[14][43]                   Yes    Yes         Yes         
cp_data[14][46:45]                Yes    Yes         Yes         
cp_data[14][51:49]                Yes    Yes         Yes         
cp_data[14][59:53]                Yes    Yes         Yes         
cp_data[14][62:61]                Yes    Yes         Yes         
cp_data[15][15:0]                 Yes    Yes         Yes         
cp_data[15][37:17]                Yes    Yes         Yes         
cp_data[15][40:39]                Yes    Yes         Yes         
cp_data[15][42]                   Yes    Yes         Yes         
cp_data[15][45:44]                Yes    Yes         Yes         
cp_data[15][48:47]                Yes    Yes         Yes         
cp_data[15][53:51]                Yes    Yes         Yes         
cp_data[15][55]                   Yes    Yes         Yes         
cp_data[15][63:57]                Yes    Yes         Yes         
Other bits of cp_data[15:0][63:0] No     No          No          
mshr_hit                          Yes    Yes         Yes         
mshr_hit_idx[3:0]                 Yes    Yes         Yes         
evict_hit                         No     No          No          
evict_hit_idx[3:0]                No     No          No          
proc_grant[0]                     No     No          No          
proc_grant[15:1]                  Yes    Yes         Yes         
memory_grant[0]                   No     No          No          
memory_grant[15:1]                Yes    Yes         Yes         
cache_mem_grant[0]                No     No          No          
cache_mem_grant[15:1]             Yes    Yes         Yes         


-------------------------------------------------------------------------------
===============================================================================
Module Instance : cache_tb.dut.cache_ctrl_inst
===============================================================================

Instance :

SCORE  LINE   TOGGLE 
 92.38 100.00  84.76 


Instance's subtree :

SCORE  LINE   TOGGLE 
 81.20  81.80  80.61 


Module : 

SCORE  LINE   TOGGLE NAME       
 92.38 100.00  84.76 cache_ctrl 


Parent : 

SCORE  LINE   TOGGLE NAME 
 81.99 --      81.99 dut  


Subtrees :

SCORE  LINE   TOGGLE NAME                             
 75.71  71.43  80.00 evict_hit_detector_inst          
 78.87  79.52  78.22 genblk1[10].mshr_entry_ctrl_inst 
 76.96  73.81  80.12 genblk1[11].mshr_entry_ctrl_inst 
 72.30  72.86  71.74 genblk1[12].mshr_entry_ctrl_inst 
 74.83  72.38  77.27 genblk1[13].mshr_entry_ctrl_inst 
 74.74  73.81  75.66 genblk1[14].mshr_entry_ctrl_inst 
 75.56  72.86  78.26 genblk1[15].mshr_entry_ctrl_inst 
 86.35  89.52  83.18 genblk1[1].mshr_entry_ctrl_inst  
 84.01  85.71  82.31 genblk1[2].mshr_entry_ctrl_inst  
 84.60  87.14  82.06 genblk1[3].mshr_entry_ctrl_inst  
 84.11  85.71  82.51 genblk1[4].mshr_entry_ctrl_inst  
 84.03  85.71  82.35 genblk1[5].mshr_entry_ctrl_inst  
 84.75  85.71  83.79 genblk1[6].mshr_entry_ctrl_inst  
 84.68  87.14  82.23 genblk1[7].mshr_entry_ctrl_inst  
 80.97  80.00  81.94 genblk1[8].mshr_entry_ctrl_inst  
 83.68  85.71  81.65 genblk1[9].mshr_entry_ctrl_inst  
 94.76 100.00  89.53 mshr_cache_mem_switch_inst       
 97.62 100.00  95.24 mshr_dispatch_selector_inst      
 92.38 100.00  84.76 mshr_hit_detector_inst           
 95.47 100.00  90.94 mshr_memory_switch_inst          
 95.41 100.00  90.82 mshr_proc_switch_inst            



-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : mshr_hit_detector
===============================================================================
SCORE  LINE   TOGGLE 
 92.38 100.00  84.76 

Source File(s) : 

/afs/umich.edu/user/z/t/ztguan/group6w22/verilog/mshr_hit_detector.sv

Module self-instances :

SCORE  LINE   TOGGLE NAME                                                
 92.38 100.00  84.76 cache_tb.dut.cache_ctrl_inst.mshr_hit_detector_inst 



-------------------------------------------------------------------------------
Line Coverage for Module : mshr_hit_detector

             Line No.   Total   Covered  Percent
TOTAL                        7        7   100.00
ALWAYS             34        7        7   100.00

33                          always_comb begin
34         1/1                  mshr_hit_o      =   1'b0;
35         1/1                  mshr_hit_idx_o  =   'd0;
36         1/1                  if (proc2cache_i.command != BUS_NONE) begin
37         1/1                      for (int unsigned entry_idx = 1; entry_idx < C_MSHR_ENTRY_NUM; entry_idx++) begin
38                                      // IF   the entry content is valid
39                                      // AND  the address from processor matches the address of current entry
40                                      // AND  current entry is the least older miss to this address
41                                      // ->   MSHR hit is detected
42         1/1                          if ((mshr_array_i[entry_idx].cmd != BUS_NONE)
43                                      &&  (mshr_array_i[entry_idx].req_addr[C_XLEN-1:C_CACHE_OFFSET_WIDTH] == proc2cache_i.addr[C_XLEN-1:C_CACHE_OFFSET_WIDTH])
44                                      &&  (mshr_array_i[entry_idx].linked == 1'b0)) begin
45         1/1                              mshr_hit_o      =   1'b1;
46         1/1                              mshr_hit_idx_o  =   entry_idx;
47                                      end
                        MISSING_ELSE
48                                  end
49                              end
                        MISSING_ELSE

-------------------------------------------------------------------------------
Toggle Coverage for Module : mshr_hit_detector
                Total Covered Percent 
Totals          6     5       83.33   
Total Bits      210   178     84.76   
Total Bits 0->1 105   89      84.76   
Total Bits 1->0 105   89      84.76   

                              
Ports          6   5   83.33  
Port Bits      210 178 84.76  
Port Bits 0->1 105 89  84.76  
Port Bits 1->0 105 89  84.76  

Port Details
                          Toggle Toggle 1->0 Toggle 0->1 Direction 
proc2cache_i.command[1:0] Yes    Yes         Yes         INPUT     
proc2cache_i.size[1:0]    Yes    Yes         Yes         INPUT     
proc2cache_i.data[63:0]   Yes    Yes         Yes         INPUT     
proc2cache_i.addr[15:0]   Yes    Yes         Yes         INPUT     
proc2cache_i.addr[31:16]  No     No          No          INPUT     
mshr_hit_o                Yes    Yes         Yes         OUTPUT    
mshr_hit_idx_o[3:0]       Yes    Yes         Yes         OUTPUT    


-------------------------------------------------------------------------------
===============================================================================
Module Instance : cache_tb.dut.cache_ctrl_inst.mshr_hit_detector_inst
===============================================================================

Instance :

SCORE  LINE   TOGGLE 
 92.38 100.00  84.76 


Instance's subtree :

SCORE  LINE   TOGGLE 
 92.38 100.00  84.76 


Module : 

SCORE  LINE   TOGGLE NAME              
 92.38 100.00  84.76 mshr_hit_detector 


Parent : 

SCORE  LINE   TOGGLE NAME            
 92.38 100.00  84.76 cache_ctrl_inst 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : mshr_cache_mem_switch
===============================================================================
SCORE  LINE   TOGGLE 
 93.35 100.00  86.69 

Source File(s) : 

/afs/umich.edu/user/z/t/ztguan/group6w22/verilog/mshr_cache_mem_switch.sv

Module self-instances :

SCORE  LINE   TOGGLE NAME                                                    
 93.35 100.00  86.69 cache_tb.dut.cache_ctrl_inst.mshr_cache_mem_switch_inst 



-------------------------------------------------------------------------------
Line Coverage for Module : mshr_cache_mem_switch

             Line No.   Total   Covered  Percent
TOTAL                       10       10   100.00
ALWAYS             65       10       10   100.00

64                              // Pick the MSHR entries with valid Memory requests
65         1/1                  arbiter_req =   'b0;
66         1/1                  for (int unsigned entry_idx = 1; entry_idx < C_MSHR_ENTRY_NUM; entry_idx++) begin
67         1/1                      if (mshr_cache_mem_i[entry_idx].req_cmd != REQ_NONE) begin
68         1/1                          arbiter_req[entry_idx]  =   1'b1;
69                                  end
                        MISSING_ELSE
70                              end
71                      
72                              // Generate acknowledge signal for arbiter to switch priority
73         1/1                  arbiter_ack     =   grant_valid;
74                      
75                              // Route the granted request to the Memory Interface
76                              // Output grant signals to the MSHR entries
77         1/1                  cache_ctrl_mem_o    =   'b0;
78         1/1                  cache_mem_grant_o   =   'b0;
79         1/1                  if (grant_valid) begin
80         1/1                      cache_ctrl_mem_o    =   mshr_cache_mem_i[grant_idx];
81         1/1                      cache_mem_grant_o   =   {{(C_MSHR_ENTRY_NUM-1){1'b0}}, 1'b1} << grant_idx;
82                              end
                        MISSING_ELSE

-------------------------------------------------------------------------------
Toggle Coverage for Module : mshr_cache_mem_switch
                Total Covered Percent 
Totals          10    6       60.00   
Total Bits      278   241     86.69   
Total Bits 0->1 139   120     86.33   
Total Bits 1->0 139   121     87.05   

                              
Ports          6   3   50.00  
Port Bits      234 199 85.04  
Port Bits 0->1 117 99  84.62  
Port Bits 1->0 117 100 85.47  

                              
Signals          4  3  75.00  
Signal Bits      44 42 95.45  
Signal Bits 0->1 22 21 95.45  
Signal Bits 1->0 22 21 95.45  

Port Details
                                   Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i                              Yes    Yes         Yes         INPUT     
rst_i                              No     Yes         No          INPUT     
cache_mem_grant_o[0]               No     No          No          OUTPUT    
cache_mem_grant_o[15:1]            Yes    Yes         Yes         OUTPUT    
cache_ctrl_mem_o.req_data_in[63:0] Yes    Yes         Yes         OUTPUT    
cache_ctrl_mem_o.req_addr[15:0]    Yes    Yes         Yes         OUTPUT    
cache_ctrl_mem_o.req_addr[31:16]   No     No          No          OUTPUT    
cache_ctrl_mem_o.req_cmd[2:0]      Yes    Yes         Yes         OUTPUT    

Signal Details
                  Toggle Toggle 1->0 Toggle 0->1 
arbiter_req[0]    No     No          No          
arbiter_req[15:1] Yes    Yes         Yes         
arbiter_ack       Yes    Yes         Yes         
grant_idx[3:0]    Yes    Yes         Yes         
grant_valid       Yes    Yes         Yes         


-------------------------------------------------------------------------------
===============================================================================
Module Instance : cache_tb.dut.cache_ctrl_inst.mshr_cache_mem_switch_inst
===============================================================================

Instance :

SCORE  LINE   TOGGLE 
 93.35 100.00  86.69 


Instance's subtree :

SCORE  LINE   TOGGLE 
 94.76 100.00  89.53 


Module : 

SCORE  LINE   TOGGLE NAME                  
 93.35 100.00  86.69 mshr_cache_mem_switch 


Parent : 

SCORE  LINE   TOGGLE NAME            
 92.38 100.00  84.76 cache_ctrl_inst 


Subtrees :

SCORE  LINE   TOGGLE NAME                 
 98.56 100.00  97.12 mshr_rr_arbiter_inst 



-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : mshr_proc_switch
===============================================================================
SCORE  LINE   TOGGLE 
 94.27 100.00  88.54 

Source File(s) : 

/afs/umich.edu/user/z/t/ztguan/group6w22/verilog/mshr_proc_switch.sv

Module self-instances :

SCORE  LINE   TOGGLE NAME                                               
 94.27 100.00  88.54 cache_tb.dut.cache_ctrl_inst.mshr_proc_switch_inst 



-------------------------------------------------------------------------------
Line Coverage for Module : mshr_proc_switch

             Line No.   Total   Covered  Percent
TOTAL                       16       16   100.00
ALWAYS             67       16       16   100.00

66                              // Extract response requests and tag requests from all the requests
67         1/1                  response_req    =   'b0 ;
68         1/1                  tag_req         =   'b0 ;
69         1/1                  for (int unsigned entry_idx = 1; entry_idx < C_MSHR_ENTRY_NUM; entry_idx++) begin
70         1/1                      if (mshr_proc_i[entry_idx].response != 'd0) begin
71         1/1                          response_req[entry_idx]  =   1'b1;
72                                  end
                        MISSING_ELSE
73                      
74         1/1                      if (mshr_proc_i[entry_idx].tag != 'd0) begin
75         1/1                          tag_req[entry_idx]  =   1'b1;
76                                  end
                        MISSING_ELSE
77                              end
78                      
79                              // Prioritize response request over tag request
80         1/1                  if (response_req != 'b0) begin
81         1/1                      arbiter_req =   response_req;
82                              end else begin
83         1/1                      arbiter_req =   tag_req     ;
84                              end
85                      
86                              // Generate acknowledge signal for arbiter to switch priority
87         1/1                  arbiter_ack     =   grant_valid;
88                      
89                              // Route the granted request to the proc Interface
90                              // Output grant signals to the MSHR entries
91         1/1                  cache2proc_o    =   'b0 ;
92         1/1                  proc_grant_o    =   'b0 ;
93         1/1                  if (grant_valid) begin
94         1/1                      cache2proc_o    =   mshr_proc_i[grant_idx]    ;
95         1/1                      proc_grant_o    =   {{(C_MSHR_ENTRY_NUM-1){1'b0}}, 1'b1} << grant_idx;
96                              end
                        MISSING_ELSE

-------------------------------------------------------------------------------
Toggle Coverage for Module : mshr_proc_switch
                Total Covered Percent 
Totals          12    6       50.00   
Total Bits      288   255     88.54   
Total Bits 0->1 144   127     88.19   
Total Bits 1->0 144   128     88.89   

                              
Ports          6   3   50.00  
Port Bits      180 153 85.00  
Port Bits 0->1 90  76  84.44  
Port Bits 1->0 90  77  85.56  

                                
Signals          6   3   50.00  
Signal Bits      108 102 94.44  
Signal Bits 0->1 54  51  94.44  
Signal Bits 1->0 54  51  94.44  

Port Details
                           Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i                      Yes    Yes         Yes         INPUT     
rst_i                      No     Yes         No          INPUT     
proc_grant_o[0]            No     No          No          OUTPUT    
proc_grant_o[15:1]         Yes    Yes         Yes         OUTPUT    
cache2proc_o.tag[3:0]      Yes    Yes         Yes         OUTPUT    
cache2proc_o.data[18:0]    Yes    Yes         Yes         OUTPUT    
cache2proc_o.data[19]      No     No          No          OUTPUT    
cache2proc_o.data[24:20]   Yes    Yes         Yes         OUTPUT    
cache2proc_o.data[25]      No     No          No          OUTPUT    
cache2proc_o.data[33:26]   Yes    Yes         Yes         OUTPUT    
cache2proc_o.data[34]      No     No          No          OUTPUT    
cache2proc_o.data[41:35]   Yes    Yes         Yes         OUTPUT    
cache2proc_o.data[43:42]   No     No          No          OUTPUT    
cache2proc_o.data[44]      Yes    Yes         Yes         OUTPUT    
cache2proc_o.data[46:45]   No     No          No          OUTPUT    
cache2proc_o.data[49:47]   Yes    Yes         Yes         OUTPUT    
cache2proc_o.data[51:50]   No     No          No          OUTPUT    
cache2proc_o.data[54:52]   Yes    Yes         Yes         OUTPUT    
cache2proc_o.data[55]      No     No          No          OUTPUT    
cache2proc_o.data[58:56]   Yes    Yes         Yes         OUTPUT    
cache2proc_o.data[59]      No     No          No          OUTPUT    
cache2proc_o.data[62:60]   Yes    Yes         Yes         OUTPUT    
cache2proc_o.data[63]      No     No          No          OUTPUT    
cache2proc_o.response[3:0] Yes    Yes         Yes         OUTPUT    

Signal Details
                   Toggle Toggle 1->0 Toggle 0->1 
response_req[0]    No     No          No          
response_req[15:1] Yes    Yes         Yes         
tag_req[0]         No     No          No          
tag_req[15:1]      Yes    Yes         Yes         
arbiter_req[0]     No     No          No          
arbiter_req[15:1]  Yes    Yes         Yes         
arbiter_ack        Yes    Yes         Yes         
grant_idx[3:0]     Yes    Yes         Yes         
grant_valid        Yes    Yes         Yes         


-------------------------------------------------------------------------------
===============================================================================
Module Instance : cache_tb.dut.cache_ctrl_inst.mshr_proc_switch_inst
===============================================================================

Instance :

SCORE  LINE   TOGGLE 
 94.27 100.00  88.54 


Instance's subtree :

SCORE  LINE   TOGGLE 
 95.41 100.00  90.82 


Module : 

SCORE  LINE   TOGGLE NAME             
 94.27 100.00  88.54 mshr_proc_switch 


Parent : 

SCORE  LINE   TOGGLE NAME            
 92.38 100.00  84.76 cache_ctrl_inst 


Subtrees :

SCORE  LINE   TOGGLE NAME                 
 98.56 100.00  97.12 mshr_rr_arbiter_inst 



-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : mshr_memory_switch
===============================================================================
SCORE  LINE   TOGGLE 
 94.72 100.00  89.44 

Source File(s) : 

/afs/umich.edu/user/z/t/ztguan/group6w22/verilog/mshr_memory_switch.sv

Module self-instances :

SCORE  LINE   TOGGLE NAME                                                 
 94.72 100.00  89.44 cache_tb.dut.cache_ctrl_inst.mshr_memory_switch_inst 



-------------------------------------------------------------------------------
Line Coverage for Module : mshr_memory_switch

             Line No.   Total   Covered  Percent
TOTAL                       13       13   100.00
ALWAYS             67       13       13   100.00

66                              // Pick the MSHR entries with valid Memory requests
67         1/1                  arbiter_req =   'b0;
68         1/1                  for (int unsigned entry_idx = 1; entry_idx < C_MSHR_ENTRY_NUM; entry_idx++) begin
69         1/1                      if ((mshr_memory_i[entry_idx].command == BUS_LOAD)
70                                  || (mshr_memory_i[entry_idx].command == BUS_STORE)) begin
71         1/1                          arbiter_req[entry_idx]  =   1'b1;
72                                  end
                        MISSING_ELSE
73                              end
74                      
75                              // Generate acknowledge signal for arbiter to switch priority
76         1/1                  arbiter_ack     =   1'b0;
77         1/1                  if ((grant_valid == 1'b1) && (mem2cache_i.response != 'd0)) begin
78         1/1                      arbiter_ack     =   1'b1;
79                              end
                        MISSING_ELSE
80                      
81                              // Route the granted request to the Memory Interface
82                              // Output grant signals to the MSHR entries
83         1/1                  cache2mem_o     =   'b0 ;
84         1/1                  memory_grant_o  =   'b0 ;
85         1/1                  if (grant_valid) begin
86         1/1                      cache2mem_o     =   mshr_memory_i[grant_idx]    ;
87         1/1                      if (enable_i) begin
88         1/1                          memory_grant_o  =   {{(C_MSHR_ENTRY_NUM-1){1'b0}}, 1'b1} << grant_idx;
89                                  end
                   ==>  MISSING_ELSE
90                              end
                        MISSING_ELSE

-------------------------------------------------------------------------------
Toggle Coverage for Module : mshr_memory_switch
                Total Covered Percent 
Totals          15    10      66.67   
Total Bits      426   381     89.44   
Total Bits 0->1 213   190     89.20   
Total Bits 1->0 213   191     89.67   

                              
Ports          11  7   63.64  
Port Bits      382 339 88.74  
Port Bits 0->1 191 169 88.48  
Port Bits 1->0 191 170 89.01  

                              
Signals          4  3  75.00  
Signal Bits      44 42 95.45  
Signal Bits 0->1 22 21 95.45  
Signal Bits 1->0 22 21 95.45  

Port Details
                          Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i                     Yes    Yes         Yes         INPUT     
rst_i                     No     Yes         No          INPUT     
enable_i                  No     No          No          INPUT     
mem2cache_i.tag[3:0]      Yes    Yes         Yes         INPUT     
mem2cache_i.data[63:0]    Yes    Yes         Yes         INPUT     
mem2cache_i.response[3:0] Yes    Yes         Yes         INPUT     
memory_grant_o[0]         No     No          No          OUTPUT    
memory_grant_o[15:1]      Yes    Yes         Yes         OUTPUT    
cache2mem_o.command[1:0]  Yes    Yes         Yes         OUTPUT    
cache2mem_o.size[1:0]     Yes    Yes         Yes         OUTPUT    
cache2mem_o.data[63:0]    Yes    Yes         Yes         OUTPUT    
cache2mem_o.addr[2:0]     No     No          No          OUTPUT    
cache2mem_o.addr[15:3]    Yes    Yes         Yes         OUTPUT    
cache2mem_o.addr[31:16]   No     No          No          OUTPUT    

Signal Details
                  Toggle Toggle 1->0 Toggle 0->1 
arbiter_req[0]    No     No          No          
arbiter_req[15:1] Yes    Yes         Yes         
arbiter_ack       Yes    Yes         Yes         
grant_idx[3:0]    Yes    Yes         Yes         
grant_valid       Yes    Yes         Yes         


-------------------------------------------------------------------------------
===============================================================================
Module Instance : cache_tb.dut.cache_ctrl_inst.mshr_memory_switch_inst
===============================================================================

Instance :

SCORE  LINE   TOGGLE 
 94.72 100.00  89.44 


Instance's subtree :

SCORE  LINE   TOGGLE 
 95.47 100.00  90.94 


Module : 

SCORE  LINE   TOGGLE NAME               
 94.72 100.00  89.44 mshr_memory_switch 


Parent : 

SCORE  LINE   TOGGLE NAME            
 92.38 100.00  84.76 cache_ctrl_inst 


Subtrees :

SCORE  LINE   TOGGLE NAME                 
 98.56 100.00  97.12 mshr_rr_arbiter_inst 



-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : mshr_dispatch_selector
===============================================================================
SCORE  LINE   TOGGLE 
 97.62 100.00  95.24 

Source File(s) : 

/afs/umich.edu/user/z/t/ztguan/group6w22/verilog/mshr_dispatch_selector.sv

Module self-instances :

SCORE  LINE   TOGGLE NAME                                                     
 97.62 100.00  95.24 cache_tb.dut.cache_ctrl_inst.mshr_dispatch_selector_inst 



-------------------------------------------------------------------------------
Line Coverage for Module : mshr_dispatch_selector

             Line No.   Total   Covered  Percent
TOTAL                        9        9   100.00
ALWAYS             39        9        9   100.00

38                              // Scan through the empty entry, and select the one with smallest index
39         1/1                  dp_idx          =   'd0;
40         1/1                  dp_idx_valid    =   1'b0;
41         1/1                  for (int unsigned entry_idx = C_MSHR_ENTRY_NUM - 1; entry_idx > 0; entry_idx--) begin
42         1/1                      if (mshr_array_i[entry_idx].cmd == BUS_NONE) begin
43         1/1                          dp_idx          =   entry_idx;
44         1/1                          dp_idx_valid    =   1'b1;
45                                  end
                        MISSING_ELSE
46                              end
47                              // Generate per-entry dp_sel
48         1/1                  dp_sel_o    =   'b0;
49         1/1                  if (dp_idx_valid) begin
50         1/1                      dp_sel_o    =   {{(C_MSHR_ENTRY_NUM-1){1'b0}}, 1'b1} << dp_idx;
51                              end
                        MISSING_ELSE

-------------------------------------------------------------------------------
Toggle Coverage for Module : mshr_dispatch_selector
                Total Covered Percent 
Totals          3     2       66.67   
Total Bits      42    40      95.24   
Total Bits 0->1 21    20      95.24   
Total Bits 1->0 21    20      95.24   

                            
Ports          1  0  0.00   
Port Bits      32 30 93.75  
Port Bits 0->1 16 15 93.75  
Port Bits 1->0 16 15 93.75  

                              
Signals          2  2  100.00 
Signal Bits      10 10 100.00 
Signal Bits 0->1 5  5  100.00 
Signal Bits 1->0 5  5  100.00 

Port Details
               Toggle Toggle 1->0 Toggle 0->1 Direction 
dp_sel_o[0]    No     No          No          OUTPUT    
dp_sel_o[15:1] Yes    Yes         Yes         OUTPUT    

Signal Details
             Toggle Toggle 1->0 Toggle 0->1 
dp_idx_valid Yes    Yes         Yes         
dp_idx[3:0]  Yes    Yes         Yes         


-------------------------------------------------------------------------------
===============================================================================
Module Instance : cache_tb.dut.cache_ctrl_inst.mshr_dispatch_selector_inst
===============================================================================

Instance :

SCORE  LINE   TOGGLE 
 97.62 100.00  95.24 


Instance's subtree :

SCORE  LINE   TOGGLE 
 97.62 100.00  95.24 


Module : 

SCORE  LINE   TOGGLE NAME                   
 97.62 100.00  95.24 mshr_dispatch_selector 


Parent : 

SCORE  LINE   TOGGLE NAME            
 92.38 100.00  84.76 cache_ctrl_inst 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : mshr_rr_arbiter
===============================================================================
SCORE  LINE   TOGGLE 
 98.56 100.00  97.12 

Source File(s) : 

/afs/umich.edu/user/z/t/ztguan/group6w22/verilog/mshr_rr_arbiter.sv

Module self-instances :

SCORE  LINE   TOGGLE NAME                                                                         
 98.56 100.00  97.12 cache_tb.dut.cache_ctrl_inst.mshr_proc_switch_inst.mshr_rr_arbiter_inst      
 98.56 100.00  97.12 cache_tb.dut.cache_ctrl_inst.mshr_memory_switch_inst.mshr_rr_arbiter_inst    
 98.56 100.00  97.12 cache_tb.dut.cache_ctrl_inst.mshr_cache_mem_switch_inst.mshr_rr_arbiter_inst 



-------------------------------------------------------------------------------
Line Coverage for Module : mshr_rr_arbiter

             Line No.   Total   Covered  Percent
TOTAL                       17       17   100.00
ALWAYS             41        3        3   100.00
ALWAYS             49        5        5   100.00
ALWAYS             70        9        9   100.00

40                          always_ff @(posedge clk_i) begin
41         1/1                  if (rst_i) begin
42         1/1                      top_idx     <=  `SD 'd0;
43                              end else begin
44         1/1                      top_idx     <=  `SD next_top_idx;
45                              end
46                          end
47                      
48                          always_comb begin
49         1/1                  next_top_idx    =   top_idx;
50         1/1                  if (ack_i) begin
51         1/1                      if (grant_o + 1 >= C_REQ_NUM) begin
52         1/1                          next_top_idx    =   'd0;
53                                  end else begin
54         1/1                          next_top_idx    =   grant_o + 'd1;
55                                  end
56                              end
                        MISSING_ELSE
57                          end
58                      
59                      // --------------------------------------------------------------------
60                      // Generate grant
61                      // --------------------------------------------------------------------
62                          always_comb begin
63                              // Rank the requests according to priority
64                              // LSB of req_rank is of top priority
65                              // if (top_idx > 0) begin
66                              //     req_rank    =   {req_i[(top_idx-1):0], req_i[(C_REQ_NUM-1):top_idx]};
67                              // end else begin
68                              //     req_rank    =   req_i;
69                              // end
70         1/1                  req_rank    =   (req_i >> top_idx) | (req_i << (C_REQ_NUM-top_idx));
71                      
72                              // The grant index with respect to req_rank
73         1/1                  grant_rank  =   0;
74         1/1                  for (int unsigned req_idx = C_REQ_NUM; req_idx > 0; req_idx--) begin
75         1/1                      if (req_rank[req_idx-1]) begin
76         1/1                          grant_rank  =   (req_idx - 1);
77                                  end
                        MISSING_ELSE
78                              end
79                      
80                              // The grant index with respect to the original req_i
81         1/1                  if (top_idx + grant_rank >= C_REQ_NUM) begin
82         1/1                      grant_o =   top_idx + grant_rank - C_REQ_NUM;
83                              end else begin
84         1/1                      grant_o =   top_idx + grant_rank;
85                              end
86                      
87                              // Assert valid_o when there is any asserted request
88         1/1                  valid_o =   |req_i;

-------------------------------------------------------------------------------
Toggle Coverage for Module : mshr_rr_arbiter
                Total Covered Percent 
Totals          10    8       80.00   
Total Bits      104   101     97.12   
Total Bits 0->1 52    50      96.15   
Total Bits 1->0 52    51      98.08   

                            
Ports          6  4  66.67  
Port Bits      48 45 93.75  
Port Bits 0->1 24 22 91.67  
Port Bits 1->0 24 23 95.83  

                              
Signals          4  4  100.00 
Signal Bits      56 56 100.00 
Signal Bits 0->1 28 28 100.00 
Signal Bits 1->0 28 28 100.00 

Port Details
             Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i        Yes    Yes         Yes         INPUT     
rst_i        No     Yes         No          INPUT     
req_i[0]     No     No          No          INPUT     
req_i[15:1]  Yes    Yes         Yes         INPUT     
ack_i        Yes    Yes         Yes         INPUT     
grant_o[3:0] Yes    Yes         Yes         OUTPUT    
valid_o      Yes    Yes         Yes         OUTPUT    

Signal Details
                  Toggle Toggle 1->0 Toggle 0->1 
top_idx[3:0]      Yes    Yes         Yes         
next_top_idx[3:0] Yes    Yes         Yes         
req_rank[15:0]    Yes    Yes         Yes         
grant_rank[3:0]   Yes    Yes         Yes         


-------------------------------------------------------------------------------
===============================================================================
Module Instance : cache_tb.dut.cache_ctrl_inst.mshr_proc_switch_inst.mshr_rr_arbiter_inst
===============================================================================

Instance :

SCORE  LINE   TOGGLE 
 98.56 100.00  97.12 


Instance's subtree :

SCORE  LINE   TOGGLE 
 98.56 100.00  97.12 


Module : 

SCORE  LINE   TOGGLE NAME            
 98.56 100.00  97.12 mshr_rr_arbiter 


Parent : 

SCORE  LINE   TOGGLE NAME                  
 94.27 100.00  88.54 mshr_proc_switch_inst 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : cache_tb.dut.cache_ctrl_inst.mshr_proc_switch_inst.mshr_rr_arbiter_inst

             Line No.   Total   Covered  Percent
TOTAL                       17       17   100.00
ALWAYS             41        3        3   100.00
ALWAYS             49        5        5   100.00
ALWAYS             70        9        9   100.00

40                          always_ff @(posedge clk_i) begin
41         1/1                  if (rst_i) begin
42         1/1                      top_idx     <=  `SD 'd0;
43                              end else begin
44         1/1                      top_idx     <=  `SD next_top_idx;
45                              end
46                          end
47                      
48                          always_comb begin
49         1/1                  next_top_idx    =   top_idx;
50         1/1                  if (ack_i) begin
51         1/1                      if (grant_o + 1 >= C_REQ_NUM) begin
52         1/1                          next_top_idx    =   'd0;
53                                  end else begin
54         1/1                          next_top_idx    =   grant_o + 'd1;
55                                  end
56                              end
                        MISSING_ELSE
57                          end
58                      
59                      // --------------------------------------------------------------------
60                      // Generate grant
61                      // --------------------------------------------------------------------
62                          always_comb begin
63                              // Rank the requests according to priority
64                              // LSB of req_rank is of top priority
65                              // if (top_idx > 0) begin
66                              //     req_rank    =   {req_i[(top_idx-1):0], req_i[(C_REQ_NUM-1):top_idx]};
67                              // end else begin
68                              //     req_rank    =   req_i;
69                              // end
70         1/1                  req_rank    =   (req_i >> top_idx) | (req_i << (C_REQ_NUM-top_idx));
71                      
72                              // The grant index with respect to req_rank
73         1/1                  grant_rank  =   0;
74         1/1                  for (int unsigned req_idx = C_REQ_NUM; req_idx > 0; req_idx--) begin
75         1/1                      if (req_rank[req_idx-1]) begin
76         1/1                          grant_rank  =   (req_idx - 1);
77                                  end
                        MISSING_ELSE
78                              end
79                      
80                              // The grant index with respect to the original req_i
81         1/1                  if (top_idx + grant_rank >= C_REQ_NUM) begin
82         1/1                      grant_o =   top_idx + grant_rank - C_REQ_NUM;
83                              end else begin
84         1/1                      grant_o =   top_idx + grant_rank;
85                              end
86                      
87                              // Assert valid_o when there is any asserted request
88         1/1                  valid_o =   |req_i;

-------------------------------------------------------------------------------
Toggle Coverage for Instance : cache_tb.dut.cache_ctrl_inst.mshr_proc_switch_inst.mshr_rr_arbiter_inst
                Total Covered Percent 
Totals          10    8       80.00   
Total Bits      104   101     97.12   
Total Bits 0->1 52    50      96.15   
Total Bits 1->0 52    51      98.08   

                            
Ports          6  4  66.67  
Port Bits      48 45 93.75  
Port Bits 0->1 24 22 91.67  
Port Bits 1->0 24 23 95.83  

                              
Signals          4  4  100.00 
Signal Bits      56 56 100.00 
Signal Bits 0->1 28 28 100.00 
Signal Bits 1->0 28 28 100.00 

Port Details
             Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i        Yes    Yes         Yes         INPUT     
rst_i        No     Yes         No          INPUT     
req_i[0]     No     No          No          INPUT     
req_i[15:1]  Yes    Yes         Yes         INPUT     
ack_i        Yes    Yes         Yes         INPUT     
grant_o[3:0] Yes    Yes         Yes         OUTPUT    
valid_o      Yes    Yes         Yes         OUTPUT    

Signal Details
                  Toggle Toggle 1->0 Toggle 0->1 
top_idx[3:0]      Yes    Yes         Yes         
next_top_idx[3:0] Yes    Yes         Yes         
req_rank[15:0]    Yes    Yes         Yes         
grant_rank[3:0]   Yes    Yes         Yes         


-------------------------------------------------------------------------------
===============================================================================
Module Instance : cache_tb.dut.cache_ctrl_inst.mshr_memory_switch_inst.mshr_rr_arbiter_inst
===============================================================================

Instance :

SCORE  LINE   TOGGLE 
 98.56 100.00  97.12 


Instance's subtree :

SCORE  LINE   TOGGLE 
 98.56 100.00  97.12 


Module : 

SCORE  LINE   TOGGLE NAME            
 98.56 100.00  97.12 mshr_rr_arbiter 


Parent : 

SCORE  LINE   TOGGLE NAME                    
 94.72 100.00  89.44 mshr_memory_switch_inst 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : cache_tb.dut.cache_ctrl_inst.mshr_memory_switch_inst.mshr_rr_arbiter_inst

             Line No.   Total   Covered  Percent
TOTAL                       17       17   100.00
ALWAYS             41        3        3   100.00
ALWAYS             49        5        5   100.00
ALWAYS             70        9        9   100.00

40                          always_ff @(posedge clk_i) begin
41         1/1                  if (rst_i) begin
42         1/1                      top_idx     <=  `SD 'd0;
43                              end else begin
44         1/1                      top_idx     <=  `SD next_top_idx;
45                              end
46                          end
47                      
48                          always_comb begin
49         1/1                  next_top_idx    =   top_idx;
50         1/1                  if (ack_i) begin
51         1/1                      if (grant_o + 1 >= C_REQ_NUM) begin
52         1/1                          next_top_idx    =   'd0;
53                                  end else begin
54         1/1                          next_top_idx    =   grant_o + 'd1;
55                                  end
56                              end
                        MISSING_ELSE
57                          end
58                      
59                      // --------------------------------------------------------------------
60                      // Generate grant
61                      // --------------------------------------------------------------------
62                          always_comb begin
63                              // Rank the requests according to priority
64                              // LSB of req_rank is of top priority
65                              // if (top_idx > 0) begin
66                              //     req_rank    =   {req_i[(top_idx-1):0], req_i[(C_REQ_NUM-1):top_idx]};
67                              // end else begin
68                              //     req_rank    =   req_i;
69                              // end
70         1/1                  req_rank    =   (req_i >> top_idx) | (req_i << (C_REQ_NUM-top_idx));
71                      
72                              // The grant index with respect to req_rank
73         1/1                  grant_rank  =   0;
74         1/1                  for (int unsigned req_idx = C_REQ_NUM; req_idx > 0; req_idx--) begin
75         1/1                      if (req_rank[req_idx-1]) begin
76         1/1                          grant_rank  =   (req_idx - 1);
77                                  end
                        MISSING_ELSE
78                              end
79                      
80                              // The grant index with respect to the original req_i
81         1/1                  if (top_idx + grant_rank >= C_REQ_NUM) begin
82         1/1                      grant_o =   top_idx + grant_rank - C_REQ_NUM;
83                              end else begin
84         1/1                      grant_o =   top_idx + grant_rank;
85                              end
86                      
87                              // Assert valid_o when there is any asserted request
88         1/1                  valid_o =   |req_i;

-------------------------------------------------------------------------------
Toggle Coverage for Instance : cache_tb.dut.cache_ctrl_inst.mshr_memory_switch_inst.mshr_rr_arbiter_inst
                Total Covered Percent 
Totals          10    8       80.00   
Total Bits      104   101     97.12   
Total Bits 0->1 52    50      96.15   
Total Bits 1->0 52    51      98.08   

                            
Ports          6  4  66.67  
Port Bits      48 45 93.75  
Port Bits 0->1 24 22 91.67  
Port Bits 1->0 24 23 95.83  

                              
Signals          4  4  100.00 
Signal Bits      56 56 100.00 
Signal Bits 0->1 28 28 100.00 
Signal Bits 1->0 28 28 100.00 

Port Details
             Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i        Yes    Yes         Yes         INPUT     
rst_i        No     Yes         No          INPUT     
req_i[0]     No     No          No          INPUT     
req_i[15:1]  Yes    Yes         Yes         INPUT     
ack_i        Yes    Yes         Yes         INPUT     
grant_o[3:0] Yes    Yes         Yes         OUTPUT    
valid_o      Yes    Yes         Yes         OUTPUT    

Signal Details
                  Toggle Toggle 1->0 Toggle 0->1 
top_idx[3:0]      Yes    Yes         Yes         
next_top_idx[3:0] Yes    Yes         Yes         
req_rank[15:0]    Yes    Yes         Yes         
grant_rank[3:0]   Yes    Yes         Yes         


-------------------------------------------------------------------------------
===============================================================================
Module Instance : cache_tb.dut.cache_ctrl_inst.mshr_cache_mem_switch_inst.mshr_rr_arbiter_inst
===============================================================================

Instance :

SCORE  LINE   TOGGLE 
 98.56 100.00  97.12 


Instance's subtree :

SCORE  LINE   TOGGLE 
 98.56 100.00  97.12 


Module : 

SCORE  LINE   TOGGLE NAME            
 98.56 100.00  97.12 mshr_rr_arbiter 


Parent : 

SCORE  LINE   TOGGLE NAME                       
 93.35 100.00  86.69 mshr_cache_mem_switch_inst 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : cache_tb.dut.cache_ctrl_inst.mshr_cache_mem_switch_inst.mshr_rr_arbiter_inst

             Line No.   Total   Covered  Percent
TOTAL                       17       17   100.00
ALWAYS             41        3        3   100.00
ALWAYS             49        5        5   100.00
ALWAYS             70        9        9   100.00

40                          always_ff @(posedge clk_i) begin
41         1/1                  if (rst_i) begin
42         1/1                      top_idx     <=  `SD 'd0;
43                              end else begin
44         1/1                      top_idx     <=  `SD next_top_idx;
45                              end
46                          end
47                      
48                          always_comb begin
49         1/1                  next_top_idx    =   top_idx;
50         1/1                  if (ack_i) begin
51         1/1                      if (grant_o + 1 >= C_REQ_NUM) begin
52         1/1                          next_top_idx    =   'd0;
53                                  end else begin
54         1/1                          next_top_idx    =   grant_o + 'd1;
55                                  end
56                              end
                        MISSING_ELSE
57                          end
58                      
59                      // --------------------------------------------------------------------
60                      // Generate grant
61                      // --------------------------------------------------------------------
62                          always_comb begin
63                              // Rank the requests according to priority
64                              // LSB of req_rank is of top priority
65                              // if (top_idx > 0) begin
66                              //     req_rank    =   {req_i[(top_idx-1):0], req_i[(C_REQ_NUM-1):top_idx]};
67                              // end else begin
68                              //     req_rank    =   req_i;
69                              // end
70         1/1                  req_rank    =   (req_i >> top_idx) | (req_i << (C_REQ_NUM-top_idx));
71                      
72                              // The grant index with respect to req_rank
73         1/1                  grant_rank  =   0;
74         1/1                  for (int unsigned req_idx = C_REQ_NUM; req_idx > 0; req_idx--) begin
75         1/1                      if (req_rank[req_idx-1]) begin
76         1/1                          grant_rank  =   (req_idx - 1);
77                                  end
                        MISSING_ELSE
78                              end
79                      
80                              // The grant index with respect to the original req_i
81         1/1                  if (top_idx + grant_rank >= C_REQ_NUM) begin
82         1/1                      grant_o =   top_idx + grant_rank - C_REQ_NUM;
83                              end else begin
84         1/1                      grant_o =   top_idx + grant_rank;
85                              end
86                      
87                              // Assert valid_o when there is any asserted request
88         1/1                  valid_o =   |req_i;

-------------------------------------------------------------------------------
Toggle Coverage for Instance : cache_tb.dut.cache_ctrl_inst.mshr_cache_mem_switch_inst.mshr_rr_arbiter_inst
                Total Covered Percent 
Totals          10    8       80.00   
Total Bits      104   101     97.12   
Total Bits 0->1 52    50      96.15   
Total Bits 1->0 52    51      98.08   

                            
Ports          6  4  66.67  
Port Bits      48 45 93.75  
Port Bits 0->1 24 22 91.67  
Port Bits 1->0 24 23 95.83  

                              
Signals          4  4  100.00 
Signal Bits      56 56 100.00 
Signal Bits 0->1 28 28 100.00 
Signal Bits 1->0 28 28 100.00 

Port Details
             Toggle Toggle 1->0 Toggle 0->1 Direction 
clk_i        Yes    Yes         Yes         INPUT     
rst_i        No     Yes         No          INPUT     
req_i[0]     No     No          No          INPUT     
req_i[15:1]  Yes    Yes         Yes         INPUT     
ack_i        Yes    Yes         Yes         INPUT     
grant_o[3:0] Yes    Yes         Yes         OUTPUT    
valid_o      Yes    Yes         Yes         OUTPUT    

Signal Details
                  Toggle Toggle 1->0 Toggle 0->1 
top_idx[3:0]      Yes    Yes         Yes         
next_top_idx[3:0] Yes    Yes         Yes         
req_rank[15:0]    Yes    Yes         Yes         
grant_rank[3:0]   Yes    Yes         Yes         


===============================================================================
Module : LRU_update
===============================================================================
SCORE  LINE   TOGGLE 
100.00 100.00 100.00 

Source File(s) : 

/afs/umich.edu/user/z/t/ztguan/group6w22/verilog/LRU_update.sv

Module self-instances :

SCORE  LINE   TOGGLE NAME                                                   
100.00 100.00 100.00 cache_tb.dut.cache_mem_inst.genblk1[0].LRU_update_inst 
100.00 100.00 100.00 cache_tb.dut.cache_mem_inst.genblk1[1].LRU_update_inst 
100.00 100.00 100.00 cache_tb.dut.cache_mem_inst.genblk1[2].LRU_update_inst 
100.00 100.00 100.00 cache_tb.dut.cache_mem_inst.genblk1[3].LRU_update_inst 
100.00 100.00 100.00 cache_tb.dut.cache_mem_inst.genblk1[4].LRU_update_inst 
100.00 100.00 100.00 cache_tb.dut.cache_mem_inst.genblk1[5].LRU_update_inst 
100.00 100.00 100.00 cache_tb.dut.cache_mem_inst.genblk1[6].LRU_update_inst 
100.00 100.00 100.00 cache_tb.dut.cache_mem_inst.genblk1[7].LRU_update_inst 



-------------------------------------------------------------------------------
Line Coverage for Module : LRU_update

             Line No.   Total   Covered  Percent
TOTAL                       23       23   100.00
ALWAYS             37       23       23   100.00

36                              // Expand the use_history to a C_CACHE_SASS * C_CACHE_SASS array
37         1/1                  offset  =   0;
38         1/1                  for (int unsigned i = 0; i < C_CACHE_SASS; i = i + 1) begin
39                                  // Diagnal
40         1/1                      expand[i][i] = 1'b1;
41                                  // Upper triangle
42         1/1                      for (int unsigned j = i + 1; j < C_CACHE_SASS; j = j + 1) begin
43         1/1                          expand[i][j]    =   use_history[offset+j-i-1];
44                                  end
45                                  // Lower triangle
46         1/1                      for (int unsigned j = 0; j < i; j = j + 1) begin
47         1/1                          expand[i][j]    =   !expand[j][i];
48                                  end
49         1/1                      offset = offset + C_CACHE_SASS - i - 1;
50                              end 
51                      
52                              // Update Matrix if there is an access
53         1/1                  for (i = 0; i < C_CACHE_SASS; i = i + 1) begin
54         1/1                      if (access[i]) begin
55         1/1                          for (j = 0; j < C_CACHE_SASS; j = j + 1) begin
56         1/1                              if (i != j) begin
57         1/1                                  expand[i][j] = 1'b0;
58                                          end
                        MISSING_ELSE
59                                      end
60                      
61         1/1                          for (j = 0; j < C_CACHE_SASS; j = j + 1) begin
62         1/1                              if (i != j) begin
63         1/1                                  expand[j][i] = 1'b1;
64                                          end
                        MISSING_ELSE
65                                      end
66                                  end
                        MISSING_ELSE
67                              end
68                      
69                              // Generate the value of use_history to be updated
70         1/1                  offset = 0;
71         1/1                  for (i = 0; i < C_CACHE_SASS; i = i + 1) begin
72         1/1                      for (j = i + 1; j < C_CACHE_SASS; j = j + 1) begin
73         1/1                          next_use_history[offset+j-i-1] = expand[i][j];
74                                  end
75         1/1                      offset = offset + C_CACHE_SASS - i - 1;
76                              end
77                      
78                              // Generate the LRU bits
79         1/1                  for (i = 0; i < C_CACHE_SASS; i = i + 1) begin
80         1/1                      next_lru[i] = &expand[i];

-------------------------------------------------------------------------------
Toggle Coverage for Module : LRU_update
                Total Covered Percent 
Totals          4     4       100.00  
Total Bits      40    40      100.00  
Total Bits 0->1 20    20      100.00  
Total Bits 1->0 20    20      100.00  

                            
Ports          4  4  100.00 
Port Bits      40 40 100.00 
Port Bits 0->1 20 20 100.00 
Port Bits 1->0 20 20 100.00 

Port Details
                      Toggle Toggle 1->0 Toggle 0->1 Direction 
use_history[5:0]      Yes    Yes         Yes         INPUT     
access[3:0]           Yes    Yes         Yes         INPUT     
next_use_history[5:0] Yes    Yes         Yes         OUTPUT    
next_lru[3:0]         Yes    Yes         Yes         OUTPUT    


-------------------------------------------------------------------------------
===============================================================================
Module Instance : cache_tb.dut.cache_mem_inst.genblk1[0].LRU_update_inst
===============================================================================

Instance :

SCORE  LINE   TOGGLE 
100.00 100.00 100.00 


Instance's subtree :

SCORE  LINE   TOGGLE 
100.00 100.00 100.00 


Module : 

SCORE  LINE   TOGGLE NAME       
100.00 100.00 100.00 LRU_update 


Parent : 

SCORE  LINE   TOGGLE NAME           
 91.91 100.00  83.82 cache_mem_inst 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : cache_tb.dut.cache_mem_inst.genblk1[0].LRU_update_inst

             Line No.   Total   Covered  Percent
TOTAL                       23       23   100.00
ALWAYS             37       23       23   100.00

36                              // Expand the use_history to a C_CACHE_SASS * C_CACHE_SASS array
37         1/1                  offset  =   0;
38         1/1                  for (int unsigned i = 0; i < C_CACHE_SASS; i = i + 1) begin
39                                  // Diagnal
40         1/1                      expand[i][i] = 1'b1;
41                                  // Upper triangle
42         1/1                      for (int unsigned j = i + 1; j < C_CACHE_SASS; j = j + 1) begin
43         1/1                          expand[i][j]    =   use_history[offset+j-i-1];
44                                  end
45                                  // Lower triangle
46         1/1                      for (int unsigned j = 0; j < i; j = j + 1) begin
47         1/1                          expand[i][j]    =   !expand[j][i];
48                                  end
49         1/1                      offset = offset + C_CACHE_SASS - i - 1;
50                              end 
51                      
52                              // Update Matrix if there is an access
53         1/1                  for (i = 0; i < C_CACHE_SASS; i = i + 1) begin
54         1/1                      if (access[i]) begin
55         1/1                          for (j = 0; j < C_CACHE_SASS; j = j + 1) begin
56         1/1                              if (i != j) begin
57         1/1                                  expand[i][j] = 1'b0;
58                                          end
                        MISSING_ELSE
59                                      end
60                      
61         1/1                          for (j = 0; j < C_CACHE_SASS; j = j + 1) begin
62         1/1                              if (i != j) begin
63         1/1                                  expand[j][i] = 1'b1;
64                                          end
                        MISSING_ELSE
65                                      end
66                                  end
                        MISSING_ELSE
67                              end
68                      
69                              // Generate the value of use_history to be updated
70         1/1                  offset = 0;
71         1/1                  for (i = 0; i < C_CACHE_SASS; i = i + 1) begin
72         1/1                      for (j = i + 1; j < C_CACHE_SASS; j = j + 1) begin
73         1/1                          next_use_history[offset+j-i-1] = expand[i][j];
74                                  end
75         1/1                      offset = offset + C_CACHE_SASS - i - 1;
76                              end
77                      
78                              // Generate the LRU bits
79         1/1                  for (i = 0; i < C_CACHE_SASS; i = i + 1) begin
80         1/1                      next_lru[i] = &expand[i];

-------------------------------------------------------------------------------
Toggle Coverage for Instance : cache_tb.dut.cache_mem_inst.genblk1[0].LRU_update_inst
                Total Covered Percent 
Totals          4     4       100.00  
Total Bits      40    40      100.00  
Total Bits 0->1 20    20      100.00  
Total Bits 1->0 20    20      100.00  

                            
Ports          4  4  100.00 
Port Bits      40 40 100.00 
Port Bits 0->1 20 20 100.00 
Port Bits 1->0 20 20 100.00 

Port Details
                      Toggle Toggle 1->0 Toggle 0->1 Direction 
use_history[5:0]      Yes    Yes         Yes         INPUT     
access[3:0]           Yes    Yes         Yes         INPUT     
next_use_history[5:0] Yes    Yes         Yes         OUTPUT    
next_lru[3:0]         Yes    Yes         Yes         OUTPUT    


-------------------------------------------------------------------------------
===============================================================================
Module Instance : cache_tb.dut.cache_mem_inst.genblk1[1].LRU_update_inst
===============================================================================

Instance :

SCORE  LINE   TOGGLE 
100.00 100.00 100.00 


Instance's subtree :

SCORE  LINE   TOGGLE 
100.00 100.00 100.00 


Module : 

SCORE  LINE   TOGGLE NAME       
100.00 100.00 100.00 LRU_update 


Parent : 

SCORE  LINE   TOGGLE NAME           
 91.91 100.00  83.82 cache_mem_inst 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : cache_tb.dut.cache_mem_inst.genblk1[1].LRU_update_inst

             Line No.   Total   Covered  Percent
TOTAL                       23       23   100.00
ALWAYS             37       23       23   100.00

36                              // Expand the use_history to a C_CACHE_SASS * C_CACHE_SASS array
37         1/1                  offset  =   0;
38         1/1                  for (int unsigned i = 0; i < C_CACHE_SASS; i = i + 1) begin
39                                  // Diagnal
40         1/1                      expand[i][i] = 1'b1;
41                                  // Upper triangle
42         1/1                      for (int unsigned j = i + 1; j < C_CACHE_SASS; j = j + 1) begin
43         1/1                          expand[i][j]    =   use_history[offset+j-i-1];
44                                  end
45                                  // Lower triangle
46         1/1                      for (int unsigned j = 0; j < i; j = j + 1) begin
47         1/1                          expand[i][j]    =   !expand[j][i];
48                                  end
49         1/1                      offset = offset + C_CACHE_SASS - i - 1;
50                              end 
51                      
52                              // Update Matrix if there is an access
53         1/1                  for (i = 0; i < C_CACHE_SASS; i = i + 1) begin
54         1/1                      if (access[i]) begin
55         1/1                          for (j = 0; j < C_CACHE_SASS; j = j + 1) begin
56         1/1                              if (i != j) begin
57         1/1                                  expand[i][j] = 1'b0;
58                                          end
                        MISSING_ELSE
59                                      end
60                      
61         1/1                          for (j = 0; j < C_CACHE_SASS; j = j + 1) begin
62         1/1                              if (i != j) begin
63         1/1                                  expand[j][i] = 1'b1;
64                                          end
                        MISSING_ELSE
65                                      end
66                                  end
                        MISSING_ELSE
67                              end
68                      
69                              // Generate the value of use_history to be updated
70         1/1                  offset = 0;
71         1/1                  for (i = 0; i < C_CACHE_SASS; i = i + 1) begin
72         1/1                      for (j = i + 1; j < C_CACHE_SASS; j = j + 1) begin
73         1/1                          next_use_history[offset+j-i-1] = expand[i][j];
74                                  end
75         1/1                      offset = offset + C_CACHE_SASS - i - 1;
76                              end
77                      
78                              // Generate the LRU bits
79         1/1                  for (i = 0; i < C_CACHE_SASS; i = i + 1) begin
80         1/1                      next_lru[i] = &expand[i];

-------------------------------------------------------------------------------
Toggle Coverage for Instance : cache_tb.dut.cache_mem_inst.genblk1[1].LRU_update_inst
                Total Covered Percent 
Totals          4     4       100.00  
Total Bits      40    40      100.00  
Total Bits 0->1 20    20      100.00  
Total Bits 1->0 20    20      100.00  

                            
Ports          4  4  100.00 
Port Bits      40 40 100.00 
Port Bits 0->1 20 20 100.00 
Port Bits 1->0 20 20 100.00 

Port Details
                      Toggle Toggle 1->0 Toggle 0->1 Direction 
use_history[5:0]      Yes    Yes         Yes         INPUT     
access[3:0]           Yes    Yes         Yes         INPUT     
next_use_history[5:0] Yes    Yes         Yes         OUTPUT    
next_lru[3:0]         Yes    Yes         Yes         OUTPUT    


-------------------------------------------------------------------------------
===============================================================================
Module Instance : cache_tb.dut.cache_mem_inst.genblk1[2].LRU_update_inst
===============================================================================

Instance :

SCORE  LINE   TOGGLE 
100.00 100.00 100.00 


Instance's subtree :

SCORE  LINE   TOGGLE 
100.00 100.00 100.00 


Module : 

SCORE  LINE   TOGGLE NAME       
100.00 100.00 100.00 LRU_update 


Parent : 

SCORE  LINE   TOGGLE NAME           
 91.91 100.00  83.82 cache_mem_inst 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : cache_tb.dut.cache_mem_inst.genblk1[2].LRU_update_inst

             Line No.   Total   Covered  Percent
TOTAL                       23       23   100.00
ALWAYS             37       23       23   100.00

36                              // Expand the use_history to a C_CACHE_SASS * C_CACHE_SASS array
37         1/1                  offset  =   0;
38         1/1                  for (int unsigned i = 0; i < C_CACHE_SASS; i = i + 1) begin
39                                  // Diagnal
40         1/1                      expand[i][i] = 1'b1;
41                                  // Upper triangle
42         1/1                      for (int unsigned j = i + 1; j < C_CACHE_SASS; j = j + 1) begin
43         1/1                          expand[i][j]    =   use_history[offset+j-i-1];
44                                  end
45                                  // Lower triangle
46         1/1                      for (int unsigned j = 0; j < i; j = j + 1) begin
47         1/1                          expand[i][j]    =   !expand[j][i];
48                                  end
49         1/1                      offset = offset + C_CACHE_SASS - i - 1;
50                              end 
51                      
52                              // Update Matrix if there is an access
53         1/1                  for (i = 0; i < C_CACHE_SASS; i = i + 1) begin
54         1/1                      if (access[i]) begin
55         1/1                          for (j = 0; j < C_CACHE_SASS; j = j + 1) begin
56         1/1                              if (i != j) begin
57         1/1                                  expand[i][j] = 1'b0;
58                                          end
                        MISSING_ELSE
59                                      end
60                      
61         1/1                          for (j = 0; j < C_CACHE_SASS; j = j + 1) begin
62         1/1                              if (i != j) begin
63         1/1                                  expand[j][i] = 1'b1;
64                                          end
                        MISSING_ELSE
65                                      end
66                                  end
                        MISSING_ELSE
67                              end
68                      
69                              // Generate the value of use_history to be updated
70         1/1                  offset = 0;
71         1/1                  for (i = 0; i < C_CACHE_SASS; i = i + 1) begin
72         1/1                      for (j = i + 1; j < C_CACHE_SASS; j = j + 1) begin
73         1/1                          next_use_history[offset+j-i-1] = expand[i][j];
74                                  end
75         1/1                      offset = offset + C_CACHE_SASS - i - 1;
76                              end
77                      
78                              // Generate the LRU bits
79         1/1                  for (i = 0; i < C_CACHE_SASS; i = i + 1) begin
80         1/1                      next_lru[i] = &expand[i];

-------------------------------------------------------------------------------
Toggle Coverage for Instance : cache_tb.dut.cache_mem_inst.genblk1[2].LRU_update_inst
                Total Covered Percent 
Totals          4     4       100.00  
Total Bits      40    40      100.00  
Total Bits 0->1 20    20      100.00  
Total Bits 1->0 20    20      100.00  

                            
Ports          4  4  100.00 
Port Bits      40 40 100.00 
Port Bits 0->1 20 20 100.00 
Port Bits 1->0 20 20 100.00 

Port Details
                      Toggle Toggle 1->0 Toggle 0->1 Direction 
use_history[5:0]      Yes    Yes         Yes         INPUT     
access[3:0]           Yes    Yes         Yes         INPUT     
next_use_history[5:0] Yes    Yes         Yes         OUTPUT    
next_lru[3:0]         Yes    Yes         Yes         OUTPUT    


-------------------------------------------------------------------------------
===============================================================================
Module Instance : cache_tb.dut.cache_mem_inst.genblk1[3].LRU_update_inst
===============================================================================

Instance :

SCORE  LINE   TOGGLE 
100.00 100.00 100.00 


Instance's subtree :

SCORE  LINE   TOGGLE 
100.00 100.00 100.00 


Module : 

SCORE  LINE   TOGGLE NAME       
100.00 100.00 100.00 LRU_update 


Parent : 

SCORE  LINE   TOGGLE NAME           
 91.91 100.00  83.82 cache_mem_inst 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : cache_tb.dut.cache_mem_inst.genblk1[3].LRU_update_inst

             Line No.   Total   Covered  Percent
TOTAL                       23       23   100.00
ALWAYS             37       23       23   100.00

36                              // Expand the use_history to a C_CACHE_SASS * C_CACHE_SASS array
37         1/1                  offset  =   0;
38         1/1                  for (int unsigned i = 0; i < C_CACHE_SASS; i = i + 1) begin
39                                  // Diagnal
40         1/1                      expand[i][i] = 1'b1;
41                                  // Upper triangle
42         1/1                      for (int unsigned j = i + 1; j < C_CACHE_SASS; j = j + 1) begin
43         1/1                          expand[i][j]    =   use_history[offset+j-i-1];
44                                  end
45                                  // Lower triangle
46         1/1                      for (int unsigned j = 0; j < i; j = j + 1) begin
47         1/1                          expand[i][j]    =   !expand[j][i];
48                                  end
49         1/1                      offset = offset + C_CACHE_SASS - i - 1;
50                              end 
51                      
52                              // Update Matrix if there is an access
53         1/1                  for (i = 0; i < C_CACHE_SASS; i = i + 1) begin
54         1/1                      if (access[i]) begin
55         1/1                          for (j = 0; j < C_CACHE_SASS; j = j + 1) begin
56         1/1                              if (i != j) begin
57         1/1                                  expand[i][j] = 1'b0;
58                                          end
                        MISSING_ELSE
59                                      end
60                      
61         1/1                          for (j = 0; j < C_CACHE_SASS; j = j + 1) begin
62         1/1                              if (i != j) begin
63         1/1                                  expand[j][i] = 1'b1;
64                                          end
                        MISSING_ELSE
65                                      end
66                                  end
                        MISSING_ELSE
67                              end
68                      
69                              // Generate the value of use_history to be updated
70         1/1                  offset = 0;
71         1/1                  for (i = 0; i < C_CACHE_SASS; i = i + 1) begin
72         1/1                      for (j = i + 1; j < C_CACHE_SASS; j = j + 1) begin
73         1/1                          next_use_history[offset+j-i-1] = expand[i][j];
74                                  end
75         1/1                      offset = offset + C_CACHE_SASS - i - 1;
76                              end
77                      
78                              // Generate the LRU bits
79         1/1                  for (i = 0; i < C_CACHE_SASS; i = i + 1) begin
80         1/1                      next_lru[i] = &expand[i];

-------------------------------------------------------------------------------
Toggle Coverage for Instance : cache_tb.dut.cache_mem_inst.genblk1[3].LRU_update_inst
                Total Covered Percent 
Totals          4     4       100.00  
Total Bits      40    40      100.00  
Total Bits 0->1 20    20      100.00  
Total Bits 1->0 20    20      100.00  

                            
Ports          4  4  100.00 
Port Bits      40 40 100.00 
Port Bits 0->1 20 20 100.00 
Port Bits 1->0 20 20 100.00 

Port Details
                      Toggle Toggle 1->0 Toggle 0->1 Direction 
use_history[5:0]      Yes    Yes         Yes         INPUT     
access[3:0]           Yes    Yes         Yes         INPUT     
next_use_history[5:0] Yes    Yes         Yes         OUTPUT    
next_lru[3:0]         Yes    Yes         Yes         OUTPUT    


-------------------------------------------------------------------------------
===============================================================================
Module Instance : cache_tb.dut.cache_mem_inst.genblk1[4].LRU_update_inst
===============================================================================

Instance :

SCORE  LINE   TOGGLE 
100.00 100.00 100.00 


Instance's subtree :

SCORE  LINE   TOGGLE 
100.00 100.00 100.00 


Module : 

SCORE  LINE   TOGGLE NAME       
100.00 100.00 100.00 LRU_update 


Parent : 

SCORE  LINE   TOGGLE NAME           
 91.91 100.00  83.82 cache_mem_inst 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : cache_tb.dut.cache_mem_inst.genblk1[4].LRU_update_inst

             Line No.   Total   Covered  Percent
TOTAL                       23       23   100.00
ALWAYS             37       23       23   100.00

36                              // Expand the use_history to a C_CACHE_SASS * C_CACHE_SASS array
37         1/1                  offset  =   0;
38         1/1                  for (int unsigned i = 0; i < C_CACHE_SASS; i = i + 1) begin
39                                  // Diagnal
40         1/1                      expand[i][i] = 1'b1;
41                                  // Upper triangle
42         1/1                      for (int unsigned j = i + 1; j < C_CACHE_SASS; j = j + 1) begin
43         1/1                          expand[i][j]    =   use_history[offset+j-i-1];
44                                  end
45                                  // Lower triangle
46         1/1                      for (int unsigned j = 0; j < i; j = j + 1) begin
47         1/1                          expand[i][j]    =   !expand[j][i];
48                                  end
49         1/1                      offset = offset + C_CACHE_SASS - i - 1;
50                              end 
51                      
52                              // Update Matrix if there is an access
53         1/1                  for (i = 0; i < C_CACHE_SASS; i = i + 1) begin
54         1/1                      if (access[i]) begin
55         1/1                          for (j = 0; j < C_CACHE_SASS; j = j + 1) begin
56         1/1                              if (i != j) begin
57         1/1                                  expand[i][j] = 1'b0;
58                                          end
                        MISSING_ELSE
59                                      end
60                      
61         1/1                          for (j = 0; j < C_CACHE_SASS; j = j + 1) begin
62         1/1                              if (i != j) begin
63         1/1                                  expand[j][i] = 1'b1;
64                                          end
                        MISSING_ELSE
65                                      end
66                                  end
                        MISSING_ELSE
67                              end
68                      
69                              // Generate the value of use_history to be updated
70         1/1                  offset = 0;
71         1/1                  for (i = 0; i < C_CACHE_SASS; i = i + 1) begin
72         1/1                      for (j = i + 1; j < C_CACHE_SASS; j = j + 1) begin
73         1/1                          next_use_history[offset+j-i-1] = expand[i][j];
74                                  end
75         1/1                      offset = offset + C_CACHE_SASS - i - 1;
76                              end
77                      
78                              // Generate the LRU bits
79         1/1                  for (i = 0; i < C_CACHE_SASS; i = i + 1) begin
80         1/1                      next_lru[i] = &expand[i];

-------------------------------------------------------------------------------
Toggle Coverage for Instance : cache_tb.dut.cache_mem_inst.genblk1[4].LRU_update_inst
                Total Covered Percent 
Totals          4     4       100.00  
Total Bits      40    40      100.00  
Total Bits 0->1 20    20      100.00  
Total Bits 1->0 20    20      100.00  

                            
Ports          4  4  100.00 
Port Bits      40 40 100.00 
Port Bits 0->1 20 20 100.00 
Port Bits 1->0 20 20 100.00 

Port Details
                      Toggle Toggle 1->0 Toggle 0->1 Direction 
use_history[5:0]      Yes    Yes         Yes         INPUT     
access[3:0]           Yes    Yes         Yes         INPUT     
next_use_history[5:0] Yes    Yes         Yes         OUTPUT    
next_lru[3:0]         Yes    Yes         Yes         OUTPUT    


-------------------------------------------------------------------------------
===============================================================================
Module Instance : cache_tb.dut.cache_mem_inst.genblk1[5].LRU_update_inst
===============================================================================

Instance :

SCORE  LINE   TOGGLE 
100.00 100.00 100.00 


Instance's subtree :

SCORE  LINE   TOGGLE 
100.00 100.00 100.00 


Module : 

SCORE  LINE   TOGGLE NAME       
100.00 100.00 100.00 LRU_update 


Parent : 

SCORE  LINE   TOGGLE NAME           
 91.91 100.00  83.82 cache_mem_inst 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : cache_tb.dut.cache_mem_inst.genblk1[5].LRU_update_inst

             Line No.   Total   Covered  Percent
TOTAL                       23       23   100.00
ALWAYS             37       23       23   100.00

36                              // Expand the use_history to a C_CACHE_SASS * C_CACHE_SASS array
37         1/1                  offset  =   0;
38         1/1                  for (int unsigned i = 0; i < C_CACHE_SASS; i = i + 1) begin
39                                  // Diagnal
40         1/1                      expand[i][i] = 1'b1;
41                                  // Upper triangle
42         1/1                      for (int unsigned j = i + 1; j < C_CACHE_SASS; j = j + 1) begin
43         1/1                          expand[i][j]    =   use_history[offset+j-i-1];
44                                  end
45                                  // Lower triangle
46         1/1                      for (int unsigned j = 0; j < i; j = j + 1) begin
47         1/1                          expand[i][j]    =   !expand[j][i];
48                                  end
49         1/1                      offset = offset + C_CACHE_SASS - i - 1;
50                              end 
51                      
52                              // Update Matrix if there is an access
53         1/1                  for (i = 0; i < C_CACHE_SASS; i = i + 1) begin
54         1/1                      if (access[i]) begin
55         1/1                          for (j = 0; j < C_CACHE_SASS; j = j + 1) begin
56         1/1                              if (i != j) begin
57         1/1                                  expand[i][j] = 1'b0;
58                                          end
                        MISSING_ELSE
59                                      end
60                      
61         1/1                          for (j = 0; j < C_CACHE_SASS; j = j + 1) begin
62         1/1                              if (i != j) begin
63         1/1                                  expand[j][i] = 1'b1;
64                                          end
                        MISSING_ELSE
65                                      end
66                                  end
                        MISSING_ELSE
67                              end
68                      
69                              // Generate the value of use_history to be updated
70         1/1                  offset = 0;
71         1/1                  for (i = 0; i < C_CACHE_SASS; i = i + 1) begin
72         1/1                      for (j = i + 1; j < C_CACHE_SASS; j = j + 1) begin
73         1/1                          next_use_history[offset+j-i-1] = expand[i][j];
74                                  end
75         1/1                      offset = offset + C_CACHE_SASS - i - 1;
76                              end
77                      
78                              // Generate the LRU bits
79         1/1                  for (i = 0; i < C_CACHE_SASS; i = i + 1) begin
80         1/1                      next_lru[i] = &expand[i];

-------------------------------------------------------------------------------
Toggle Coverage for Instance : cache_tb.dut.cache_mem_inst.genblk1[5].LRU_update_inst
                Total Covered Percent 
Totals          4     4       100.00  
Total Bits      40    40      100.00  
Total Bits 0->1 20    20      100.00  
Total Bits 1->0 20    20      100.00  

                            
Ports          4  4  100.00 
Port Bits      40 40 100.00 
Port Bits 0->1 20 20 100.00 
Port Bits 1->0 20 20 100.00 

Port Details
                      Toggle Toggle 1->0 Toggle 0->1 Direction 
use_history[5:0]      Yes    Yes         Yes         INPUT     
access[3:0]           Yes    Yes         Yes         INPUT     
next_use_history[5:0] Yes    Yes         Yes         OUTPUT    
next_lru[3:0]         Yes    Yes         Yes         OUTPUT    


-------------------------------------------------------------------------------
===============================================================================
Module Instance : cache_tb.dut.cache_mem_inst.genblk1[6].LRU_update_inst
===============================================================================

Instance :

SCORE  LINE   TOGGLE 
100.00 100.00 100.00 


Instance's subtree :

SCORE  LINE   TOGGLE 
100.00 100.00 100.00 


Module : 

SCORE  LINE   TOGGLE NAME       
100.00 100.00 100.00 LRU_update 


Parent : 

SCORE  LINE   TOGGLE NAME           
 91.91 100.00  83.82 cache_mem_inst 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : cache_tb.dut.cache_mem_inst.genblk1[6].LRU_update_inst

             Line No.   Total   Covered  Percent
TOTAL                       23       23   100.00
ALWAYS             37       23       23   100.00

36                              // Expand the use_history to a C_CACHE_SASS * C_CACHE_SASS array
37         1/1                  offset  =   0;
38         1/1                  for (int unsigned i = 0; i < C_CACHE_SASS; i = i + 1) begin
39                                  // Diagnal
40         1/1                      expand[i][i] = 1'b1;
41                                  // Upper triangle
42         1/1                      for (int unsigned j = i + 1; j < C_CACHE_SASS; j = j + 1) begin
43         1/1                          expand[i][j]    =   use_history[offset+j-i-1];
44                                  end
45                                  // Lower triangle
46         1/1                      for (int unsigned j = 0; j < i; j = j + 1) begin
47         1/1                          expand[i][j]    =   !expand[j][i];
48                                  end
49         1/1                      offset = offset + C_CACHE_SASS - i - 1;
50                              end 
51                      
52                              // Update Matrix if there is an access
53         1/1                  for (i = 0; i < C_CACHE_SASS; i = i + 1) begin
54         1/1                      if (access[i]) begin
55         1/1                          for (j = 0; j < C_CACHE_SASS; j = j + 1) begin
56         1/1                              if (i != j) begin
57         1/1                                  expand[i][j] = 1'b0;
58                                          end
                        MISSING_ELSE
59                                      end
60                      
61         1/1                          for (j = 0; j < C_CACHE_SASS; j = j + 1) begin
62         1/1                              if (i != j) begin
63         1/1                                  expand[j][i] = 1'b1;
64                                          end
                        MISSING_ELSE
65                                      end
66                                  end
                        MISSING_ELSE
67                              end
68                      
69                              // Generate the value of use_history to be updated
70         1/1                  offset = 0;
71         1/1                  for (i = 0; i < C_CACHE_SASS; i = i + 1) begin
72         1/1                      for (j = i + 1; j < C_CACHE_SASS; j = j + 1) begin
73         1/1                          next_use_history[offset+j-i-1] = expand[i][j];
74                                  end
75         1/1                      offset = offset + C_CACHE_SASS - i - 1;
76                              end
77                      
78                              // Generate the LRU bits
79         1/1                  for (i = 0; i < C_CACHE_SASS; i = i + 1) begin
80         1/1                      next_lru[i] = &expand[i];

-------------------------------------------------------------------------------
Toggle Coverage for Instance : cache_tb.dut.cache_mem_inst.genblk1[6].LRU_update_inst
                Total Covered Percent 
Totals          4     4       100.00  
Total Bits      40    40      100.00  
Total Bits 0->1 20    20      100.00  
Total Bits 1->0 20    20      100.00  

                            
Ports          4  4  100.00 
Port Bits      40 40 100.00 
Port Bits 0->1 20 20 100.00 
Port Bits 1->0 20 20 100.00 

Port Details
                      Toggle Toggle 1->0 Toggle 0->1 Direction 
use_history[5:0]      Yes    Yes         Yes         INPUT     
access[3:0]           Yes    Yes         Yes         INPUT     
next_use_history[5:0] Yes    Yes         Yes         OUTPUT    
next_lru[3:0]         Yes    Yes         Yes         OUTPUT    


-------------------------------------------------------------------------------
===============================================================================
Module Instance : cache_tb.dut.cache_mem_inst.genblk1[7].LRU_update_inst
===============================================================================

Instance :

SCORE  LINE   TOGGLE 
100.00 100.00 100.00 


Instance's subtree :

SCORE  LINE   TOGGLE 
100.00 100.00 100.00 


Module : 

SCORE  LINE   TOGGLE NAME       
100.00 100.00 100.00 LRU_update 


Parent : 

SCORE  LINE   TOGGLE NAME           
 91.91 100.00  83.82 cache_mem_inst 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : cache_tb.dut.cache_mem_inst.genblk1[7].LRU_update_inst

             Line No.   Total   Covered  Percent
TOTAL                       23       23   100.00
ALWAYS             37       23       23   100.00

36                              // Expand the use_history to a C_CACHE_SASS * C_CACHE_SASS array
37         1/1                  offset  =   0;
38         1/1                  for (int unsigned i = 0; i < C_CACHE_SASS; i = i + 1) begin
39                                  // Diagnal
40         1/1                      expand[i][i] = 1'b1;
41                                  // Upper triangle
42         1/1                      for (int unsigned j = i + 1; j < C_CACHE_SASS; j = j + 1) begin
43         1/1                          expand[i][j]    =   use_history[offset+j-i-1];
44                                  end
45                                  // Lower triangle
46         1/1                      for (int unsigned j = 0; j < i; j = j + 1) begin
47         1/1                          expand[i][j]    =   !expand[j][i];
48                                  end
49         1/1                      offset = offset + C_CACHE_SASS - i - 1;
50                              end 
51                      
52                              // Update Matrix if there is an access
53         1/1                  for (i = 0; i < C_CACHE_SASS; i = i + 1) begin
54         1/1                      if (access[i]) begin
55         1/1                          for (j = 0; j < C_CACHE_SASS; j = j + 1) begin
56         1/1                              if (i != j) begin
57         1/1                                  expand[i][j] = 1'b0;
58                                          end
                        MISSING_ELSE
59                                      end
60                      
61         1/1                          for (j = 0; j < C_CACHE_SASS; j = j + 1) begin
62         1/1                              if (i != j) begin
63         1/1                                  expand[j][i] = 1'b1;
64                                          end
                        MISSING_ELSE
65                                      end
66                                  end
                        MISSING_ELSE
67                              end
68                      
69                              // Generate the value of use_history to be updated
70         1/1                  offset = 0;
71         1/1                  for (i = 0; i < C_CACHE_SASS; i = i + 1) begin
72         1/1                      for (j = i + 1; j < C_CACHE_SASS; j = j + 1) begin
73         1/1                          next_use_history[offset+j-i-1] = expand[i][j];
74                                  end
75         1/1                      offset = offset + C_CACHE_SASS - i - 1;
76                              end
77                      
78                              // Generate the LRU bits
79         1/1                  for (i = 0; i < C_CACHE_SASS; i = i + 1) begin
80         1/1                      next_lru[i] = &expand[i];

-------------------------------------------------------------------------------
Toggle Coverage for Instance : cache_tb.dut.cache_mem_inst.genblk1[7].LRU_update_inst
                Total Covered Percent 
Totals          4     4       100.00  
Total Bits      40    40      100.00  
Total Bits 0->1 20    20      100.00  
Total Bits 1->0 20    20      100.00  

                            
Ports          4  4  100.00 
Port Bits      40 40 100.00 
Port Bits 0->1 20 20 100.00 
Port Bits 1->0 20 20 100.00 

Port Details
                      Toggle Toggle 1->0 Toggle 0->1 Direction 
use_history[5:0]      Yes    Yes         Yes         INPUT     
access[3:0]           Yes    Yes         Yes         INPUT     
next_use_history[5:0] Yes    Yes         Yes         OUTPUT    
next_lru[3:0]         Yes    Yes         Yes         OUTPUT    


===============================================================================
Module : cache_tb
===============================================================================
SCORE  LINE   TOGGLE 
100.00 100.00 100.00 

Source File(s) : 

/afs/umich.edu/user/z/t/ztguan/group6w22/testbench/cache_tb.sv

Module self-instances :

SCORE  LINE   TOGGLE NAME     
100.00 100.00 100.00 cache_tb 



-------------------------------------------------------------------------------
Line Coverage for Module : cache_tb

             Line No.   Total   Covered  Percent
TOTAL                       19       19   100.00
INITIAL           563        4        4   100.00
INITIAL           615       15       15   100.00

562                         initial begin
563        1/1                  clk_i   =   0;
564        1/1                  forever begin
565        2/2                      #(C_CLOCK_PERIOD/2) clk_i   =   ~clk_i;
566                             end
567                         end
568                     
569                     // --------------------------------------------------------------------
570                     // Interface Instantiation
571                     // --------------------------------------------------------------------
572                         cache_if    _if     (clk_i);
573                     
574                     // --------------------------------------------------------------------
575                     // DUT Instantiation
576                     // --------------------------------------------------------------------
577                         cache dut (
578                             .mshr_array_mon_o   (_if.mshr_array_mon_o   ),
579                             .cache_array_mon_o  (_if.cache_array_mon_o  ),
580                             .clk_i              (    clk_i              ),
581                             .rst_i              (_if.rst_i              ),
582                             .proc2cache_i       (_if.proc2cache_i       ),
583                             .cache2proc_o       (_if.cache2proc_o       ),
584                             .memory_enable_i    (_if.memory_enable_i    ),
585                             .cache2mem_o        (_if.cache2mem_o        ),
586                             .mem2cache_i        (_if.mem2cache_i        )
587                         );
588                     
589                         // Instantiate the Data Memory
590                         mem mem_inst (
591                             // Inputs
592                             .clk               (    clk_i                   ),
593                             .proc2mem_command  (_if.cache2mem_o.command     ),
594                             .proc2mem_addr     (_if.cache2mem_o.addr        ),
595                             .proc2mem_data     (_if.cache2mem_o.data        ),
596                     `ifndef CACHE_MODE
597                             .proc2mem_size     (_if.cache2mem_o.size        ),
598                     `endif
599                             // Outputs
600                             .mem2proc_response (_if.mem2cache_i.response    ),
601                             .mem2proc_data     (_if.mem2cache_i.data        ),
602                             .mem2proc_tag      (_if.mem2cache_i.tag         )
603                         );
604                     // --------------------------------------------------------------------
605                     
606                     // --------------------------------------------------------------------
607                     // Test Instantiation
608                     // --------------------------------------------------------------------
609                         test    t0;
610                     
611                     // --------------------------------------------------------------------
612                     // Call test
613                     // --------------------------------------------------------------------
614                         initial begin
615        1/1                  _if.rst_i           =   'd1 ;
616        1/1                  _if.proc2cache_i    =   'd0 ;
617        1/1                  _if.memory_enable_i =   1'b1;
618        1/1                  for (int unsigned double_addr = 0; double_addr < `MEM_64BIT_LINES; double_addr++) begin
619        1/1                      mem_inst.unified_memory[double_addr]    =   64'b0;
620                             end
621        1/1                  $display("Start Test");
622                             // Apply reset and start stimulus
623        2/2                  #50 _if.rst_i   =   0;
624        1/1                  $display("reset = %0d", _if.rst_i);
625                     
626                     
627        1/1                  t0  =   new;
628        1/1                  t0.e0.vif   =   _if;
629        1/1                  t0.run();
630                     
631                             // Because multiple components and clock are running
632                             // in the background, we need to call $finish explicitly
633        1/1                  $display("@@PASSED");
634        2/2                  #50 $finish;

-------------------------------------------------------------------------------
Toggle Coverage for Module : cache_tb
                Total Covered Percent 
Totals          1     1       100.00  
Total Bits      2     2       100.00  
Total Bits 0->1 1     1       100.00  
Total Bits 1->0 1     1       100.00  

                            
Signals          1 1 100.00 
Signal Bits      2 2 100.00 
Signal Bits 0->1 1 1 100.00 
Signal Bits 1->0 1 1 100.00 

Signal Details
      Toggle Toggle 1->0 Toggle 0->1 
clk_i Yes    Yes         Yes         


-------------------------------------------------------------------------------
===============================================================================
Module Instance : cache_tb
===============================================================================

Instance :

SCORE  LINE   TOGGLE 
100.00 100.00 100.00 


Instance's subtree :

SCORE  LINE   TOGGLE 
 81.91  83.38  80.43 


Module : 

SCORE  LINE   TOGGLE NAME     
100.00 100.00 100.00 cache_tb 


Parent : 

none
----------------


Subtrees :

SCORE  LINE   TOGGLE NAME     
 86.02 --      86.02 _if      
 81.94  83.13  80.75 dut      
 75.65 100.00  51.30 mem_inst 



-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
